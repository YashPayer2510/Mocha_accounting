=== LOGIN TESTS STARTED: 2025-10-23 03:50:19 ===
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.3.5, pluggy-1.6.0 -- /opt/hostedtoolcache/Python/3.13.7/x64/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.11.0-1018-azure-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.6.0'}, 'Plugins': {'html': '4.1.1', 'rerunfailures': '16.1', 'Faker': '37.11.0', 'xdist': '3.8.0', 'metadata': '3.1.1'}, 'CI': 'true', 'JAVA_HOME': '/usr/lib/jvm/temurin-17-jdk-amd64'}
rootdir: /home/runner/work/Mocha_accounting/Mocha_accounting
plugins: html-4.1.1, rerunfailures-16.1, Faker-37.11.0, xdist-3.8.0, metadata-3.1.1
collecting ... collected 15 items

tests/test_signup_login/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] ERROR [  6%]
tests/test_signup_login/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] ERROR [ 13%]
tests/test_signup_login/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ERROR [ 20%]
tests/test_signup_login/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] ERROR [ 26%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username0] ERROR [ 33%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username1] ERROR [ 40%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username2] ERROR [ 46%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username3] ERROR [ 53%]
tests/test_signup_login/test_login.py::test_blank_username_validation ERROR [ 60%]
tests/test_signup_login/test_login.py::test_blank_password_validation ERROR [ 66%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username0] ERROR [ 73%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username1] ERROR [ 80%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username2] ERROR [ 86%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username3] ERROR [ 93%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username4] ERROR [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a898c20>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a898d70>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a898c20>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a898d70>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4a8992b0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a898c20>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a4a899010>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5636f9855f83 \\u003Cunknown>\\n#17 0x7f4e2f29caa4 \\u003Cunknown>\\n#18 0x7f4e2f329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5636f9856fea <unknown>
E       #1 0x5636f92d4d06 <unknown>
E       #2 0x5636f931032c <unknown>
E       #3 0x5636f930bf94 <unknown>
E       #4 0x5636f935b3b3 <unknown>
E       #5 0x5636f935aa66 <unknown>
E       #6 0x5636f934cbe3 <unknown>
E       #7 0x5636f93192d2 <unknown>
E       #8 0x5636f9319f91 <unknown>
E       #9 0x5636f981a9e8 <unknown>
E       #10 0x5636f981e84f <unknown>
E       #11 0x5636f9801ec9 <unknown>
E       #12 0x5636f981f3f5 <unknown>
E       #13 0x5636f97e774f <unknown>
E       #14 0x5636f9843cc8 <unknown>
E       #15 0x5636f9843ea3 <unknown>
E       #16 0x5636f9855f83 <unknown>
E       #17 0x7f4e2f29caa4 <unknown>
E       #18 0x7f4e2f329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5636f9856fea <unknown>
E           #1 0x5636f92d4d06 <unknown>
E           #2 0x5636f931032c <unknown>
E           #3 0x5636f930bf94 <unknown>
E           #4 0x5636f935b3b3 <unknown>
E           #5 0x5636f935aa66 <unknown>
E           #6 0x5636f934cbe3 <unknown>
E           #7 0x5636f93192d2 <unknown>
E           #8 0x5636f9319f91 <unknown>
E           #9 0x5636f981a9e8 <unknown>
E           #10 0x5636f981e84f <unknown>
E           #11 0x5636f9801ec9 <unknown>
E           #12 0x5636f981f3f5 <unknown>
E           #13 0x5636f97e774f <unknown>
E           #14 0x5636f9843cc8 <unknown>
E           #15 0x5636f9843ea3 <unknown>
E           #16 0x5636f9855f83 <unknown>
E           #17 0x7f4e2f29caa4 <unknown>
E           #18 0x7f4e2f329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:20,863 - INFO - Starting test with Chrome browser
2025-10-23 03:50:20,863 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:20,928 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:20,963 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:20,996 - INFO - There is no [linux64] chromedriver "141.0.7390.122" for browser google-chrome "141.0.7390" in cache
2025-10-23 03:50:20,996 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:21,101 - INFO - WebDriver version 141.0.7390.122 selected
2025-10-23 03:50:21,106 - INFO - Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
2025-10-23 03:50:21,107 - INFO - About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
2025-10-23 03:50:21,149 - INFO - Driver downloading response is 200
2025-10-23 03:50:21,200 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:21,346 - INFO - Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122]
2025-10-23 03:50:22,459 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5636f9856fea <unknown>
#1 0x5636f92d4d06 <unknown>
#2 0x5636f931032c <unknown>
#3 0x5636f930bf94 <unknown>
#4 0x5636f935b3b3 <unknown>
#5 0x5636f935aa66 <unknown>
#6 0x5636f934cbe3 <unknown>
#7 0x5636f93192d2 <unknown>
#8 0x5636f9319f91 <unknown>
#9 0x5636f981a9e8 <unknown>
#10 0x5636f981e84f <unknown>
#11 0x5636f9801ec9 <unknown>
#12 0x5636f981f3f5 <unknown>
#13 0x5636f97e774f <unknown>
#14 0x5636f9843cc8 <unknown>
#15 0x5636f9843ea3 <unknown>
#16 0x5636f9855f83 <unknown>
#17 0x7f4e2f29caa4 <unknown>
#18 0x7f4e2f329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 There is no [linux64] chromedriver "141.0.7390.122" for browser google-chrome "141.0.7390" in cache
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 WebDriver version 141.0.7390.122 selected
INFO     WDM:logger.py:11 Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 Driver downloading response is 200
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122]
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5636f9856fea <unknown>
#1 0x5636f92d4d06 <unknown>
#2 0x5636f931032c <unknown>
#3 0x5636f930bf94 <unknown>
#4 0x5636f935b3b3 <unknown>
#5 0x5636f935aa66 <unknown>
#6 0x5636f934cbe3 <unknown>
#7 0x5636f93192d2 <unknown>
#8 0x5636f9319f91 <unknown>
#9 0x5636f981a9e8 <unknown>
#10 0x5636f981e84f <unknown>
#11 0x5636f9801ec9 <unknown>
#12 0x5636f981f3f5 <unknown>
#13 0x5636f97e774f <unknown>
#14 0x5636f9843cc8 <unknown>
#15 0x5636f9843ea3 <unknown>
#16 0x5636f9855f83 <unknown>
#17 0x7f4e2f29caa4 <unknown>
#18 0x7f4e2f329c6c <unknown>
____ ERROR at setup of test_valid_login[samatakamble9@gmail.com-Samata@16] _____

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a88e710>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a88ec10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a88e710>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a88ec10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4a88efd0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a88e710>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a4a88ee90>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5635595cbf83 \\u003Cunknown>\\n#17 0x7f8f1409caa4 \\u003Cunknown>\\n#18 0x7f8f14129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5635595ccfea <unknown>
E       #1 0x56355904ad06 <unknown>
E       #2 0x56355908632c <unknown>
E       #3 0x563559081f94 <unknown>
E       #4 0x5635590d13b3 <unknown>
E       #5 0x5635590d0a66 <unknown>
E       #6 0x5635590c2be3 <unknown>
E       #7 0x56355908f2d2 <unknown>
E       #8 0x56355908ff91 <unknown>
E       #9 0x5635595909e8 <unknown>
E       #10 0x56355959484f <unknown>
E       #11 0x563559577ec9 <unknown>
E       #12 0x5635595953f5 <unknown>
E       #13 0x56355955d74f <unknown>
E       #14 0x5635595b9cc8 <unknown>
E       #15 0x5635595b9ea3 <unknown>
E       #16 0x5635595cbf83 <unknown>
E       #17 0x7f8f1409caa4 <unknown>
E       #18 0x7f8f14129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5635595ccfea <unknown>
E           #1 0x56355904ad06 <unknown>
E           #2 0x56355908632c <unknown>
E           #3 0x563559081f94 <unknown>
E           #4 0x5635590d13b3 <unknown>
E           #5 0x5635590d0a66 <unknown>
E           #6 0x5635590c2be3 <unknown>
E           #7 0x56355908f2d2 <unknown>
E           #8 0x56355908ff91 <unknown>
E           #9 0x5635595909e8 <unknown>
E           #10 0x56355959484f <unknown>
E           #11 0x563559577ec9 <unknown>
E           #12 0x5635595953f5 <unknown>
E           #13 0x56355955d74f <unknown>
E           #14 0x5635595b9cc8 <unknown>
E           #15 0x5635595b9ea3 <unknown>
E           #16 0x5635595cbf83 <unknown>
E           #17 0x7f8f1409caa4 <unknown>
E           #18 0x7f8f14129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:22,526 - INFO - Starting test with Chrome browser
2025-10-23 03:50:22,526 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:22,591 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:22,624 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:22,672 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:23,761 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5635595ccfea <unknown>
#1 0x56355904ad06 <unknown>
#2 0x56355908632c <unknown>
#3 0x563559081f94 <unknown>
#4 0x5635590d13b3 <unknown>
#5 0x5635590d0a66 <unknown>
#6 0x5635590c2be3 <unknown>
#7 0x56355908f2d2 <unknown>
#8 0x56355908ff91 <unknown>
#9 0x5635595909e8 <unknown>
#10 0x56355959484f <unknown>
#11 0x563559577ec9 <unknown>
#12 0x5635595953f5 <unknown>
#13 0x56355955d74f <unknown>
#14 0x5635595b9cc8 <unknown>
#15 0x5635595b9ea3 <unknown>
#16 0x5635595cbf83 <unknown>
#17 0x7f8f1409caa4 <unknown>
#18 0x7f8f14129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5635595ccfea <unknown>
#1 0x56355904ad06 <unknown>
#2 0x56355908632c <unknown>
#3 0x563559081f94 <unknown>
#4 0x5635590d13b3 <unknown>
#5 0x5635590d0a66 <unknown>
#6 0x5635590c2be3 <unknown>
#7 0x56355908f2d2 <unknown>
#8 0x56355908ff91 <unknown>
#9 0x5635595909e8 <unknown>
#10 0x56355959484f <unknown>
#11 0x563559577ec9 <unknown>
#12 0x5635595953f5 <unknown>
#13 0x56355955d74f <unknown>
#14 0x5635595b9cc8 <unknown>
#15 0x5635595b9ea3 <unknown>
#16 0x5635595cbf83 <unknown>
#17 0x7f8f1409caa4 <unknown>
#18 0x7f8f14129c6c <unknown>
__ ERROR at setup of test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ___

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a88ead0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a88ce10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a88ead0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a88ce10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4a88d310>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a88ead0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a48db4910>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x561ee4182f83 \\u003Cunknown>\\n#17 0x7f29cbc9caa4 \\u003Cunknown>\\n#18 0x7f29cbd29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x561ee4183fea <unknown>
E       #1 0x561ee3c01d06 <unknown>
E       #2 0x561ee3c3d32c <unknown>
E       #3 0x561ee3c38f94 <unknown>
E       #4 0x561ee3c883b3 <unknown>
E       #5 0x561ee3c87a66 <unknown>
E       #6 0x561ee3c79be3 <unknown>
E       #7 0x561ee3c462d2 <unknown>
E       #8 0x561ee3c46f91 <unknown>
E       #9 0x561ee41479e8 <unknown>
E       #10 0x561ee414b84f <unknown>
E       #11 0x561ee412eec9 <unknown>
E       #12 0x561ee414c3f5 <unknown>
E       #13 0x561ee411474f <unknown>
E       #14 0x561ee4170cc8 <unknown>
E       #15 0x561ee4170ea3 <unknown>
E       #16 0x561ee4182f83 <unknown>
E       #17 0x7f29cbc9caa4 <unknown>
E       #18 0x7f29cbd29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x561ee4183fea <unknown>
E           #1 0x561ee3c01d06 <unknown>
E           #2 0x561ee3c3d32c <unknown>
E           #3 0x561ee3c38f94 <unknown>
E           #4 0x561ee3c883b3 <unknown>
E           #5 0x561ee3c87a66 <unknown>
E           #6 0x561ee3c79be3 <unknown>
E           #7 0x561ee3c462d2 <unknown>
E           #8 0x561ee3c46f91 <unknown>
E           #9 0x561ee41479e8 <unknown>
E           #10 0x561ee414b84f <unknown>
E           #11 0x561ee412eec9 <unknown>
E           #12 0x561ee414c3f5 <unknown>
E           #13 0x561ee411474f <unknown>
E           #14 0x561ee4170cc8 <unknown>
E           #15 0x561ee4170ea3 <unknown>
E           #16 0x561ee4182f83 <unknown>
E           #17 0x7f29cbc9caa4 <unknown>
E           #18 0x7f29cbd29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:23,802 - INFO - Starting test with Chrome browser
2025-10-23 03:50:23,802 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:23,867 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:23,902 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:23,934 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:25,023 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x561ee4183fea <unknown>
#1 0x561ee3c01d06 <unknown>
#2 0x561ee3c3d32c <unknown>
#3 0x561ee3c38f94 <unknown>
#4 0x561ee3c883b3 <unknown>
#5 0x561ee3c87a66 <unknown>
#6 0x561ee3c79be3 <unknown>
#7 0x561ee3c462d2 <unknown>
#8 0x561ee3c46f91 <unknown>
#9 0x561ee41479e8 <unknown>
#10 0x561ee414b84f <unknown>
#11 0x561ee412eec9 <unknown>
#12 0x561ee414c3f5 <unknown>
#13 0x561ee411474f <unknown>
#14 0x561ee4170cc8 <unknown>
#15 0x561ee4170ea3 <unknown>
#16 0x561ee4182f83 <unknown>
#17 0x7f29cbc9caa4 <unknown>
#18 0x7f29cbd29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x561ee4183fea <unknown>
#1 0x561ee3c01d06 <unknown>
#2 0x561ee3c3d32c <unknown>
#3 0x561ee3c38f94 <unknown>
#4 0x561ee3c883b3 <unknown>
#5 0x561ee3c87a66 <unknown>
#6 0x561ee3c79be3 <unknown>
#7 0x561ee3c462d2 <unknown>
#8 0x561ee3c46f91 <unknown>
#9 0x561ee41479e8 <unknown>
#10 0x561ee414b84f <unknown>
#11 0x561ee412eec9 <unknown>
#12 0x561ee414c3f5 <unknown>
#13 0x561ee411474f <unknown>
#14 0x561ee4170cc8 <unknown>
#15 0x561ee4170ea3 <unknown>
#16 0x561ee4182f83 <unknown>
#17 0x7f29cbc9caa4 <unknown>
#18 0x7f29cbd29c6c <unknown>
_ ERROR at setup of test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a85ec40>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a85ec40>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4a85f100>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85eb10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a4a85efd0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x557a0be80f83 \\u003Cunknown>\\n#17 0x7f2232a9caa4 \\u003Cunknown>\\n#18 0x7f2232b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x557a0be81fea <unknown>
E       #1 0x557a0b8ffd06 <unknown>
E       #2 0x557a0b93b32c <unknown>
E       #3 0x557a0b936f94 <unknown>
E       #4 0x557a0b9863b3 <unknown>
E       #5 0x557a0b985a66 <unknown>
E       #6 0x557a0b977be3 <unknown>
E       #7 0x557a0b9442d2 <unknown>
E       #8 0x557a0b944f91 <unknown>
E       #9 0x557a0be459e8 <unknown>
E       #10 0x557a0be4984f <unknown>
E       #11 0x557a0be2cec9 <unknown>
E       #12 0x557a0be4a3f5 <unknown>
E       #13 0x557a0be1274f <unknown>
E       #14 0x557a0be6ecc8 <unknown>
E       #15 0x557a0be6eea3 <unknown>
E       #16 0x557a0be80f83 <unknown>
E       #17 0x7f2232a9caa4 <unknown>
E       #18 0x7f2232b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x557a0be81fea <unknown>
E           #1 0x557a0b8ffd06 <unknown>
E           #2 0x557a0b93b32c <unknown>
E           #3 0x557a0b936f94 <unknown>
E           #4 0x557a0b9863b3 <unknown>
E           #5 0x557a0b985a66 <unknown>
E           #6 0x557a0b977be3 <unknown>
E           #7 0x557a0b9442d2 <unknown>
E           #8 0x557a0b944f91 <unknown>
E           #9 0x557a0be459e8 <unknown>
E           #10 0x557a0be4984f <unknown>
E           #11 0x557a0be2cec9 <unknown>
E           #12 0x557a0be4a3f5 <unknown>
E           #13 0x557a0be1274f <unknown>
E           #14 0x557a0be6ecc8 <unknown>
E           #15 0x557a0be6eea3 <unknown>
E           #16 0x557a0be80f83 <unknown>
E           #17 0x7f2232a9caa4 <unknown>
E           #18 0x7f2232b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:25,062 - INFO - Starting test with Chrome browser
2025-10-23 03:50:25,062 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:25,129 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:25,163 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:25,199 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:26,288 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x557a0be81fea <unknown>
#1 0x557a0b8ffd06 <unknown>
#2 0x557a0b93b32c <unknown>
#3 0x557a0b936f94 <unknown>
#4 0x557a0b9863b3 <unknown>
#5 0x557a0b985a66 <unknown>
#6 0x557a0b977be3 <unknown>
#7 0x557a0b9442d2 <unknown>
#8 0x557a0b944f91 <unknown>
#9 0x557a0be459e8 <unknown>
#10 0x557a0be4984f <unknown>
#11 0x557a0be2cec9 <unknown>
#12 0x557a0be4a3f5 <unknown>
#13 0x557a0be1274f <unknown>
#14 0x557a0be6ecc8 <unknown>
#15 0x557a0be6eea3 <unknown>
#16 0x557a0be80f83 <unknown>
#17 0x7f2232a9caa4 <unknown>
#18 0x7f2232b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x557a0be81fea <unknown>
#1 0x557a0b8ffd06 <unknown>
#2 0x557a0b93b32c <unknown>
#3 0x557a0b936f94 <unknown>
#4 0x557a0b9863b3 <unknown>
#5 0x557a0b985a66 <unknown>
#6 0x557a0b977be3 <unknown>
#7 0x557a0b9442d2 <unknown>
#8 0x557a0b944f91 <unknown>
#9 0x557a0be459e8 <unknown>
#10 0x557a0be4984f <unknown>
#11 0x557a0be2cec9 <unknown>
#12 0x557a0be4a3f5 <unknown>
#13 0x557a0be1274f <unknown>
#14 0x557a0be6ecc8 <unknown>
#15 0x557a0be6eea3 <unknown>
#16 0x557a0be80f83 <unknown>
#17 0x7f2232a9caa4 <unknown>
#18 0x7f2232b29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username0] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85f950>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48d682b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85f950>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48d682b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a48d68510>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85f950>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a48d683e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55d9e9897f83 \\u003Cunknown>\\n#17 0x7fca9269caa4 \\u003Cunknown>\\n#18 0x7fca92729c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55d9e9898fea <unknown>
E       #1 0x55d9e9316d06 <unknown>
E       #2 0x55d9e935232c <unknown>
E       #3 0x55d9e934df94 <unknown>
E       #4 0x55d9e939d3b3 <unknown>
E       #5 0x55d9e939ca66 <unknown>
E       #6 0x55d9e938ebe3 <unknown>
E       #7 0x55d9e935b2d2 <unknown>
E       #8 0x55d9e935bf91 <unknown>
E       #9 0x55d9e985c9e8 <unknown>
E       #10 0x55d9e986084f <unknown>
E       #11 0x55d9e9843ec9 <unknown>
E       #12 0x55d9e98613f5 <unknown>
E       #13 0x55d9e982974f <unknown>
E       #14 0x55d9e9885cc8 <unknown>
E       #15 0x55d9e9885ea3 <unknown>
E       #16 0x55d9e9897f83 <unknown>
E       #17 0x7fca9269caa4 <unknown>
E       #18 0x7fca92729c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55d9e9898fea <unknown>
E           #1 0x55d9e9316d06 <unknown>
E           #2 0x55d9e935232c <unknown>
E           #3 0x55d9e934df94 <unknown>
E           #4 0x55d9e939d3b3 <unknown>
E           #5 0x55d9e939ca66 <unknown>
E           #6 0x55d9e938ebe3 <unknown>
E           #7 0x55d9e935b2d2 <unknown>
E           #8 0x55d9e935bf91 <unknown>
E           #9 0x55d9e985c9e8 <unknown>
E           #10 0x55d9e986084f <unknown>
E           #11 0x55d9e9843ec9 <unknown>
E           #12 0x55d9e98613f5 <unknown>
E           #13 0x55d9e982974f <unknown>
E           #14 0x55d9e9885cc8 <unknown>
E           #15 0x55d9e9885ea3 <unknown>
E           #16 0x55d9e9897f83 <unknown>
E           #17 0x7fca9269caa4 <unknown>
E           #18 0x7fca92729c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:26,327 - INFO - Starting test with Chrome browser
2025-10-23 03:50:26,327 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:26,391 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:26,427 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:26,459 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:27,549 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d9e9898fea <unknown>
#1 0x55d9e9316d06 <unknown>
#2 0x55d9e935232c <unknown>
#3 0x55d9e934df94 <unknown>
#4 0x55d9e939d3b3 <unknown>
#5 0x55d9e939ca66 <unknown>
#6 0x55d9e938ebe3 <unknown>
#7 0x55d9e935b2d2 <unknown>
#8 0x55d9e935bf91 <unknown>
#9 0x55d9e985c9e8 <unknown>
#10 0x55d9e986084f <unknown>
#11 0x55d9e9843ec9 <unknown>
#12 0x55d9e98613f5 <unknown>
#13 0x55d9e982974f <unknown>
#14 0x55d9e9885cc8 <unknown>
#15 0x55d9e9885ea3 <unknown>
#16 0x55d9e9897f83 <unknown>
#17 0x7fca9269caa4 <unknown>
#18 0x7fca92729c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d9e9898fea <unknown>
#1 0x55d9e9316d06 <unknown>
#2 0x55d9e935232c <unknown>
#3 0x55d9e934df94 <unknown>
#4 0x55d9e939d3b3 <unknown>
#5 0x55d9e939ca66 <unknown>
#6 0x55d9e938ebe3 <unknown>
#7 0x55d9e935b2d2 <unknown>
#8 0x55d9e935bf91 <unknown>
#9 0x55d9e985c9e8 <unknown>
#10 0x55d9e986084f <unknown>
#11 0x55d9e9843ec9 <unknown>
#12 0x55d9e98613f5 <unknown>
#13 0x55d9e982974f <unknown>
#14 0x55d9e9885cc8 <unknown>
#15 0x55d9e9885ea3 <unknown>
#16 0x55d9e9897f83 <unknown>
#17 0x7fca9269caa4 <unknown>
#18 0x7fca92729c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username1] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85ab10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48de43b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85ab10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48de43b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a48de4b90>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a85ab10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a48de4a70>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5584c90eaf83 \\u003Cunknown>\\n#17 0x7fde4209caa4 \\u003Cunknown>\\n#18 0x7fde42129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5584c90ebfea <unknown>
E       #1 0x5584c8b69d06 <unknown>
E       #2 0x5584c8ba532c <unknown>
E       #3 0x5584c8ba0f94 <unknown>
E       #4 0x5584c8bf03b3 <unknown>
E       #5 0x5584c8befa66 <unknown>
E       #6 0x5584c8be1be3 <unknown>
E       #7 0x5584c8bae2d2 <unknown>
E       #8 0x5584c8baef91 <unknown>
E       #9 0x5584c90af9e8 <unknown>
E       #10 0x5584c90b384f <unknown>
E       #11 0x5584c9096ec9 <unknown>
E       #12 0x5584c90b43f5 <unknown>
E       #13 0x5584c907c74f <unknown>
E       #14 0x5584c90d8cc8 <unknown>
E       #15 0x5584c90d8ea3 <unknown>
E       #16 0x5584c90eaf83 <unknown>
E       #17 0x7fde4209caa4 <unknown>
E       #18 0x7fde42129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5584c90ebfea <unknown>
E           #1 0x5584c8b69d06 <unknown>
E           #2 0x5584c8ba532c <unknown>
E           #3 0x5584c8ba0f94 <unknown>
E           #4 0x5584c8bf03b3 <unknown>
E           #5 0x5584c8befa66 <unknown>
E           #6 0x5584c8be1be3 <unknown>
E           #7 0x5584c8bae2d2 <unknown>
E           #8 0x5584c8baef91 <unknown>
E           #9 0x5584c90af9e8 <unknown>
E           #10 0x5584c90b384f <unknown>
E           #11 0x5584c9096ec9 <unknown>
E           #12 0x5584c90b43f5 <unknown>
E           #13 0x5584c907c74f <unknown>
E           #14 0x5584c90d8cc8 <unknown>
E           #15 0x5584c90d8ea3 <unknown>
E           #16 0x5584c90eaf83 <unknown>
E           #17 0x7fde4209caa4 <unknown>
E           #18 0x7fde42129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:27,588 - INFO - Starting test with Chrome browser
2025-10-23 03:50:27,588 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:27,653 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:27,687 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:27,721 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:28,810 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5584c90ebfea <unknown>
#1 0x5584c8b69d06 <unknown>
#2 0x5584c8ba532c <unknown>
#3 0x5584c8ba0f94 <unknown>
#4 0x5584c8bf03b3 <unknown>
#5 0x5584c8befa66 <unknown>
#6 0x5584c8be1be3 <unknown>
#7 0x5584c8bae2d2 <unknown>
#8 0x5584c8baef91 <unknown>
#9 0x5584c90af9e8 <unknown>
#10 0x5584c90b384f <unknown>
#11 0x5584c9096ec9 <unknown>
#12 0x5584c90b43f5 <unknown>
#13 0x5584c907c74f <unknown>
#14 0x5584c90d8cc8 <unknown>
#15 0x5584c90d8ea3 <unknown>
#16 0x5584c90eaf83 <unknown>
#17 0x7fde4209caa4 <unknown>
#18 0x7fde42129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5584c90ebfea <unknown>
#1 0x5584c8b69d06 <unknown>
#2 0x5584c8ba532c <unknown>
#3 0x5584c8ba0f94 <unknown>
#4 0x5584c8bf03b3 <unknown>
#5 0x5584c8befa66 <unknown>
#6 0x5584c8be1be3 <unknown>
#7 0x5584c8bae2d2 <unknown>
#8 0x5584c8baef91 <unknown>
#9 0x5584c90af9e8 <unknown>
#10 0x5584c90b384f <unknown>
#11 0x5584c9096ec9 <unknown>
#12 0x5584c90b43f5 <unknown>
#13 0x5584c907c74f <unknown>
#14 0x5584c90d8cc8 <unknown>
#15 0x5584c90d8ea3 <unknown>
#16 0x5584c90eaf83 <unknown>
#17 0x7fde4209caa4 <unknown>
#18 0x7fde42129c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username2] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8af8a0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a8af9b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8af8a0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a8af9b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4a8aead0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8af8a0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a4a8aebe0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x556ab8763f83 \\u003Cunknown>\\n#17 0x7f8a4d29caa4 \\u003Cunknown>\\n#18 0x7f8a4d329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x556ab8764fea <unknown>
E       #1 0x556ab81e2d06 <unknown>
E       #2 0x556ab821e32c <unknown>
E       #3 0x556ab8219f94 <unknown>
E       #4 0x556ab82693b3 <unknown>
E       #5 0x556ab8268a66 <unknown>
E       #6 0x556ab825abe3 <unknown>
E       #7 0x556ab82272d2 <unknown>
E       #8 0x556ab8227f91 <unknown>
E       #9 0x556ab87289e8 <unknown>
E       #10 0x556ab872c84f <unknown>
E       #11 0x556ab870fec9 <unknown>
E       #12 0x556ab872d3f5 <unknown>
E       #13 0x556ab86f574f <unknown>
E       #14 0x556ab8751cc8 <unknown>
E       #15 0x556ab8751ea3 <unknown>
E       #16 0x556ab8763f83 <unknown>
E       #17 0x7f8a4d29caa4 <unknown>
E       #18 0x7f8a4d329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x556ab8764fea <unknown>
E           #1 0x556ab81e2d06 <unknown>
E           #2 0x556ab821e32c <unknown>
E           #3 0x556ab8219f94 <unknown>
E           #4 0x556ab82693b3 <unknown>
E           #5 0x556ab8268a66 <unknown>
E           #6 0x556ab825abe3 <unknown>
E           #7 0x556ab82272d2 <unknown>
E           #8 0x556ab8227f91 <unknown>
E           #9 0x556ab87289e8 <unknown>
E           #10 0x556ab872c84f <unknown>
E           #11 0x556ab870fec9 <unknown>
E           #12 0x556ab872d3f5 <unknown>
E           #13 0x556ab86f574f <unknown>
E           #14 0x556ab8751cc8 <unknown>
E           #15 0x556ab8751ea3 <unknown>
E           #16 0x556ab8763f83 <unknown>
E           #17 0x7f8a4d29caa4 <unknown>
E           #18 0x7f8a4d329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:28,850 - INFO - Starting test with Chrome browser
2025-10-23 03:50:28,850 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:28,916 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:28,950 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:28,982 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:30,069 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x556ab8764fea <unknown>
#1 0x556ab81e2d06 <unknown>
#2 0x556ab821e32c <unknown>
#3 0x556ab8219f94 <unknown>
#4 0x556ab82693b3 <unknown>
#5 0x556ab8268a66 <unknown>
#6 0x556ab825abe3 <unknown>
#7 0x556ab82272d2 <unknown>
#8 0x556ab8227f91 <unknown>
#9 0x556ab87289e8 <unknown>
#10 0x556ab872c84f <unknown>
#11 0x556ab870fec9 <unknown>
#12 0x556ab872d3f5 <unknown>
#13 0x556ab86f574f <unknown>
#14 0x556ab8751cc8 <unknown>
#15 0x556ab8751ea3 <unknown>
#16 0x556ab8763f83 <unknown>
#17 0x7f8a4d29caa4 <unknown>
#18 0x7f8a4d329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x556ab8764fea <unknown>
#1 0x556ab81e2d06 <unknown>
#2 0x556ab821e32c <unknown>
#3 0x556ab8219f94 <unknown>
#4 0x556ab82693b3 <unknown>
#5 0x556ab8268a66 <unknown>
#6 0x556ab825abe3 <unknown>
#7 0x556ab82272d2 <unknown>
#8 0x556ab8227f91 <unknown>
#9 0x556ab87289e8 <unknown>
#10 0x556ab872c84f <unknown>
#11 0x556ab870fec9 <unknown>
#12 0x556ab872d3f5 <unknown>
#13 0x556ab86f574f <unknown>
#14 0x556ab8751cc8 <unknown>
#15 0x556ab8751ea3 <unknown>
#16 0x556ab8763f83 <unknown>
#17 0x7f8a4d29caa4 <unknown>
#18 0x7f8a4d329c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username3] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8acd10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a494f0c00>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8acd10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a494f0c00>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a494f08d0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8acd10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a494f09e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55ccb0a9ff83 \\u003Cunknown>\\n#17 0x7fcf3ca9caa4 \\u003Cunknown>\\n#18 0x7fcf3cb29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55ccb0aa0fea <unknown>
E       #1 0x55ccb051ed06 <unknown>
E       #2 0x55ccb055a32c <unknown>
E       #3 0x55ccb0555f94 <unknown>
E       #4 0x55ccb05a53b3 <unknown>
E       #5 0x55ccb05a4a66 <unknown>
E       #6 0x55ccb0596be3 <unknown>
E       #7 0x55ccb05632d2 <unknown>
E       #8 0x55ccb0563f91 <unknown>
E       #9 0x55ccb0a649e8 <unknown>
E       #10 0x55ccb0a6884f <unknown>
E       #11 0x55ccb0a4bec9 <unknown>
E       #12 0x55ccb0a693f5 <unknown>
E       #13 0x55ccb0a3174f <unknown>
E       #14 0x55ccb0a8dcc8 <unknown>
E       #15 0x55ccb0a8dea3 <unknown>
E       #16 0x55ccb0a9ff83 <unknown>
E       #17 0x7fcf3ca9caa4 <unknown>
E       #18 0x7fcf3cb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55ccb0aa0fea <unknown>
E           #1 0x55ccb051ed06 <unknown>
E           #2 0x55ccb055a32c <unknown>
E           #3 0x55ccb0555f94 <unknown>
E           #4 0x55ccb05a53b3 <unknown>
E           #5 0x55ccb05a4a66 <unknown>
E           #6 0x55ccb0596be3 <unknown>
E           #7 0x55ccb05632d2 <unknown>
E           #8 0x55ccb0563f91 <unknown>
E           #9 0x55ccb0a649e8 <unknown>
E           #10 0x55ccb0a6884f <unknown>
E           #11 0x55ccb0a4bec9 <unknown>
E           #12 0x55ccb0a693f5 <unknown>
E           #13 0x55ccb0a3174f <unknown>
E           #14 0x55ccb0a8dcc8 <unknown>
E           #15 0x55ccb0a8dea3 <unknown>
E           #16 0x55ccb0a9ff83 <unknown>
E           #17 0x7fcf3ca9caa4 <unknown>
E           #18 0x7fcf3cb29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:30,109 - INFO - Starting test with Chrome browser
2025-10-23 03:50:30,110 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:30,176 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:30,210 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:30,245 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:31,333 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ccb0aa0fea <unknown>
#1 0x55ccb051ed06 <unknown>
#2 0x55ccb055a32c <unknown>
#3 0x55ccb0555f94 <unknown>
#4 0x55ccb05a53b3 <unknown>
#5 0x55ccb05a4a66 <unknown>
#6 0x55ccb0596be3 <unknown>
#7 0x55ccb05632d2 <unknown>
#8 0x55ccb0563f91 <unknown>
#9 0x55ccb0a649e8 <unknown>
#10 0x55ccb0a6884f <unknown>
#11 0x55ccb0a4bec9 <unknown>
#12 0x55ccb0a693f5 <unknown>
#13 0x55ccb0a3174f <unknown>
#14 0x55ccb0a8dcc8 <unknown>
#15 0x55ccb0a8dea3 <unknown>
#16 0x55ccb0a9ff83 <unknown>
#17 0x7fcf3ca9caa4 <unknown>
#18 0x7fcf3cb29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ccb0aa0fea <unknown>
#1 0x55ccb051ed06 <unknown>
#2 0x55ccb055a32c <unknown>
#3 0x55ccb0555f94 <unknown>
#4 0x55ccb05a53b3 <unknown>
#5 0x55ccb05a4a66 <unknown>
#6 0x55ccb0596be3 <unknown>
#7 0x55ccb05632d2 <unknown>
#8 0x55ccb0563f91 <unknown>
#9 0x55ccb0a649e8 <unknown>
#10 0x55ccb0a6884f <unknown>
#11 0x55ccb0a4bec9 <unknown>
#12 0x55ccb0a693f5 <unknown>
#13 0x55ccb0a3174f <unknown>
#14 0x55ccb0a8dcc8 <unknown>
#15 0x55ccb0a8dea3 <unknown>
#16 0x55ccb0a9ff83 <unknown>
#17 0x7fcf3ca9caa4 <unknown>
#18 0x7fcf3cb29c6c <unknown>
_______________ ERROR at setup of test_blank_username_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48db0450>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48db0550>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48db0450>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48db0550>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a48db0050>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48db0450>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a48db0750>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x559727759f83 \\u003Cunknown>\\n#17 0x7f3ba949caa4 \\u003Cunknown>\\n#18 0x7f3ba9529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55972775afea <unknown>
E       #1 0x5597271d8d06 <unknown>
E       #2 0x55972721432c <unknown>
E       #3 0x55972720ff94 <unknown>
E       #4 0x55972725f3b3 <unknown>
E       #5 0x55972725ea66 <unknown>
E       #6 0x559727250be3 <unknown>
E       #7 0x55972721d2d2 <unknown>
E       #8 0x55972721df91 <unknown>
E       #9 0x55972771e9e8 <unknown>
E       #10 0x55972772284f <unknown>
E       #11 0x559727705ec9 <unknown>
E       #12 0x5597277233f5 <unknown>
E       #13 0x5597276eb74f <unknown>
E       #14 0x559727747cc8 <unknown>
E       #15 0x559727747ea3 <unknown>
E       #16 0x559727759f83 <unknown>
E       #17 0x7f3ba949caa4 <unknown>
E       #18 0x7f3ba9529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55972775afea <unknown>
E           #1 0x5597271d8d06 <unknown>
E           #2 0x55972721432c <unknown>
E           #3 0x55972720ff94 <unknown>
E           #4 0x55972725f3b3 <unknown>
E           #5 0x55972725ea66 <unknown>
E           #6 0x559727250be3 <unknown>
E           #7 0x55972721d2d2 <unknown>
E           #8 0x55972721df91 <unknown>
E           #9 0x55972771e9e8 <unknown>
E           #10 0x55972772284f <unknown>
E           #11 0x559727705ec9 <unknown>
E           #12 0x5597277233f5 <unknown>
E           #13 0x5597276eb74f <unknown>
E           #14 0x559727747cc8 <unknown>
E           #15 0x559727747ea3 <unknown>
E           #16 0x559727759f83 <unknown>
E           #17 0x7f3ba949caa4 <unknown>
E           #18 0x7f3ba9529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:31,372 - INFO - Starting test with Chrome browser
2025-10-23 03:50:31,373 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:31,437 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:31,472 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:31,505 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:32,593 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55972775afea <unknown>
#1 0x5597271d8d06 <unknown>
#2 0x55972721432c <unknown>
#3 0x55972720ff94 <unknown>
#4 0x55972725f3b3 <unknown>
#5 0x55972725ea66 <unknown>
#6 0x559727250be3 <unknown>
#7 0x55972721d2d2 <unknown>
#8 0x55972721df91 <unknown>
#9 0x55972771e9e8 <unknown>
#10 0x55972772284f <unknown>
#11 0x559727705ec9 <unknown>
#12 0x5597277233f5 <unknown>
#13 0x5597276eb74f <unknown>
#14 0x559727747cc8 <unknown>
#15 0x559727747ea3 <unknown>
#16 0x559727759f83 <unknown>
#17 0x7f3ba949caa4 <unknown>
#18 0x7f3ba9529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55972775afea <unknown>
#1 0x5597271d8d06 <unknown>
#2 0x55972721432c <unknown>
#3 0x55972720ff94 <unknown>
#4 0x55972725f3b3 <unknown>
#5 0x55972725ea66 <unknown>
#6 0x559727250be3 <unknown>
#7 0x55972721d2d2 <unknown>
#8 0x55972721df91 <unknown>
#9 0x55972771e9e8 <unknown>
#10 0x55972772284f <unknown>
#11 0x559727705ec9 <unknown>
#12 0x5597277233f5 <unknown>
#13 0x5597276eb74f <unknown>
#14 0x559727747cc8 <unknown>
#15 0x559727747ea3 <unknown>
#16 0x559727759f83 <unknown>
#17 0x7f3ba949caa4 <unknown>
#18 0x7f3ba9529c6c <unknown>
_______________ ERROR at setup of test_blank_password_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48db2550>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48db2850>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48db2550>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48db2850>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a48db2d50>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48db2550>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a48db2c50>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55b8dec27f83 \\u003Cunknown>\\n#17 0x7f3cf5a9caa4 \\u003Cunknown>\\n#18 0x7f3cf5b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55b8dec28fea <unknown>
E       #1 0x55b8de6a6d06 <unknown>
E       #2 0x55b8de6e232c <unknown>
E       #3 0x55b8de6ddf94 <unknown>
E       #4 0x55b8de72d3b3 <unknown>
E       #5 0x55b8de72ca66 <unknown>
E       #6 0x55b8de71ebe3 <unknown>
E       #7 0x55b8de6eb2d2 <unknown>
E       #8 0x55b8de6ebf91 <unknown>
E       #9 0x55b8debec9e8 <unknown>
E       #10 0x55b8debf084f <unknown>
E       #11 0x55b8debd3ec9 <unknown>
E       #12 0x55b8debf13f5 <unknown>
E       #13 0x55b8debb974f <unknown>
E       #14 0x55b8dec15cc8 <unknown>
E       #15 0x55b8dec15ea3 <unknown>
E       #16 0x55b8dec27f83 <unknown>
E       #17 0x7f3cf5a9caa4 <unknown>
E       #18 0x7f3cf5b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55b8dec28fea <unknown>
E           #1 0x55b8de6a6d06 <unknown>
E           #2 0x55b8de6e232c <unknown>
E           #3 0x55b8de6ddf94 <unknown>
E           #4 0x55b8de72d3b3 <unknown>
E           #5 0x55b8de72ca66 <unknown>
E           #6 0x55b8de71ebe3 <unknown>
E           #7 0x55b8de6eb2d2 <unknown>
E           #8 0x55b8de6ebf91 <unknown>
E           #9 0x55b8debec9e8 <unknown>
E           #10 0x55b8debf084f <unknown>
E           #11 0x55b8debd3ec9 <unknown>
E           #12 0x55b8debf13f5 <unknown>
E           #13 0x55b8debb974f <unknown>
E           #14 0x55b8dec15cc8 <unknown>
E           #15 0x55b8dec15ea3 <unknown>
E           #16 0x55b8dec27f83 <unknown>
E           #17 0x7f3cf5a9caa4 <unknown>
E           #18 0x7f3cf5b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:32,637 - INFO - Starting test with Chrome browser
2025-10-23 03:50:32,637 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:32,702 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:32,736 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:32,770 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:33,859 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b8dec28fea <unknown>
#1 0x55b8de6a6d06 <unknown>
#2 0x55b8de6e232c <unknown>
#3 0x55b8de6ddf94 <unknown>
#4 0x55b8de72d3b3 <unknown>
#5 0x55b8de72ca66 <unknown>
#6 0x55b8de71ebe3 <unknown>
#7 0x55b8de6eb2d2 <unknown>
#8 0x55b8de6ebf91 <unknown>
#9 0x55b8debec9e8 <unknown>
#10 0x55b8debf084f <unknown>
#11 0x55b8debd3ec9 <unknown>
#12 0x55b8debf13f5 <unknown>
#13 0x55b8debb974f <unknown>
#14 0x55b8dec15cc8 <unknown>
#15 0x55b8dec15ea3 <unknown>
#16 0x55b8dec27f83 <unknown>
#17 0x7f3cf5a9caa4 <unknown>
#18 0x7f3cf5b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b8dec28fea <unknown>
#1 0x55b8de6a6d06 <unknown>
#2 0x55b8de6e232c <unknown>
#3 0x55b8de6ddf94 <unknown>
#4 0x55b8de72d3b3 <unknown>
#5 0x55b8de72ca66 <unknown>
#6 0x55b8de71ebe3 <unknown>
#7 0x55b8de6eb2d2 <unknown>
#8 0x55b8de6ebf91 <unknown>
#9 0x55b8debec9e8 <unknown>
#10 0x55b8debf084f <unknown>
#11 0x55b8debd3ec9 <unknown>
#12 0x55b8debf13f5 <unknown>
#13 0x55b8debb974f <unknown>
#14 0x55b8dec15cc8 <unknown>
#15 0x55b8dec15ea3 <unknown>
#16 0x55b8dec27f83 <unknown>
#17 0x7f3cf5a9caa4 <unknown>
#18 0x7f3cf5b29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username0] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8ec320>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a8ed310>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8ec320>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a8ed310>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4a8ed220>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8ec320>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a4a8edd60>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55b6f51a4f83 \\u003Cunknown>\\n#17 0x7fb33409caa4 \\u003Cunknown>\\n#18 0x7fb334129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55b6f51a5fea <unknown>
E       #1 0x55b6f4c23d06 <unknown>
E       #2 0x55b6f4c5f32c <unknown>
E       #3 0x55b6f4c5af94 <unknown>
E       #4 0x55b6f4caa3b3 <unknown>
E       #5 0x55b6f4ca9a66 <unknown>
E       #6 0x55b6f4c9bbe3 <unknown>
E       #7 0x55b6f4c682d2 <unknown>
E       #8 0x55b6f4c68f91 <unknown>
E       #9 0x55b6f51699e8 <unknown>
E       #10 0x55b6f516d84f <unknown>
E       #11 0x55b6f5150ec9 <unknown>
E       #12 0x55b6f516e3f5 <unknown>
E       #13 0x55b6f513674f <unknown>
E       #14 0x55b6f5192cc8 <unknown>
E       #15 0x55b6f5192ea3 <unknown>
E       #16 0x55b6f51a4f83 <unknown>
E       #17 0x7fb33409caa4 <unknown>
E       #18 0x7fb334129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55b6f51a5fea <unknown>
E           #1 0x55b6f4c23d06 <unknown>
E           #2 0x55b6f4c5f32c <unknown>
E           #3 0x55b6f4c5af94 <unknown>
E           #4 0x55b6f4caa3b3 <unknown>
E           #5 0x55b6f4ca9a66 <unknown>
E           #6 0x55b6f4c9bbe3 <unknown>
E           #7 0x55b6f4c682d2 <unknown>
E           #8 0x55b6f4c68f91 <unknown>
E           #9 0x55b6f51699e8 <unknown>
E           #10 0x55b6f516d84f <unknown>
E           #11 0x55b6f5150ec9 <unknown>
E           #12 0x55b6f516e3f5 <unknown>
E           #13 0x55b6f513674f <unknown>
E           #14 0x55b6f5192cc8 <unknown>
E           #15 0x55b6f5192ea3 <unknown>
E           #16 0x55b6f51a4f83 <unknown>
E           #17 0x7fb33409caa4 <unknown>
E           #18 0x7fb334129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:33,900 - INFO - Starting test with Chrome browser
2025-10-23 03:50:33,900 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:33,965 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:33,999 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:34,033 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:35,123 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b6f51a5fea <unknown>
#1 0x55b6f4c23d06 <unknown>
#2 0x55b6f4c5f32c <unknown>
#3 0x55b6f4c5af94 <unknown>
#4 0x55b6f4caa3b3 <unknown>
#5 0x55b6f4ca9a66 <unknown>
#6 0x55b6f4c9bbe3 <unknown>
#7 0x55b6f4c682d2 <unknown>
#8 0x55b6f4c68f91 <unknown>
#9 0x55b6f51699e8 <unknown>
#10 0x55b6f516d84f <unknown>
#11 0x55b6f5150ec9 <unknown>
#12 0x55b6f516e3f5 <unknown>
#13 0x55b6f513674f <unknown>
#14 0x55b6f5192cc8 <unknown>
#15 0x55b6f5192ea3 <unknown>
#16 0x55b6f51a4f83 <unknown>
#17 0x7fb33409caa4 <unknown>
#18 0x7fb334129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b6f51a5fea <unknown>
#1 0x55b6f4c23d06 <unknown>
#2 0x55b6f4c5f32c <unknown>
#3 0x55b6f4c5af94 <unknown>
#4 0x55b6f4caa3b3 <unknown>
#5 0x55b6f4ca9a66 <unknown>
#6 0x55b6f4c9bbe3 <unknown>
#7 0x55b6f4c682d2 <unknown>
#8 0x55b6f4c68f91 <unknown>
#9 0x55b6f51699e8 <unknown>
#10 0x55b6f516d84f <unknown>
#11 0x55b6f5150ec9 <unknown>
#12 0x55b6f516e3f5 <unknown>
#13 0x55b6f513674f <unknown>
#14 0x55b6f5192cc8 <unknown>
#15 0x55b6f5192ea3 <unknown>
#16 0x55b6f51a4f83 <unknown>
#17 0x7fb33409caa4 <unknown>
#18 0x7fb334129c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username1] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8ee3f0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a8ee990>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8ee3f0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a8ee990>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a48d50230>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a8ee3f0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a48d50050>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55e1f8252f83 \\u003Cunknown>\\n#17 0x7ffaab89caa4 \\u003Cunknown>\\n#18 0x7ffaab929c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55e1f8253fea <unknown>
E       #1 0x55e1f7cd1d06 <unknown>
E       #2 0x55e1f7d0d32c <unknown>
E       #3 0x55e1f7d08f94 <unknown>
E       #4 0x55e1f7d583b3 <unknown>
E       #5 0x55e1f7d57a66 <unknown>
E       #6 0x55e1f7d49be3 <unknown>
E       #7 0x55e1f7d162d2 <unknown>
E       #8 0x55e1f7d16f91 <unknown>
E       #9 0x55e1f82179e8 <unknown>
E       #10 0x55e1f821b84f <unknown>
E       #11 0x55e1f81feec9 <unknown>
E       #12 0x55e1f821c3f5 <unknown>
E       #13 0x55e1f81e474f <unknown>
E       #14 0x55e1f8240cc8 <unknown>
E       #15 0x55e1f8240ea3 <unknown>
E       #16 0x55e1f8252f83 <unknown>
E       #17 0x7ffaab89caa4 <unknown>
E       #18 0x7ffaab929c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55e1f8253fea <unknown>
E           #1 0x55e1f7cd1d06 <unknown>
E           #2 0x55e1f7d0d32c <unknown>
E           #3 0x55e1f7d08f94 <unknown>
E           #4 0x55e1f7d583b3 <unknown>
E           #5 0x55e1f7d57a66 <unknown>
E           #6 0x55e1f7d49be3 <unknown>
E           #7 0x55e1f7d162d2 <unknown>
E           #8 0x55e1f7d16f91 <unknown>
E           #9 0x55e1f82179e8 <unknown>
E           #10 0x55e1f821b84f <unknown>
E           #11 0x55e1f81feec9 <unknown>
E           #12 0x55e1f821c3f5 <unknown>
E           #13 0x55e1f81e474f <unknown>
E           #14 0x55e1f8240cc8 <unknown>
E           #15 0x55e1f8240ea3 <unknown>
E           #16 0x55e1f8252f83 <unknown>
E           #17 0x7ffaab89caa4 <unknown>
E           #18 0x7ffaab929c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:35,163 - INFO - Starting test with Chrome browser
2025-10-23 03:50:35,163 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:35,230 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:35,265 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:35,297 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:36,385 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55e1f8253fea <unknown>
#1 0x55e1f7cd1d06 <unknown>
#2 0x55e1f7d0d32c <unknown>
#3 0x55e1f7d08f94 <unknown>
#4 0x55e1f7d583b3 <unknown>
#5 0x55e1f7d57a66 <unknown>
#6 0x55e1f7d49be3 <unknown>
#7 0x55e1f7d162d2 <unknown>
#8 0x55e1f7d16f91 <unknown>
#9 0x55e1f82179e8 <unknown>
#10 0x55e1f821b84f <unknown>
#11 0x55e1f81feec9 <unknown>
#12 0x55e1f821c3f5 <unknown>
#13 0x55e1f81e474f <unknown>
#14 0x55e1f8240cc8 <unknown>
#15 0x55e1f8240ea3 <unknown>
#16 0x55e1f8252f83 <unknown>
#17 0x7ffaab89caa4 <unknown>
#18 0x7ffaab929c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55e1f8253fea <unknown>
#1 0x55e1f7cd1d06 <unknown>
#2 0x55e1f7d0d32c <unknown>
#3 0x55e1f7d08f94 <unknown>
#4 0x55e1f7d583b3 <unknown>
#5 0x55e1f7d57a66 <unknown>
#6 0x55e1f7d49be3 <unknown>
#7 0x55e1f7d162d2 <unknown>
#8 0x55e1f7d16f91 <unknown>
#9 0x55e1f82179e8 <unknown>
#10 0x55e1f821b84f <unknown>
#11 0x55e1f81feec9 <unknown>
#12 0x55e1f821c3f5 <unknown>
#13 0x55e1f81e474f <unknown>
#14 0x55e1f8240cc8 <unknown>
#15 0x55e1f8240ea3 <unknown>
#16 0x55e1f8252f83 <unknown>
#17 0x7ffaab89caa4 <unknown>
#18 0x7ffaab929c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username2] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a838bb0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a839710>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a838bb0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4a839710>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4a83a0b0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4a838bb0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a4a839d30>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55cb4b457f83 \\u003Cunknown>\\n#17 0x7fcd2ba9caa4 \\u003Cunknown>\\n#18 0x7fcd2bb29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55cb4b458fea <unknown>
E       #1 0x55cb4aed6d06 <unknown>
E       #2 0x55cb4af1232c <unknown>
E       #3 0x55cb4af0df94 <unknown>
E       #4 0x55cb4af5d3b3 <unknown>
E       #5 0x55cb4af5ca66 <unknown>
E       #6 0x55cb4af4ebe3 <unknown>
E       #7 0x55cb4af1b2d2 <unknown>
E       #8 0x55cb4af1bf91 <unknown>
E       #9 0x55cb4b41c9e8 <unknown>
E       #10 0x55cb4b42084f <unknown>
E       #11 0x55cb4b403ec9 <unknown>
E       #12 0x55cb4b4213f5 <unknown>
E       #13 0x55cb4b3e974f <unknown>
E       #14 0x55cb4b445cc8 <unknown>
E       #15 0x55cb4b445ea3 <unknown>
E       #16 0x55cb4b457f83 <unknown>
E       #17 0x7fcd2ba9caa4 <unknown>
E       #18 0x7fcd2bb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55cb4b458fea <unknown>
E           #1 0x55cb4aed6d06 <unknown>
E           #2 0x55cb4af1232c <unknown>
E           #3 0x55cb4af0df94 <unknown>
E           #4 0x55cb4af5d3b3 <unknown>
E           #5 0x55cb4af5ca66 <unknown>
E           #6 0x55cb4af4ebe3 <unknown>
E           #7 0x55cb4af1b2d2 <unknown>
E           #8 0x55cb4af1bf91 <unknown>
E           #9 0x55cb4b41c9e8 <unknown>
E           #10 0x55cb4b42084f <unknown>
E           #11 0x55cb4b403ec9 <unknown>
E           #12 0x55cb4b4213f5 <unknown>
E           #13 0x55cb4b3e974f <unknown>
E           #14 0x55cb4b445cc8 <unknown>
E           #15 0x55cb4b445ea3 <unknown>
E           #16 0x55cb4b457f83 <unknown>
E           #17 0x7fcd2ba9caa4 <unknown>
E           #18 0x7fcd2bb29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:36,424 - INFO - Starting test with Chrome browser
2025-10-23 03:50:36,424 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:36,488 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:36,522 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:36,555 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:37,644 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55cb4b458fea <unknown>
#1 0x55cb4aed6d06 <unknown>
#2 0x55cb4af1232c <unknown>
#3 0x55cb4af0df94 <unknown>
#4 0x55cb4af5d3b3 <unknown>
#5 0x55cb4af5ca66 <unknown>
#6 0x55cb4af4ebe3 <unknown>
#7 0x55cb4af1b2d2 <unknown>
#8 0x55cb4af1bf91 <unknown>
#9 0x55cb4b41c9e8 <unknown>
#10 0x55cb4b42084f <unknown>
#11 0x55cb4b403ec9 <unknown>
#12 0x55cb4b4213f5 <unknown>
#13 0x55cb4b3e974f <unknown>
#14 0x55cb4b445cc8 <unknown>
#15 0x55cb4b445ea3 <unknown>
#16 0x55cb4b457f83 <unknown>
#17 0x7fcd2ba9caa4 <unknown>
#18 0x7fcd2bb29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55cb4b458fea <unknown>
#1 0x55cb4aed6d06 <unknown>
#2 0x55cb4af1232c <unknown>
#3 0x55cb4af0df94 <unknown>
#4 0x55cb4af5d3b3 <unknown>
#5 0x55cb4af5ca66 <unknown>
#6 0x55cb4af4ebe3 <unknown>
#7 0x55cb4af1b2d2 <unknown>
#8 0x55cb4af1bf91 <unknown>
#9 0x55cb4b41c9e8 <unknown>
#10 0x55cb4b42084f <unknown>
#11 0x55cb4b403ec9 <unknown>
#12 0x55cb4b4213f5 <unknown>
#13 0x55cb4b3e974f <unknown>
#14 0x55cb4b445cc8 <unknown>
#15 0x55cb4b445ea3 <unknown>
#16 0x55cb4b457f83 <unknown>
#17 0x7fcd2ba9caa4 <unknown>
#18 0x7fcd2bb29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username3] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48d749f0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48d74bb0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48d749f0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a48d74bb0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a48d74d70>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a48d749f0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a48d751d0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55ba84858f83 \\u003Cunknown>\\n#17 0x7f089fe9caa4 \\u003Cunknown>\\n#18 0x7f089ff29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55ba84859fea <unknown>
E       #1 0x55ba842d7d06 <unknown>
E       #2 0x55ba8431332c <unknown>
E       #3 0x55ba8430ef94 <unknown>
E       #4 0x55ba8435e3b3 <unknown>
E       #5 0x55ba8435da66 <unknown>
E       #6 0x55ba8434fbe3 <unknown>
E       #7 0x55ba8431c2d2 <unknown>
E       #8 0x55ba8431cf91 <unknown>
E       #9 0x55ba8481d9e8 <unknown>
E       #10 0x55ba8482184f <unknown>
E       #11 0x55ba84804ec9 <unknown>
E       #12 0x55ba848223f5 <unknown>
E       #13 0x55ba847ea74f <unknown>
E       #14 0x55ba84846cc8 <unknown>
E       #15 0x55ba84846ea3 <unknown>
E       #16 0x55ba84858f83 <unknown>
E       #17 0x7f089fe9caa4 <unknown>
E       #18 0x7f089ff29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55ba84859fea <unknown>
E           #1 0x55ba842d7d06 <unknown>
E           #2 0x55ba8431332c <unknown>
E           #3 0x55ba8430ef94 <unknown>
E           #4 0x55ba8435e3b3 <unknown>
E           #5 0x55ba8435da66 <unknown>
E           #6 0x55ba8434fbe3 <unknown>
E           #7 0x55ba8431c2d2 <unknown>
E           #8 0x55ba8431cf91 <unknown>
E           #9 0x55ba8481d9e8 <unknown>
E           #10 0x55ba8482184f <unknown>
E           #11 0x55ba84804ec9 <unknown>
E           #12 0x55ba848223f5 <unknown>
E           #13 0x55ba847ea74f <unknown>
E           #14 0x55ba84846cc8 <unknown>
E           #15 0x55ba84846ea3 <unknown>
E           #16 0x55ba84858f83 <unknown>
E           #17 0x7f089fe9caa4 <unknown>
E           #18 0x7f089ff29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:37,683 - INFO - Starting test with Chrome browser
2025-10-23 03:50:37,683 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:37,752 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:37,787 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:37,819 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:38,907 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ba84859fea <unknown>
#1 0x55ba842d7d06 <unknown>
#2 0x55ba8431332c <unknown>
#3 0x55ba8430ef94 <unknown>
#4 0x55ba8435e3b3 <unknown>
#5 0x55ba8435da66 <unknown>
#6 0x55ba8434fbe3 <unknown>
#7 0x55ba8431c2d2 <unknown>
#8 0x55ba8431cf91 <unknown>
#9 0x55ba8481d9e8 <unknown>
#10 0x55ba8482184f <unknown>
#11 0x55ba84804ec9 <unknown>
#12 0x55ba848223f5 <unknown>
#13 0x55ba847ea74f <unknown>
#14 0x55ba84846cc8 <unknown>
#15 0x55ba84846ea3 <unknown>
#16 0x55ba84858f83 <unknown>
#17 0x7f089fe9caa4 <unknown>
#18 0x7f089ff29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ba84859fea <unknown>
#1 0x55ba842d7d06 <unknown>
#2 0x55ba8431332c <unknown>
#3 0x55ba8430ef94 <unknown>
#4 0x55ba8435e3b3 <unknown>
#5 0x55ba8435da66 <unknown>
#6 0x55ba8434fbe3 <unknown>
#7 0x55ba8431c2d2 <unknown>
#8 0x55ba8431cf91 <unknown>
#9 0x55ba8481d9e8 <unknown>
#10 0x55ba8482184f <unknown>
#11 0x55ba84804ec9 <unknown>
#12 0x55ba848223f5 <unknown>
#13 0x55ba847ea74f <unknown>
#14 0x55ba84846cc8 <unknown>
#15 0x55ba84846ea3 <unknown>
#16 0x55ba84858f83 <unknown>
#17 0x7f089fe9caa4 <unknown>
#18 0x7f089ff29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username4] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4b335980>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4b336b60>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4b335980>
service = <selenium.webdriver.chrome.service.Service object at 0x7f9a4b336b60>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f9a4b3357e0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f9a4b335980>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f9a4b337790>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5560a4a8cf83 \\u003Cunknown>\\n#17 0x7fdb6449caa4 \\u003Cunknown>\\n#18 0x7fdb64529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5560a4a8dfea <unknown>
E       #1 0x5560a450bd06 <unknown>
E       #2 0x5560a454732c <unknown>
E       #3 0x5560a4542f94 <unknown>
E       #4 0x5560a45923b3 <unknown>
E       #5 0x5560a4591a66 <unknown>
E       #6 0x5560a4583be3 <unknown>
E       #7 0x5560a45502d2 <unknown>
E       #8 0x5560a4550f91 <unknown>
E       #9 0x5560a4a519e8 <unknown>
E       #10 0x5560a4a5584f <unknown>
E       #11 0x5560a4a38ec9 <unknown>
E       #12 0x5560a4a563f5 <unknown>
E       #13 0x5560a4a1e74f <unknown>
E       #14 0x5560a4a7acc8 <unknown>
E       #15 0x5560a4a7aea3 <unknown>
E       #16 0x5560a4a8cf83 <unknown>
E       #17 0x7fdb6449caa4 <unknown>
E       #18 0x7fdb64529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5560a4a8dfea <unknown>
E           #1 0x5560a450bd06 <unknown>
E           #2 0x5560a454732c <unknown>
E           #3 0x5560a4542f94 <unknown>
E           #4 0x5560a45923b3 <unknown>
E           #5 0x5560a4591a66 <unknown>
E           #6 0x5560a4583be3 <unknown>
E           #7 0x5560a45502d2 <unknown>
E           #8 0x5560a4550f91 <unknown>
E           #9 0x5560a4a519e8 <unknown>
E           #10 0x5560a4a5584f <unknown>
E           #11 0x5560a4a38ec9 <unknown>
E           #12 0x5560a4a563f5 <unknown>
E           #13 0x5560a4a1e74f <unknown>
E           #14 0x5560a4a7acc8 <unknown>
E           #15 0x5560a4a7aea3 <unknown>
E           #16 0x5560a4a8cf83 <unknown>
E           #17 0x7fdb6449caa4 <unknown>
E           #18 0x7fdb64529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-23 03:50:38,948 - INFO - Starting test with Chrome browser
2025-10-23 03:50:38,948 - INFO - ====== WebDriver manager ======
2025-10-23 03:50:39,013 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:39,050 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 03:50:39,083 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 03:50:40,172 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5560a4a8dfea <unknown>
#1 0x5560a450bd06 <unknown>
#2 0x5560a454732c <unknown>
#3 0x5560a4542f94 <unknown>
#4 0x5560a45923b3 <unknown>
#5 0x5560a4591a66 <unknown>
#6 0x5560a4583be3 <unknown>
#7 0x5560a45502d2 <unknown>
#8 0x5560a4550f91 <unknown>
#9 0x5560a4a519e8 <unknown>
#10 0x5560a4a5584f <unknown>
#11 0x5560a4a38ec9 <unknown>
#12 0x5560a4a563f5 <unknown>
#13 0x5560a4a1e74f <unknown>
#14 0x5560a4a7acc8 <unknown>
#15 0x5560a4a7aea3 <unknown>
#16 0x5560a4a8cf83 <unknown>
#17 0x7fdb6449caa4 <unknown>
#18 0x7fdb64529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5560a4a8dfea <unknown>
#1 0x5560a450bd06 <unknown>
#2 0x5560a454732c <unknown>
#3 0x5560a4542f94 <unknown>
#4 0x5560a45923b3 <unknown>
#5 0x5560a4591a66 <unknown>
#6 0x5560a4583be3 <unknown>
#7 0x5560a45502d2 <unknown>
#8 0x5560a4550f91 <unknown>
#9 0x5560a4a519e8 <unknown>
#10 0x5560a4a5584f <unknown>
#11 0x5560a4a38ec9 <unknown>
#12 0x5560a4a563f5 <unknown>
#13 0x5560a4a1e74f <unknown>
#14 0x5560a4a7acc8 <unknown>
#15 0x5560a4a7aea3 <unknown>
#16 0x5560a4a8cf83 <unknown>
#17 0x7fdb6449caa4 <unknown>
#18 0x7fdb64529c6c <unknown>
- Generated html report: file:///home/runner/work/Mocha_accounting/Mocha_accounting/C%3A%5CUsers%5CTaurus13%5CPycharmProjects%5CPythonProject%5Creports/20251023_035020/report.html -
============================= 15 errors in 19.45s ==============================
=== LOGIN TESTS COMPLETED ===
Exit Code: 1
=== LOGIN TESTS STARTED: 2025-10-23 14:47:27 ===
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.3.5, pluggy-1.6.0 -- /opt/hostedtoolcache/Python/3.13.7/x64/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.11.0-1018-azure-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.6.0'}, 'Plugins': {'html': '4.1.1', 'rerunfailures': '16.1', 'Faker': '37.11.0', 'xdist': '3.8.0', 'metadata': '3.1.1'}, 'CI': 'true', 'JAVA_HOME': '/usr/lib/jvm/temurin-17-jdk-amd64'}
rootdir: /home/runner/work/Mocha_accounting/Mocha_accounting
plugins: html-4.1.1, rerunfailures-16.1, Faker-37.11.0, xdist-3.8.0, metadata-3.1.1
collecting ... collected 15 items

tests/test_signup_login/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] PASSED [  6%]
tests/test_signup_login/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] PASSED [ 13%]
tests/test_signup_login/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] PASSED [ 20%]
tests/test_signup_login/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] PASSED [ 26%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username0] PASSED [ 33%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username1] PASSED [ 40%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username2] PASSED [ 46%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username3] PASSED [ 53%]
tests/test_signup_login/test_login.py::test_blank_username_validation FAILED [ 60%]
tests/test_signup_login/test_login.py::test_blank_password_validation FAILED [ 66%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username0] FAILED [ 73%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username1] FAILED [ 80%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username2] FAILED [ 86%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username3] FAILED [ 93%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username4] FAILED [100%]

=================================== FAILURES ===================================
________________________ test_blank_username_validation ________________________

sign_login_setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="ca73a9f1781626781f422166f5ed00f4")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def test_blank_username_validation(sign_login_setup, login_test_data):
        driver = sign_login_setup
        login_page = LoginPage(driver)
        #login_page.enter_password(valid_password[0])
        login_page.click_username()
        login_page.disabled_click_login_button()
>       login_page.username_blank_validation(login_test_data)

tests/test_signup_login/test_login.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pages.login_page.LoginPage object at 0x7fee2ddc3550>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def username_blank_validation(self, login_test_data):
>       self.actions.wait_for_element(self.username_validation)

pages/login_page.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <actions.actions.Actions object at 0x7fee2ddc3d50>
locator = ('xpath', "//div[normalize-space()='Email is required.']")
timeout = 100

    def wait_for_element(self, locator, timeout=100):
>       WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))

actions/actions.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="ca73a9f1781626781f422166f5ed00f4")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fee2ca86f20>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55cb2347cfea <unknown>
E       #1 0x55cb22efad06 <unknown>
E       #2 0x55cb22f4ce6d <unknown>
E       #3 0x55cb22f4d101 <unknown>
E       #4 0x55cb22f9b6b4 <unknown>
E       #5 0x55cb22f72e3d <unknown>
E       #6 0x55cb22f98b3b <unknown>
E       #7 0x55cb22f72be3 <unknown>
E       #8 0x55cb22f3f2d2 <unknown>
E       #9 0x55cb22f3ff91 <unknown>
E       #10 0x55cb234409e8 <unknown>
E       #11 0x55cb2344484f <unknown>
E       #12 0x55cb23427ec9 <unknown>
E       #13 0x55cb234453f5 <unknown>
E       #14 0x55cb2340d74f <unknown>
E       #15 0x55cb23469cc8 <unknown>
E       #16 0x55cb23469ea3 <unknown>
E       #17 0x55cb2347bf83 <unknown>
E       #18 0x7fcb1ca9caa4 <unknown>
E       #19 0x7fcb1cb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:48:10,010 - INFO - Starting test with Chrome browser
2025-10-23 14:48:10,010 - INFO - ====== WebDriver manager ======
2025-10-23 14:48:10,075 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:48:10,126 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:48:10,172 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:48:11,600 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:49:56,795 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
________________________ test_blank_password_validation ________________________

sign_login_setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="2293c73c9b9b33b413ce3b342f466baa")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def test_blank_password_validation(sign_login_setup,login_test_data):
        driver = sign_login_setup
        login_page = LoginPage(driver)
        login_page.enter_username(valid_username[0])
        login_page.click_password()
        login_page.disabled_click_login_button()
>       login_page.password_blank_validation(login_test_data)

tests/test_signup_login/test_login.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pages.login_page.LoginPage object at 0x7fee2ce38450>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def password_blank_validation(self, login_test_data):
>       self.actions.wait_for_element(self.password_validation)

pages/login_page.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <actions.actions.Actions object at 0x7fee2ce38c50>
locator = ('xpath', "//div[normalize-space()='Password is required']")
timeout = 100

    def wait_for_element(self, locator, timeout=100):
>       WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))

actions/actions.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="2293c73c9b9b33b413ce3b342f466baa")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fee2ca871a0>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x555f3c8b0fea <unknown>
E       #1 0x555f3c32ed06 <unknown>
E       #2 0x555f3c380e6d <unknown>
E       #3 0x555f3c381101 <unknown>
E       #4 0x555f3c3cf6b4 <unknown>
E       #5 0x555f3c3a6e3d <unknown>
E       #6 0x555f3c3ccb3b <unknown>
E       #7 0x555f3c3a6be3 <unknown>
E       #8 0x555f3c3732d2 <unknown>
E       #9 0x555f3c373f91 <unknown>
E       #10 0x555f3c8749e8 <unknown>
E       #11 0x555f3c87884f <unknown>
E       #12 0x555f3c85bec9 <unknown>
E       #13 0x555f3c8793f5 <unknown>
E       #14 0x555f3c84174f <unknown>
E       #15 0x555f3c89dcc8 <unknown>
E       #16 0x555f3c89dea3 <unknown>
E       #17 0x555f3c8aff83 <unknown>
E       #18 0x7f1449a9caa4 <unknown>
E       #19 0x7f1449b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:49:56,886 - INFO - Starting test with Chrome browser
2025-10-23 14:49:56,887 - INFO - ====== WebDriver manager ======
2025-10-23 14:49:56,950 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:49:56,998 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:49:57,043 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:49:58,374 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:51:45,179 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
___________________ test_invalid_email_validation[username0] ___________________

sign_login_setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="f2a8ade9ff089fef0f4695f0cfa4b37f")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = ('yash10%gmail.com',)

    @pytest.mark.parametrize("username", zip(invalid_format_username))
    def test_invalid_email_validation(sign_login_setup, login_test_data, username):
        driver = sign_login_setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.disabled_click_login_button()
>       login_page.invalid_email_validation(login_test_data)

tests/test_signup_login/test_login.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pages.login_page.LoginPage object at 0x7fee2cec1a90>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def invalid_email_validation(self, login_test_data):
>       self.actions.wait_for_element(self.invalid_email_verification_msg)

pages/login_page.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <actions.actions.Actions object at 0x7fee2cec0c80>
locator = ('xpath', "//div[@class='invalid-feedback']"), timeout = 100

    def wait_for_element(self, locator, timeout=100):
>       WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))

actions/actions.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="f2a8ade9ff089fef0f4695f0cfa4b37f")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fee2bfc0180>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x561f7ad58fea <unknown>
E       #1 0x561f7a7d6d06 <unknown>
E       #2 0x561f7a828e6d <unknown>
E       #3 0x561f7a829101 <unknown>
E       #4 0x561f7a8776b4 <unknown>
E       #5 0x561f7a84ee3d <unknown>
E       #6 0x561f7a874b3b <unknown>
E       #7 0x561f7a84ebe3 <unknown>
E       #8 0x561f7a81b2d2 <unknown>
E       #9 0x561f7a81bf91 <unknown>
E       #10 0x561f7ad1c9e8 <unknown>
E       #11 0x561f7ad2084f <unknown>
E       #12 0x561f7ad03ec9 <unknown>
E       #13 0x561f7ad213f5 <unknown>
E       #14 0x561f7ace974f <unknown>
E       #15 0x561f7ad45cc8 <unknown>
E       #16 0x561f7ad45ea3 <unknown>
E       #17 0x561f7ad57f83 <unknown>
E       #18 0x7f7c3129caa4 <unknown>
E       #19 0x7f7c31329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:51:45,271 - INFO - Starting test with Chrome browser
2025-10-23 14:51:45,271 - INFO - ====== WebDriver manager ======
2025-10-23 14:51:45,336 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:51:45,383 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:51:45,428 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:51:46,938 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:53:32,042 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
___________________ test_invalid_email_validation[username1] ___________________

sign_login_setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="715e5d8d802d44161b0b3868cecec31a")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = ('payeryash1gmail.com',)

    @pytest.mark.parametrize("username", zip(invalid_format_username))
    def test_invalid_email_validation(sign_login_setup, login_test_data, username):
        driver = sign_login_setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.disabled_click_login_button()
>       login_page.invalid_email_validation(login_test_data)

tests/test_signup_login/test_login.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pages.login_page.LoginPage object at 0x7fee2cec3020>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def invalid_email_validation(self, login_test_data):
>       self.actions.wait_for_element(self.invalid_email_verification_msg)

pages/login_page.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <actions.actions.Actions object at 0x7fee2cec17c0>
locator = ('xpath', "//div[@class='invalid-feedback']"), timeout = 100

    def wait_for_element(self, locator, timeout=100):
>       WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))

actions/actions.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="715e5d8d802d44161b0b3868cecec31a")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fee2bfc05e0>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55beb85b5fea <unknown>
E       #1 0x55beb8033d06 <unknown>
E       #2 0x55beb8085e6d <unknown>
E       #3 0x55beb8086101 <unknown>
E       #4 0x55beb80d46b4 <unknown>
E       #5 0x55beb80abe3d <unknown>
E       #6 0x55beb80d1b3b <unknown>
E       #7 0x55beb80abbe3 <unknown>
E       #8 0x55beb80782d2 <unknown>
E       #9 0x55beb8078f91 <unknown>
E       #10 0x55beb85799e8 <unknown>
E       #11 0x55beb857d84f <unknown>
E       #12 0x55beb8560ec9 <unknown>
E       #13 0x55beb857e3f5 <unknown>
E       #14 0x55beb854674f <unknown>
E       #15 0x55beb85a2cc8 <unknown>
E       #16 0x55beb85a2ea3 <unknown>
E       #17 0x55beb85b4f83 <unknown>
E       #18 0x7f0cc009caa4 <unknown>
E       #19 0x7f0cc0129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:53:32,137 - INFO - Starting test with Chrome browser
2025-10-23 14:53:32,137 - INFO - ====== WebDriver manager ======
2025-10-23 14:53:32,201 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:53:32,250 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:53:32,294 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:53:33,882 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:55:19,041 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
___________________ test_invalid_email_validation[username2] ___________________

sign_login_setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="c842fe6b2d5631c9bef7b6ffc863acef")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = (' payeryash10@gmai|com',)

    @pytest.mark.parametrize("username", zip(invalid_format_username))
    def test_invalid_email_validation(sign_login_setup, login_test_data, username):
        driver = sign_login_setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.disabled_click_login_button()
>       login_page.invalid_email_validation(login_test_data)

tests/test_signup_login/test_login.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pages.login_page.LoginPage object at 0x7fee2cf0b3f0>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def invalid_email_validation(self, login_test_data):
>       self.actions.wait_for_element(self.invalid_email_verification_msg)

pages/login_page.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <actions.actions.Actions object at 0x7fee2cf0bbd0>
locator = ('xpath', "//div[@class='invalid-feedback']"), timeout = 100

    def wait_for_element(self, locator, timeout=100):
>       WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))

actions/actions.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="c842fe6b2d5631c9bef7b6ffc863acef")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fee2bfc0b80>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55b75f7ddfea <unknown>
E       #1 0x55b75f25bd06 <unknown>
E       #2 0x55b75f2ade6d <unknown>
E       #3 0x55b75f2ae101 <unknown>
E       #4 0x55b75f2fc6b4 <unknown>
E       #5 0x55b75f2d3e3d <unknown>
E       #6 0x55b75f2f9b3b <unknown>
E       #7 0x55b75f2d3be3 <unknown>
E       #8 0x55b75f2a02d2 <unknown>
E       #9 0x55b75f2a0f91 <unknown>
E       #10 0x55b75f7a19e8 <unknown>
E       #11 0x55b75f7a584f <unknown>
E       #12 0x55b75f788ec9 <unknown>
E       #13 0x55b75f7a63f5 <unknown>
E       #14 0x55b75f76e74f <unknown>
E       #15 0x55b75f7cacc8 <unknown>
E       #16 0x55b75f7caea3 <unknown>
E       #17 0x55b75f7dcf83 <unknown>
E       #18 0x7fb77929caa4 <unknown>
E       #19 0x7fb779329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:55:19,109 - INFO - Starting test with Chrome browser
2025-10-23 14:55:19,109 - INFO - ====== WebDriver manager ======
2025-10-23 14:55:19,174 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:55:19,221 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:55:19,268 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:55:19,952 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:57:05,431 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
___________________ test_invalid_email_validation[username3] ___________________

sign_login_setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="4dbe5e6b28c82c40d5a4c337bc4df631")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = ('payergmail.com',)

    @pytest.mark.parametrize("username", zip(invalid_format_username))
    def test_invalid_email_validation(sign_login_setup, login_test_data, username):
        driver = sign_login_setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.disabled_click_login_button()
>       login_page.invalid_email_validation(login_test_data)

tests/test_signup_login/test_login.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pages.login_page.LoginPage object at 0x7fee2bf64bb0>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def invalid_email_validation(self, login_test_data):
>       self.actions.wait_for_element(self.invalid_email_verification_msg)

pages/login_page.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <actions.actions.Actions object at 0x7fee2bf65390>
locator = ('xpath', "//div[@class='invalid-feedback']"), timeout = 100

    def wait_for_element(self, locator, timeout=100):
>       WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))

actions/actions.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="4dbe5e6b28c82c40d5a4c337bc4df631")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fee2bfc11c0>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55a537615fea <unknown>
E       #1 0x55a537093d06 <unknown>
E       #2 0x55a5370e5e6d <unknown>
E       #3 0x55a5370e6101 <unknown>
E       #4 0x55a5371346b4 <unknown>
E       #5 0x55a53710be3d <unknown>
E       #6 0x55a537131b3b <unknown>
E       #7 0x55a53710bbe3 <unknown>
E       #8 0x55a5370d82d2 <unknown>
E       #9 0x55a5370d8f91 <unknown>
E       #10 0x55a5375d99e8 <unknown>
E       #11 0x55a5375dd84f <unknown>
E       #12 0x55a5375c0ec9 <unknown>
E       #13 0x55a5375de3f5 <unknown>
E       #14 0x55a5375a674f <unknown>
E       #15 0x55a537602cc8 <unknown>
E       #16 0x55a537602ea3 <unknown>
E       #17 0x55a537614f83 <unknown>
E       #18 0x7f5aaf89caa4 <unknown>
E       #19 0x7f5aaf929c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:57:05,523 - INFO - Starting test with Chrome browser
2025-10-23 14:57:05,523 - INFO - ====== WebDriver manager ======
2025-10-23 14:57:05,588 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:57:05,635 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:57:05,681 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:57:07,283 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:58:52,416 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
___________________ test_invalid_email_validation[username4] ___________________

sign_login_setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="4ae027e364ea35068665310de89db268")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = ('payeryash10@gmail/com',)

    @pytest.mark.parametrize("username", zip(invalid_format_username))
    def test_invalid_email_validation(sign_login_setup, login_test_data, username):
        driver = sign_login_setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.disabled_click_login_button()
>       login_page.invalid_email_validation(login_test_data)

tests/test_signup_login/test_login.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pages.login_page.LoginPage object at 0x7fee2bf9eb60>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}

    def invalid_email_validation(self, login_test_data):
>       self.actions.wait_for_element(self.invalid_email_verification_msg)

pages/login_page.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <actions.actions.Actions object at 0x7fee2bf9d980>
locator = ('xpath', "//div[@class='invalid-feedback']"), timeout = 100

    def wait_for_element(self, locator, timeout=100):
>       WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))

actions/actions.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="4ae027e364ea35068665310de89db268")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7fee2bfc1580>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x5559e5b12fea <unknown>
E       #1 0x5559e5590d06 <unknown>
E       #2 0x5559e55e2e6d <unknown>
E       #3 0x5559e55e3101 <unknown>
E       #4 0x5559e56316b4 <unknown>
E       #5 0x5559e5608e3d <unknown>
E       #6 0x5559e562eb3b <unknown>
E       #7 0x5559e5608be3 <unknown>
E       #8 0x5559e55d52d2 <unknown>
E       #9 0x5559e55d5f91 <unknown>
E       #10 0x5559e5ad69e8 <unknown>
E       #11 0x5559e5ada84f <unknown>
E       #12 0x5559e5abdec9 <unknown>
E       #13 0x5559e5adb3f5 <unknown>
E       #14 0x5559e5aa374f <unknown>
E       #15 0x5559e5affcc8 <unknown>
E       #16 0x5559e5affea3 <unknown>
E       #17 0x5559e5b11f83 <unknown>
E       #18 0x7f3cb869caa4 <unknown>
E       #19 0x7f3cb8729c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:58:52,486 - INFO - Starting test with Chrome browser
2025-10-23 14:58:52,486 - INFO - ====== WebDriver manager ======
2025-10-23 14:58:52,550 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:58:52,598 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:58:52,645 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:58:54,037 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 15:00:39,200 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
==================================== PASSES ====================================
________ test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] ________
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:47:29,530 - INFO - Starting test with Chrome browser
2025-10-23 14:47:29,530 - INFO - ====== WebDriver manager ======
2025-10-23 14:47:29,670 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:29,789 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:29,835 - INFO - There is no [linux64] chromedriver "141.0.7390.122" for browser google-chrome "141.0.7390" in cache
2025-10-23 14:47:29,836 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:29,960 - INFO - WebDriver version 141.0.7390.122 selected
2025-10-23 14:47:29,964 - INFO - Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
2025-10-23 14:47:29,964 - INFO - About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
2025-10-23 14:47:30,023 - INFO - Driver downloading response is 200
2025-10-23 14:47:30,093 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:30,249 - INFO - Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122]
2025-10-23 14:47:32,382 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 There is no [linux64] chromedriver "141.0.7390.122" for browser google-chrome "141.0.7390" in cache
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 WebDriver version 141.0.7390.122 selected
INFO     WDM:logger.py:11 Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.122/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 Driver downloading response is 200
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122]
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
----------------------------- Captured stderr call -----------------------------
2025-10-23 14:47:32,383 - INFO - Starting the test case for valid credentials
2025-10-23 14:47:32,550 - INFO - User enters the email-id
2025-10-23 14:47:34,167 - INFO - User enters the password
2025-10-23 14:47:34,253 - INFO - User clicks on login button
2025-10-23 14:47:36,837 - INFO - The test case passed
------------------------------ Captured log call -------------------------------
INFO     tests.test_signup_login.test_login:test_login.py:25 Starting the test case for valid credentials
INFO     tests.test_signup_login.test_login:test_login.py:27 User enters the email-id
INFO     tests.test_signup_login.test_login:test_login.py:29 User enters the password
INFO     tests.test_signup_login.test_login:test_login.py:31 User clicks on login button
INFO     tests.test_signup_login.test_login:test_login.py:33 The test case passed
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:47:36,838 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
_____________ test_valid_login[samatakamble9@gmail.com-Samata@16] ______________
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:47:36,917 - INFO - Starting test with Chrome browser
2025-10-23 14:47:36,917 - INFO - ====== WebDriver manager ======
2025-10-23 14:47:36,981 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:37,027 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:37,089 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:47:38,601 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
----------------------------- Captured stderr call -----------------------------
2025-10-23 14:47:38,602 - INFO - Starting the test case for valid credentials
2025-10-23 14:47:38,742 - INFO - User enters the email-id
2025-10-23 14:47:40,193 - INFO - User enters the password
2025-10-23 14:47:40,295 - INFO - User clicks on login button
2025-10-23 14:47:42,555 - INFO - The test case passed
------------------------------ Captured log call -------------------------------
INFO     tests.test_signup_login.test_login:test_login.py:25 Starting the test case for valid credentials
INFO     tests.test_signup_login.test_login:test_login.py:27 User enters the email-id
INFO     tests.test_signup_login.test_login:test_login.py:29 User enters the password
INFO     tests.test_signup_login.test_login:test_login.py:31 User clicks on login button
INFO     tests.test_signup_login.test_login:test_login.py:33 The test case passed
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:47:42,556 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
___________ test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ____________
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:47:42,621 - INFO - Starting test with Chrome browser
2025-10-23 14:47:42,621 - INFO - ====== WebDriver manager ======
2025-10-23 14:47:42,685 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:42,732 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:42,778 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:47:43,420 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
----------------------------- Captured stderr call -----------------------------
2025-10-23 14:47:43,421 - INFO - Starting the test case for valid credentials
2025-10-23 14:47:43,841 - INFO - User enters the email-id
2025-10-23 14:47:45,331 - INFO - User enters the password
2025-10-23 14:47:45,418 - INFO - User clicks on login button
2025-10-23 14:47:47,626 - INFO - The test case passed
------------------------------ Captured log call -------------------------------
INFO     tests.test_signup_login.test_login:test_login.py:25 Starting the test case for valid credentials
INFO     tests.test_signup_login.test_login:test_login.py:27 User enters the email-id
INFO     tests.test_signup_login.test_login:test_login.py:29 User enters the password
INFO     tests.test_signup_login.test_login:test_login.py:31 User clicks on login button
INFO     tests.test_signup_login.test_login:test_login.py:33 The test case passed
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:47:47,627 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
______ test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] _______
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:47:47,694 - INFO - Starting test with Chrome browser
2025-10-23 14:47:47,695 - INFO - ====== WebDriver manager ======
2025-10-23 14:47:47,758 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:47,806 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:47,851 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:47:49,247 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
----------------------------- Captured stderr call -----------------------------
2025-10-23 14:47:49,248 - INFO - Starting the test case for valid credentials
2025-10-23 14:47:49,402 - INFO - User enters the email-id
2025-10-23 14:47:50,939 - INFO - User enters the password
2025-10-23 14:47:51,027 - INFO - User clicks on login button
2025-10-23 14:47:52,989 - INFO - The test case passed
------------------------------ Captured log call -------------------------------
INFO     tests.test_signup_login.test_login:test_login.py:25 Starting the test case for valid credentials
INFO     tests.test_signup_login.test_login:test_login.py:27 User enters the email-id
INFO     tests.test_signup_login.test_login:test_login.py:29 User enters the password
INFO     tests.test_signup_login.test_login:test_login.py:31 User clicks on login button
INFO     tests.test_signup_login.test_login:test_login.py:33 The test case passed
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:47:52,990 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
_____________________ test_invalid_email_login[username0] ______________________
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:47:53,058 - INFO - Starting test with Chrome browser
2025-10-23 14:47:53,058 - INFO - ====== WebDriver manager ======
2025-10-23 14:47:53,124 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:53,171 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:53,218 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:47:54,664 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:47:57,445 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
_____________________ test_invalid_email_login[username1] ______________________
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:47:57,508 - INFO - Starting test with Chrome browser
2025-10-23 14:47:57,508 - INFO - ====== WebDriver manager ======
2025-10-23 14:47:57,573 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:57,620 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:47:57,674 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:47:58,323 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:48:01,383 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
_____________________ test_invalid_email_login[username2] ______________________
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:48:01,446 - INFO - Starting test with Chrome browser
2025-10-23 14:48:01,446 - INFO - ====== WebDriver manager ======
2025-10-23 14:48:01,511 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:48:01,560 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:48:01,606 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:48:02,230 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:48:05,328 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
_____________________ test_invalid_email_login[username3] ______________________
---------------------------- Captured stderr setup -----------------------------
2025-10-23 14:48:05,391 - INFO - Starting test with Chrome browser
2025-10-23 14:48:05,391 - INFO - ====== WebDriver manager ======
2025-10-23 14:48:05,457 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:48:05,504 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-23 14:48:05,737 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
2025-10-23 14:48:07,171 - INFO - Navigated to: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:78 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.122/chromedriver-linux64/chromedriver] found in cache
INFO     tests.test_signup_login.conftest:conftest.py:134 Navigated to: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-10-23 14:48:09,944 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     tests.test_signup_login.conftest:conftest.py:144 Closing browser
- Generated html report: file:///home/runner/work/Mocha_accounting/Mocha_accounting/C%3A%5CUsers%5CTaurus13%5CPycharmProjects%5CPythonProject%5Creports/20251023_144729/report.html -
=================== 7 failed, 8 passed in 789.85s (0:13:09) ====================
=== LOGIN TESTS COMPLETED ===
Exit Code: 1
