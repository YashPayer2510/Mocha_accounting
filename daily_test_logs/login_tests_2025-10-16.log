=== LOGIN TESTS STARTED: 2025-10-16 15:13:32 ===
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.3.5, pluggy-1.6.0 -- /opt/hostedtoolcache/Python/3.13.7/x64/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.11.0-1018-azure-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.6.0'}, 'Plugins': {'html': '4.1.1', 'rerunfailures': '16.1', 'Faker': '37.11.0', 'xdist': '3.8.0', 'metadata': '3.1.1'}, 'CI': 'true', 'JAVA_HOME': '/usr/lib/jvm/temurin-17-jdk-amd64'}
rootdir: /home/runner/work/Mocha_accounting/Mocha_accounting
plugins: html-4.1.1, rerunfailures-16.1, Faker-37.11.0, xdist-3.8.0, metadata-3.1.1
collecting ... collected 15 items

tests/test_signup_login/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] ERROR [  6%]
tests/test_signup_login/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] ERROR [ 13%]
tests/test_signup_login/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ERROR [ 20%]
tests/test_signup_login/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] ERROR [ 26%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username0] ERROR [ 33%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username1] ERROR [ 40%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username2] ERROR [ 46%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username3] ERROR [ 53%]
tests/test_signup_login/test_login.py::test_blank_username_validation ERROR [ 60%]
tests/test_signup_login/test_login.py::test_blank_password_validation ERROR [ 66%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username0] ERROR [ 73%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username1] ERROR [ 80%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username2] ERROR [ 86%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username3] ERROR [ 93%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username4] ERROR [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9870d70>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b9870ec0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9870d70>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b9870ec0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b9871400>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9870d70>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b9871160>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5568798bb613 \\u003Cunknown>\\n#17 0x7f43b529caa4 \\u003Cunknown>\\n#18 0x7f43b5329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5568798bc67a <unknown>
E       #1 0x55687933b566 <unknown>
E       #2 0x556879376b4c <unknown>
E       #3 0x5568793727c4 <unknown>
E       #4 0x5568793c1bd3 <unknown>
E       #5 0x5568793c1286 <unknown>
E       #6 0x5568793b3403 <unknown>
E       #7 0x55687937fb02 <unknown>
E       #8 0x5568793807c1 <unknown>
E       #9 0x556879880448 <unknown>
E       #10 0x5568798842af <unknown>
E       #11 0x5568798678d9 <unknown>
E       #12 0x556879884e55 <unknown>
E       #13 0x55687984d13f <unknown>
E       #14 0x5568798a94b8 <unknown>
E       #15 0x5568798a9693 <unknown>
E       #16 0x5568798bb613 <unknown>
E       #17 0x7f43b529caa4 <unknown>
E       #18 0x7f43b5329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5568798bc67a <unknown>
E           #1 0x55687933b566 <unknown>
E           #2 0x556879376b4c <unknown>
E           #3 0x5568793727c4 <unknown>
E           #4 0x5568793c1bd3 <unknown>
E           #5 0x5568793c1286 <unknown>
E           #6 0x5568793b3403 <unknown>
E           #7 0x55687937fb02 <unknown>
E           #8 0x5568793807c1 <unknown>
E           #9 0x556879880448 <unknown>
E           #10 0x5568798842af <unknown>
E           #11 0x5568798678d9 <unknown>
E           #12 0x556879884e55 <unknown>
E           #13 0x55687984d13f <unknown>
E           #14 0x5568798a94b8 <unknown>
E           #15 0x5568798a9693 <unknown>
E           #16 0x5568798bb613 <unknown>
E           #17 0x7f43b529caa4 <unknown>
E           #18 0x7f43b5329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:33,852 - INFO - Starting test with Chrome browser
2025-10-16 15:13:33,852 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:33,919 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:33,956 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:33,990 - INFO - There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
2025-10-16 15:13:33,990 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:34,090 - INFO - WebDriver version 141.0.7390.78 selected
2025-10-16 15:13:34,095 - INFO - Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-16 15:13:34,095 - INFO - About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-16 15:13:34,141 - INFO - Driver downloading response is 200
2025-10-16 15:13:34,350 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:34,493 - INFO - Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
2025-10-16 15:13:35,606 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5568798bc67a <unknown>
#1 0x55687933b566 <unknown>
#2 0x556879376b4c <unknown>
#3 0x5568793727c4 <unknown>
#4 0x5568793c1bd3 <unknown>
#5 0x5568793c1286 <unknown>
#6 0x5568793b3403 <unknown>
#7 0x55687937fb02 <unknown>
#8 0x5568793807c1 <unknown>
#9 0x556879880448 <unknown>
#10 0x5568798842af <unknown>
#11 0x5568798678d9 <unknown>
#12 0x556879884e55 <unknown>
#13 0x55687984d13f <unknown>
#14 0x5568798a94b8 <unknown>
#15 0x5568798a9693 <unknown>
#16 0x5568798bb613 <unknown>
#17 0x7f43b529caa4 <unknown>
#18 0x7f43b5329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 WebDriver version 141.0.7390.78 selected
INFO     WDM:logger.py:11 Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 Driver downloading response is 200
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5568798bc67a <unknown>
#1 0x55687933b566 <unknown>
#2 0x556879376b4c <unknown>
#3 0x5568793727c4 <unknown>
#4 0x5568793c1bd3 <unknown>
#5 0x5568793c1286 <unknown>
#6 0x5568793b3403 <unknown>
#7 0x55687937fb02 <unknown>
#8 0x5568793807c1 <unknown>
#9 0x556879880448 <unknown>
#10 0x5568798842af <unknown>
#11 0x5568798678d9 <unknown>
#12 0x556879884e55 <unknown>
#13 0x55687984d13f <unknown>
#14 0x5568798a94b8 <unknown>
#15 0x5568798a9693 <unknown>
#16 0x5568798bb613 <unknown>
#17 0x7f43b529caa4 <unknown>
#18 0x7f43b5329c6c <unknown>
____ ERROR at setup of test_valid_login[samatakamble9@gmail.com-Samata@16] _____

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b987e710>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b987ec10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b987e710>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b987ec10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b987efd0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b987e710>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b987ee90>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55feac265613 \\u003Cunknown>\\n#17 0x7f890b69caa4 \\u003Cunknown>\\n#18 0x7f890b729c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55feac26667a <unknown>
E       #1 0x55feabce5566 <unknown>
E       #2 0x55feabd20b4c <unknown>
E       #3 0x55feabd1c7c4 <unknown>
E       #4 0x55feabd6bbd3 <unknown>
E       #5 0x55feabd6b286 <unknown>
E       #6 0x55feabd5d403 <unknown>
E       #7 0x55feabd29b02 <unknown>
E       #8 0x55feabd2a7c1 <unknown>
E       #9 0x55feac22a448 <unknown>
E       #10 0x55feac22e2af <unknown>
E       #11 0x55feac2118d9 <unknown>
E       #12 0x55feac22ee55 <unknown>
E       #13 0x55feac1f713f <unknown>
E       #14 0x55feac2534b8 <unknown>
E       #15 0x55feac253693 <unknown>
E       #16 0x55feac265613 <unknown>
E       #17 0x7f890b69caa4 <unknown>
E       #18 0x7f890b729c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55feac26667a <unknown>
E           #1 0x55feabce5566 <unknown>
E           #2 0x55feabd20b4c <unknown>
E           #3 0x55feabd1c7c4 <unknown>
E           #4 0x55feabd6bbd3 <unknown>
E           #5 0x55feabd6b286 <unknown>
E           #6 0x55feabd5d403 <unknown>
E           #7 0x55feabd29b02 <unknown>
E           #8 0x55feabd2a7c1 <unknown>
E           #9 0x55feac22a448 <unknown>
E           #10 0x55feac22e2af <unknown>
E           #11 0x55feac2118d9 <unknown>
E           #12 0x55feac22ee55 <unknown>
E           #13 0x55feac1f713f <unknown>
E           #14 0x55feac2534b8 <unknown>
E           #15 0x55feac253693 <unknown>
E           #16 0x55feac265613 <unknown>
E           #17 0x7f890b69caa4 <unknown>
E           #18 0x7f890b729c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:35,673 - INFO - Starting test with Chrome browser
2025-10-16 15:13:35,674 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:35,737 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:35,773 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:35,875 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:36,964 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55feac26667a <unknown>
#1 0x55feabce5566 <unknown>
#2 0x55feabd20b4c <unknown>
#3 0x55feabd1c7c4 <unknown>
#4 0x55feabd6bbd3 <unknown>
#5 0x55feabd6b286 <unknown>
#6 0x55feabd5d403 <unknown>
#7 0x55feabd29b02 <unknown>
#8 0x55feabd2a7c1 <unknown>
#9 0x55feac22a448 <unknown>
#10 0x55feac22e2af <unknown>
#11 0x55feac2118d9 <unknown>
#12 0x55feac22ee55 <unknown>
#13 0x55feac1f713f <unknown>
#14 0x55feac2534b8 <unknown>
#15 0x55feac253693 <unknown>
#16 0x55feac265613 <unknown>
#17 0x7f890b69caa4 <unknown>
#18 0x7f890b729c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55feac26667a <unknown>
#1 0x55feabce5566 <unknown>
#2 0x55feabd20b4c <unknown>
#3 0x55feabd1c7c4 <unknown>
#4 0x55feabd6bbd3 <unknown>
#5 0x55feabd6b286 <unknown>
#6 0x55feabd5d403 <unknown>
#7 0x55feabd29b02 <unknown>
#8 0x55feabd2a7c1 <unknown>
#9 0x55feac22a448 <unknown>
#10 0x55feac22e2af <unknown>
#11 0x55feac2118d9 <unknown>
#12 0x55feac22ee55 <unknown>
#13 0x55feac1f713f <unknown>
#14 0x55feac2534b8 <unknown>
#15 0x55feac253693 <unknown>
#16 0x55feac265613 <unknown>
#17 0x7f890b69caa4 <unknown>
#18 0x7f890b729c6c <unknown>
__ ERROR at setup of test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ___

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b987ead0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b987ce10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b987ead0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b987ce10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b987d310>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b987ead0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b86ac910>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x559010a24613 \\u003Cunknown>\\n#17 0x7f8802a9caa4 \\u003Cunknown>\\n#18 0x7f8802b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x559010a2567a <unknown>
E       #1 0x5590104a4566 <unknown>
E       #2 0x5590104dfb4c <unknown>
E       #3 0x5590104db7c4 <unknown>
E       #4 0x55901052abd3 <unknown>
E       #5 0x55901052a286 <unknown>
E       #6 0x55901051c403 <unknown>
E       #7 0x5590104e8b02 <unknown>
E       #8 0x5590104e97c1 <unknown>
E       #9 0x5590109e9448 <unknown>
E       #10 0x5590109ed2af <unknown>
E       #11 0x5590109d08d9 <unknown>
E       #12 0x5590109ede55 <unknown>
E       #13 0x5590109b613f <unknown>
E       #14 0x559010a124b8 <unknown>
E       #15 0x559010a12693 <unknown>
E       #16 0x559010a24613 <unknown>
E       #17 0x7f8802a9caa4 <unknown>
E       #18 0x7f8802b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x559010a2567a <unknown>
E           #1 0x5590104a4566 <unknown>
E           #2 0x5590104dfb4c <unknown>
E           #3 0x5590104db7c4 <unknown>
E           #4 0x55901052abd3 <unknown>
E           #5 0x55901052a286 <unknown>
E           #6 0x55901051c403 <unknown>
E           #7 0x5590104e8b02 <unknown>
E           #8 0x5590104e97c1 <unknown>
E           #9 0x5590109e9448 <unknown>
E           #10 0x5590109ed2af <unknown>
E           #11 0x5590109d08d9 <unknown>
E           #12 0x5590109ede55 <unknown>
E           #13 0x5590109b613f <unknown>
E           #14 0x559010a124b8 <unknown>
E           #15 0x559010a12693 <unknown>
E           #16 0x559010a24613 <unknown>
E           #17 0x7f8802a9caa4 <unknown>
E           #18 0x7f8802b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:37,005 - INFO - Starting test with Chrome browser
2025-10-16 15:13:37,005 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:37,071 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:37,108 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:37,142 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:38,229 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x559010a2567a <unknown>
#1 0x5590104a4566 <unknown>
#2 0x5590104dfb4c <unknown>
#3 0x5590104db7c4 <unknown>
#4 0x55901052abd3 <unknown>
#5 0x55901052a286 <unknown>
#6 0x55901051c403 <unknown>
#7 0x5590104e8b02 <unknown>
#8 0x5590104e97c1 <unknown>
#9 0x5590109e9448 <unknown>
#10 0x5590109ed2af <unknown>
#11 0x5590109d08d9 <unknown>
#12 0x5590109ede55 <unknown>
#13 0x5590109b613f <unknown>
#14 0x559010a124b8 <unknown>
#15 0x559010a12693 <unknown>
#16 0x559010a24613 <unknown>
#17 0x7f8802a9caa4 <unknown>
#18 0x7f8802b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x559010a2567a <unknown>
#1 0x5590104a4566 <unknown>
#2 0x5590104dfb4c <unknown>
#3 0x5590104db7c4 <unknown>
#4 0x55901052abd3 <unknown>
#5 0x55901052a286 <unknown>
#6 0x55901051c403 <unknown>
#7 0x5590104e8b02 <unknown>
#8 0x5590104e97c1 <unknown>
#9 0x5590109e9448 <unknown>
#10 0x5590109ed2af <unknown>
#11 0x5590109d08d9 <unknown>
#12 0x5590109ede55 <unknown>
#13 0x5590109b613f <unknown>
#14 0x559010a124b8 <unknown>
#15 0x559010a12693 <unknown>
#16 0x559010a24613 <unknown>
#17 0x7f8802a9caa4 <unknown>
#18 0x7f8802b29c6c <unknown>
_ ERROR at setup of test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b984eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b984ec40>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b984eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b984ec40>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b984f100>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b984eb10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b984efd0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55b6cc2c6613 \\u003Cunknown>\\n#17 0x7f1fe4c9caa4 \\u003Cunknown>\\n#18 0x7f1fe4d29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55b6cc2c767a <unknown>
E       #1 0x55b6cbd46566 <unknown>
E       #2 0x55b6cbd81b4c <unknown>
E       #3 0x55b6cbd7d7c4 <unknown>
E       #4 0x55b6cbdccbd3 <unknown>
E       #5 0x55b6cbdcc286 <unknown>
E       #6 0x55b6cbdbe403 <unknown>
E       #7 0x55b6cbd8ab02 <unknown>
E       #8 0x55b6cbd8b7c1 <unknown>
E       #9 0x55b6cc28b448 <unknown>
E       #10 0x55b6cc28f2af <unknown>
E       #11 0x55b6cc2728d9 <unknown>
E       #12 0x55b6cc28fe55 <unknown>
E       #13 0x55b6cc25813f <unknown>
E       #14 0x55b6cc2b44b8 <unknown>
E       #15 0x55b6cc2b4693 <unknown>
E       #16 0x55b6cc2c6613 <unknown>
E       #17 0x7f1fe4c9caa4 <unknown>
E       #18 0x7f1fe4d29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55b6cc2c767a <unknown>
E           #1 0x55b6cbd46566 <unknown>
E           #2 0x55b6cbd81b4c <unknown>
E           #3 0x55b6cbd7d7c4 <unknown>
E           #4 0x55b6cbdccbd3 <unknown>
E           #5 0x55b6cbdcc286 <unknown>
E           #6 0x55b6cbdbe403 <unknown>
E           #7 0x55b6cbd8ab02 <unknown>
E           #8 0x55b6cbd8b7c1 <unknown>
E           #9 0x55b6cc28b448 <unknown>
E           #10 0x55b6cc28f2af <unknown>
E           #11 0x55b6cc2728d9 <unknown>
E           #12 0x55b6cc28fe55 <unknown>
E           #13 0x55b6cc25813f <unknown>
E           #14 0x55b6cc2b44b8 <unknown>
E           #15 0x55b6cc2b4693 <unknown>
E           #16 0x55b6cc2c6613 <unknown>
E           #17 0x7f1fe4c9caa4 <unknown>
E           #18 0x7f1fe4d29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:38,269 - INFO - Starting test with Chrome browser
2025-10-16 15:13:38,269 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:38,333 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:38,369 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:38,402 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:39,490 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b6cc2c767a <unknown>
#1 0x55b6cbd46566 <unknown>
#2 0x55b6cbd81b4c <unknown>
#3 0x55b6cbd7d7c4 <unknown>
#4 0x55b6cbdccbd3 <unknown>
#5 0x55b6cbdcc286 <unknown>
#6 0x55b6cbdbe403 <unknown>
#7 0x55b6cbd8ab02 <unknown>
#8 0x55b6cbd8b7c1 <unknown>
#9 0x55b6cc28b448 <unknown>
#10 0x55b6cc28f2af <unknown>
#11 0x55b6cc2728d9 <unknown>
#12 0x55b6cc28fe55 <unknown>
#13 0x55b6cc25813f <unknown>
#14 0x55b6cc2b44b8 <unknown>
#15 0x55b6cc2b4693 <unknown>
#16 0x55b6cc2c6613 <unknown>
#17 0x7f1fe4c9caa4 <unknown>
#18 0x7f1fe4d29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b6cc2c767a <unknown>
#1 0x55b6cbd46566 <unknown>
#2 0x55b6cbd81b4c <unknown>
#3 0x55b6cbd7d7c4 <unknown>
#4 0x55b6cbdccbd3 <unknown>
#5 0x55b6cbdcc286 <unknown>
#6 0x55b6cbdbe403 <unknown>
#7 0x55b6cbd8ab02 <unknown>
#8 0x55b6cbd8b7c1 <unknown>
#9 0x55b6cc28b448 <unknown>
#10 0x55b6cc28f2af <unknown>
#11 0x55b6cc2728d9 <unknown>
#12 0x55b6cc28fe55 <unknown>
#13 0x55b6cc25813f <unknown>
#14 0x55b6cc2b44b8 <unknown>
#15 0x55b6cc2b4693 <unknown>
#16 0x55b6cc2c6613 <unknown>
#17 0x7f1fe4c9caa4 <unknown>
#18 0x7f1fe4d29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username0] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b984f950>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b86982b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b984f950>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b86982b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b8698510>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b984f950>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b86983e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5558c1293613 \\u003Cunknown>\\n#17 0x7f8f9c09caa4 \\u003Cunknown>\\n#18 0x7f8f9c129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5558c129467a <unknown>
E       #1 0x5558c0d13566 <unknown>
E       #2 0x5558c0d4eb4c <unknown>
E       #3 0x5558c0d4a7c4 <unknown>
E       #4 0x5558c0d99bd3 <unknown>
E       #5 0x5558c0d99286 <unknown>
E       #6 0x5558c0d8b403 <unknown>
E       #7 0x5558c0d57b02 <unknown>
E       #8 0x5558c0d587c1 <unknown>
E       #9 0x5558c1258448 <unknown>
E       #10 0x5558c125c2af <unknown>
E       #11 0x5558c123f8d9 <unknown>
E       #12 0x5558c125ce55 <unknown>
E       #13 0x5558c122513f <unknown>
E       #14 0x5558c12814b8 <unknown>
E       #15 0x5558c1281693 <unknown>
E       #16 0x5558c1293613 <unknown>
E       #17 0x7f8f9c09caa4 <unknown>
E       #18 0x7f8f9c129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5558c129467a <unknown>
E           #1 0x5558c0d13566 <unknown>
E           #2 0x5558c0d4eb4c <unknown>
E           #3 0x5558c0d4a7c4 <unknown>
E           #4 0x5558c0d99bd3 <unknown>
E           #5 0x5558c0d99286 <unknown>
E           #6 0x5558c0d8b403 <unknown>
E           #7 0x5558c0d57b02 <unknown>
E           #8 0x5558c0d587c1 <unknown>
E           #9 0x5558c1258448 <unknown>
E           #10 0x5558c125c2af <unknown>
E           #11 0x5558c123f8d9 <unknown>
E           #12 0x5558c125ce55 <unknown>
E           #13 0x5558c122513f <unknown>
E           #14 0x5558c12814b8 <unknown>
E           #15 0x5558c1281693 <unknown>
E           #16 0x5558c1293613 <unknown>
E           #17 0x7f8f9c09caa4 <unknown>
E           #18 0x7f8f9c129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:39,528 - INFO - Starting test with Chrome browser
2025-10-16 15:13:39,529 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:39,593 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:39,629 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:39,664 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:40,754 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5558c129467a <unknown>
#1 0x5558c0d13566 <unknown>
#2 0x5558c0d4eb4c <unknown>
#3 0x5558c0d4a7c4 <unknown>
#4 0x5558c0d99bd3 <unknown>
#5 0x5558c0d99286 <unknown>
#6 0x5558c0d8b403 <unknown>
#7 0x5558c0d57b02 <unknown>
#8 0x5558c0d587c1 <unknown>
#9 0x5558c1258448 <unknown>
#10 0x5558c125c2af <unknown>
#11 0x5558c123f8d9 <unknown>
#12 0x5558c125ce55 <unknown>
#13 0x5558c122513f <unknown>
#14 0x5558c12814b8 <unknown>
#15 0x5558c1281693 <unknown>
#16 0x5558c1293613 <unknown>
#17 0x7f8f9c09caa4 <unknown>
#18 0x7f8f9c129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5558c129467a <unknown>
#1 0x5558c0d13566 <unknown>
#2 0x5558c0d4eb4c <unknown>
#3 0x5558c0d4a7c4 <unknown>
#4 0x5558c0d99bd3 <unknown>
#5 0x5558c0d99286 <unknown>
#6 0x5558c0d8b403 <unknown>
#7 0x5558c0d57b02 <unknown>
#8 0x5558c0d587c1 <unknown>
#9 0x5558c1258448 <unknown>
#10 0x5558c125c2af <unknown>
#11 0x5558c123f8d9 <unknown>
#12 0x5558c125ce55 <unknown>
#13 0x5558c122513f <unknown>
#14 0x5558c12814b8 <unknown>
#15 0x5558c1281693 <unknown>
#16 0x5558c1293613 <unknown>
#17 0x7f8f9c09caa4 <unknown>
#18 0x7f8f9c129c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username1] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9842b10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b86743b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9842b10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b86743b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b8674b90>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9842b10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b8674a70>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55fcc7012613 \\u003Cunknown>\\n#17 0x7fa971a9caa4 \\u003Cunknown>\\n#18 0x7fa971b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55fcc701367a <unknown>
E       #1 0x55fcc6a92566 <unknown>
E       #2 0x55fcc6acdb4c <unknown>
E       #3 0x55fcc6ac97c4 <unknown>
E       #4 0x55fcc6b18bd3 <unknown>
E       #5 0x55fcc6b18286 <unknown>
E       #6 0x55fcc6b0a403 <unknown>
E       #7 0x55fcc6ad6b02 <unknown>
E       #8 0x55fcc6ad77c1 <unknown>
E       #9 0x55fcc6fd7448 <unknown>
E       #10 0x55fcc6fdb2af <unknown>
E       #11 0x55fcc6fbe8d9 <unknown>
E       #12 0x55fcc6fdbe55 <unknown>
E       #13 0x55fcc6fa413f <unknown>
E       #14 0x55fcc70004b8 <unknown>
E       #15 0x55fcc7000693 <unknown>
E       #16 0x55fcc7012613 <unknown>
E       #17 0x7fa971a9caa4 <unknown>
E       #18 0x7fa971b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55fcc701367a <unknown>
E           #1 0x55fcc6a92566 <unknown>
E           #2 0x55fcc6acdb4c <unknown>
E           #3 0x55fcc6ac97c4 <unknown>
E           #4 0x55fcc6b18bd3 <unknown>
E           #5 0x55fcc6b18286 <unknown>
E           #6 0x55fcc6b0a403 <unknown>
E           #7 0x55fcc6ad6b02 <unknown>
E           #8 0x55fcc6ad77c1 <unknown>
E           #9 0x55fcc6fd7448 <unknown>
E           #10 0x55fcc6fdb2af <unknown>
E           #11 0x55fcc6fbe8d9 <unknown>
E           #12 0x55fcc6fdbe55 <unknown>
E           #13 0x55fcc6fa413f <unknown>
E           #14 0x55fcc70004b8 <unknown>
E           #15 0x55fcc7000693 <unknown>
E           #16 0x55fcc7012613 <unknown>
E           #17 0x7fa971a9caa4 <unknown>
E           #18 0x7fa971b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:40,793 - INFO - Starting test with Chrome browser
2025-10-16 15:13:40,793 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:40,860 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:40,896 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:40,930 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:42,022 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55fcc701367a <unknown>
#1 0x55fcc6a92566 <unknown>
#2 0x55fcc6acdb4c <unknown>
#3 0x55fcc6ac97c4 <unknown>
#4 0x55fcc6b18bd3 <unknown>
#5 0x55fcc6b18286 <unknown>
#6 0x55fcc6b0a403 <unknown>
#7 0x55fcc6ad6b02 <unknown>
#8 0x55fcc6ad77c1 <unknown>
#9 0x55fcc6fd7448 <unknown>
#10 0x55fcc6fdb2af <unknown>
#11 0x55fcc6fbe8d9 <unknown>
#12 0x55fcc6fdbe55 <unknown>
#13 0x55fcc6fa413f <unknown>
#14 0x55fcc70004b8 <unknown>
#15 0x55fcc7000693 <unknown>
#16 0x55fcc7012613 <unknown>
#17 0x7fa971a9caa4 <unknown>
#18 0x7fa971b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55fcc701367a <unknown>
#1 0x55fcc6a92566 <unknown>
#2 0x55fcc6acdb4c <unknown>
#3 0x55fcc6ac97c4 <unknown>
#4 0x55fcc6b18bd3 <unknown>
#5 0x55fcc6b18286 <unknown>
#6 0x55fcc6b0a403 <unknown>
#7 0x55fcc6ad6b02 <unknown>
#8 0x55fcc6ad77c1 <unknown>
#9 0x55fcc6fd7448 <unknown>
#10 0x55fcc6fdb2af <unknown>
#11 0x55fcc6fbe8d9 <unknown>
#12 0x55fcc6fdbe55 <unknown>
#13 0x55fcc6fa413f <unknown>
#14 0x55fcc70004b8 <unknown>
#15 0x55fcc7000693 <unknown>
#16 0x55fcc7012613 <unknown>
#17 0x7fa971a9caa4 <unknown>
#18 0x7fa971b29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username2] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b988b8a0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b988b9b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b988b8a0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b988b9b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b988aad0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b988b8a0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b988abe0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55fbb0f0c613 \\u003Cunknown>\\n#17 0x7fb70569caa4 \\u003Cunknown>\\n#18 0x7fb705729c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55fbb0f0d67a <unknown>
E       #1 0x55fbb098c566 <unknown>
E       #2 0x55fbb09c7b4c <unknown>
E       #3 0x55fbb09c37c4 <unknown>
E       #4 0x55fbb0a12bd3 <unknown>
E       #5 0x55fbb0a12286 <unknown>
E       #6 0x55fbb0a04403 <unknown>
E       #7 0x55fbb09d0b02 <unknown>
E       #8 0x55fbb09d17c1 <unknown>
E       #9 0x55fbb0ed1448 <unknown>
E       #10 0x55fbb0ed52af <unknown>
E       #11 0x55fbb0eb88d9 <unknown>
E       #12 0x55fbb0ed5e55 <unknown>
E       #13 0x55fbb0e9e13f <unknown>
E       #14 0x55fbb0efa4b8 <unknown>
E       #15 0x55fbb0efa693 <unknown>
E       #16 0x55fbb0f0c613 <unknown>
E       #17 0x7fb70569caa4 <unknown>
E       #18 0x7fb705729c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55fbb0f0d67a <unknown>
E           #1 0x55fbb098c566 <unknown>
E           #2 0x55fbb09c7b4c <unknown>
E           #3 0x55fbb09c37c4 <unknown>
E           #4 0x55fbb0a12bd3 <unknown>
E           #5 0x55fbb0a12286 <unknown>
E           #6 0x55fbb0a04403 <unknown>
E           #7 0x55fbb09d0b02 <unknown>
E           #8 0x55fbb09d17c1 <unknown>
E           #9 0x55fbb0ed1448 <unknown>
E           #10 0x55fbb0ed52af <unknown>
E           #11 0x55fbb0eb88d9 <unknown>
E           #12 0x55fbb0ed5e55 <unknown>
E           #13 0x55fbb0e9e13f <unknown>
E           #14 0x55fbb0efa4b8 <unknown>
E           #15 0x55fbb0efa693 <unknown>
E           #16 0x55fbb0f0c613 <unknown>
E           #17 0x7fb70569caa4 <unknown>
E           #18 0x7fb705729c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:42,062 - INFO - Starting test with Chrome browser
2025-10-16 15:13:42,062 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:42,129 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:42,164 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:42,201 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:43,290 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55fbb0f0d67a <unknown>
#1 0x55fbb098c566 <unknown>
#2 0x55fbb09c7b4c <unknown>
#3 0x55fbb09c37c4 <unknown>
#4 0x55fbb0a12bd3 <unknown>
#5 0x55fbb0a12286 <unknown>
#6 0x55fbb0a04403 <unknown>
#7 0x55fbb09d0b02 <unknown>
#8 0x55fbb09d17c1 <unknown>
#9 0x55fbb0ed1448 <unknown>
#10 0x55fbb0ed52af <unknown>
#11 0x55fbb0eb88d9 <unknown>
#12 0x55fbb0ed5e55 <unknown>
#13 0x55fbb0e9e13f <unknown>
#14 0x55fbb0efa4b8 <unknown>
#15 0x55fbb0efa693 <unknown>
#16 0x55fbb0f0c613 <unknown>
#17 0x7fb70569caa4 <unknown>
#18 0x7fb705729c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55fbb0f0d67a <unknown>
#1 0x55fbb098c566 <unknown>
#2 0x55fbb09c7b4c <unknown>
#3 0x55fbb09c37c4 <unknown>
#4 0x55fbb0a12bd3 <unknown>
#5 0x55fbb0a12286 <unknown>
#6 0x55fbb0a04403 <unknown>
#7 0x55fbb09d0b02 <unknown>
#8 0x55fbb09d17c1 <unknown>
#9 0x55fbb0ed1448 <unknown>
#10 0x55fbb0ed52af <unknown>
#11 0x55fbb0eb88d9 <unknown>
#12 0x55fbb0ed5e55 <unknown>
#13 0x55fbb0e9e13f <unknown>
#14 0x55fbb0efa4b8 <unknown>
#15 0x55fbb0efa693 <unknown>
#16 0x55fbb0f0c613 <unknown>
#17 0x7fb70569caa4 <unknown>
#18 0x7fb705729c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username3] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9888d10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b8ddcc00>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9888d10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b8ddcc00>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b8ddc8d0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b9888d10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b8ddc9e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55628f88f613 \\u003Cunknown>\\n#17 0x7f643fc9caa4 \\u003Cunknown>\\n#18 0x7f643fd29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55628f89067a <unknown>
E       #1 0x55628f30f566 <unknown>
E       #2 0x55628f34ab4c <unknown>
E       #3 0x55628f3467c4 <unknown>
E       #4 0x55628f395bd3 <unknown>
E       #5 0x55628f395286 <unknown>
E       #6 0x55628f387403 <unknown>
E       #7 0x55628f353b02 <unknown>
E       #8 0x55628f3547c1 <unknown>
E       #9 0x55628f854448 <unknown>
E       #10 0x55628f8582af <unknown>
E       #11 0x55628f83b8d9 <unknown>
E       #12 0x55628f858e55 <unknown>
E       #13 0x55628f82113f <unknown>
E       #14 0x55628f87d4b8 <unknown>
E       #15 0x55628f87d693 <unknown>
E       #16 0x55628f88f613 <unknown>
E       #17 0x7f643fc9caa4 <unknown>
E       #18 0x7f643fd29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55628f89067a <unknown>
E           #1 0x55628f30f566 <unknown>
E           #2 0x55628f34ab4c <unknown>
E           #3 0x55628f3467c4 <unknown>
E           #4 0x55628f395bd3 <unknown>
E           #5 0x55628f395286 <unknown>
E           #6 0x55628f387403 <unknown>
E           #7 0x55628f353b02 <unknown>
E           #8 0x55628f3547c1 <unknown>
E           #9 0x55628f854448 <unknown>
E           #10 0x55628f8582af <unknown>
E           #11 0x55628f83b8d9 <unknown>
E           #12 0x55628f858e55 <unknown>
E           #13 0x55628f82113f <unknown>
E           #14 0x55628f87d4b8 <unknown>
E           #15 0x55628f87d693 <unknown>
E           #16 0x55628f88f613 <unknown>
E           #17 0x7f643fc9caa4 <unknown>
E           #18 0x7f643fd29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:43,329 - INFO - Starting test with Chrome browser
2025-10-16 15:13:43,329 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:43,393 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:43,429 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:43,461 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:44,550 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55628f89067a <unknown>
#1 0x55628f30f566 <unknown>
#2 0x55628f34ab4c <unknown>
#3 0x55628f3467c4 <unknown>
#4 0x55628f395bd3 <unknown>
#5 0x55628f395286 <unknown>
#6 0x55628f387403 <unknown>
#7 0x55628f353b02 <unknown>
#8 0x55628f3547c1 <unknown>
#9 0x55628f854448 <unknown>
#10 0x55628f8582af <unknown>
#11 0x55628f83b8d9 <unknown>
#12 0x55628f858e55 <unknown>
#13 0x55628f82113f <unknown>
#14 0x55628f87d4b8 <unknown>
#15 0x55628f87d693 <unknown>
#16 0x55628f88f613 <unknown>
#17 0x7f643fc9caa4 <unknown>
#18 0x7f643fd29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55628f89067a <unknown>
#1 0x55628f30f566 <unknown>
#2 0x55628f34ab4c <unknown>
#3 0x55628f3467c4 <unknown>
#4 0x55628f395bd3 <unknown>
#5 0x55628f395286 <unknown>
#6 0x55628f387403 <unknown>
#7 0x55628f353b02 <unknown>
#8 0x55628f3547c1 <unknown>
#9 0x55628f854448 <unknown>
#10 0x55628f8582af <unknown>
#11 0x55628f83b8d9 <unknown>
#12 0x55628f858e55 <unknown>
#13 0x55628f82113f <unknown>
#14 0x55628f87d4b8 <unknown>
#15 0x55628f87d693 <unknown>
#16 0x55628f88f613 <unknown>
#17 0x7f643fc9caa4 <unknown>
#18 0x7f643fd29c6c <unknown>
_______________ ERROR at setup of test_blank_username_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b8640450>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b8640550>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b8640450>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b8640550>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b8640050>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b8640450>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b8640750>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55d4a9564613 \\u003Cunknown>\\n#17 0x7fca1ba9caa4 \\u003Cunknown>\\n#18 0x7fca1bb29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55d4a956567a <unknown>
E       #1 0x55d4a8fe4566 <unknown>
E       #2 0x55d4a901fb4c <unknown>
E       #3 0x55d4a901b7c4 <unknown>
E       #4 0x55d4a906abd3 <unknown>
E       #5 0x55d4a906a286 <unknown>
E       #6 0x55d4a905c403 <unknown>
E       #7 0x55d4a9028b02 <unknown>
E       #8 0x55d4a90297c1 <unknown>
E       #9 0x55d4a9529448 <unknown>
E       #10 0x55d4a952d2af <unknown>
E       #11 0x55d4a95108d9 <unknown>
E       #12 0x55d4a952de55 <unknown>
E       #13 0x55d4a94f613f <unknown>
E       #14 0x55d4a95524b8 <unknown>
E       #15 0x55d4a9552693 <unknown>
E       #16 0x55d4a9564613 <unknown>
E       #17 0x7fca1ba9caa4 <unknown>
E       #18 0x7fca1bb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55d4a956567a <unknown>
E           #1 0x55d4a8fe4566 <unknown>
E           #2 0x55d4a901fb4c <unknown>
E           #3 0x55d4a901b7c4 <unknown>
E           #4 0x55d4a906abd3 <unknown>
E           #5 0x55d4a906a286 <unknown>
E           #6 0x55d4a905c403 <unknown>
E           #7 0x55d4a9028b02 <unknown>
E           #8 0x55d4a90297c1 <unknown>
E           #9 0x55d4a9529448 <unknown>
E           #10 0x55d4a952d2af <unknown>
E           #11 0x55d4a95108d9 <unknown>
E           #12 0x55d4a952de55 <unknown>
E           #13 0x55d4a94f613f <unknown>
E           #14 0x55d4a95524b8 <unknown>
E           #15 0x55d4a9552693 <unknown>
E           #16 0x55d4a9564613 <unknown>
E           #17 0x7fca1ba9caa4 <unknown>
E           #18 0x7fca1bb29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:44,589 - INFO - Starting test with Chrome browser
2025-10-16 15:13:44,589 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:44,655 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:44,691 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:44,725 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:45,815 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d4a956567a <unknown>
#1 0x55d4a8fe4566 <unknown>
#2 0x55d4a901fb4c <unknown>
#3 0x55d4a901b7c4 <unknown>
#4 0x55d4a906abd3 <unknown>
#5 0x55d4a906a286 <unknown>
#6 0x55d4a905c403 <unknown>
#7 0x55d4a9028b02 <unknown>
#8 0x55d4a90297c1 <unknown>
#9 0x55d4a9529448 <unknown>
#10 0x55d4a952d2af <unknown>
#11 0x55d4a95108d9 <unknown>
#12 0x55d4a952de55 <unknown>
#13 0x55d4a94f613f <unknown>
#14 0x55d4a95524b8 <unknown>
#15 0x55d4a9552693 <unknown>
#16 0x55d4a9564613 <unknown>
#17 0x7fca1ba9caa4 <unknown>
#18 0x7fca1bb29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d4a956567a <unknown>
#1 0x55d4a8fe4566 <unknown>
#2 0x55d4a901fb4c <unknown>
#3 0x55d4a901b7c4 <unknown>
#4 0x55d4a906abd3 <unknown>
#5 0x55d4a906a286 <unknown>
#6 0x55d4a905c403 <unknown>
#7 0x55d4a9028b02 <unknown>
#8 0x55d4a90297c1 <unknown>
#9 0x55d4a9529448 <unknown>
#10 0x55d4a952d2af <unknown>
#11 0x55d4a95108d9 <unknown>
#12 0x55d4a952de55 <unknown>
#13 0x55d4a94f613f <unknown>
#14 0x55d4a95524b8 <unknown>
#15 0x55d4a9552693 <unknown>
#16 0x55d4a9564613 <unknown>
#17 0x7fca1ba9caa4 <unknown>
#18 0x7fca1bb29c6c <unknown>
_______________ ERROR at setup of test_blank_password_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b8642550>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b8642850>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b8642550>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b8642850>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b8642d50>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b8642550>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b8642c50>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55cd4604d613 \\u003Cunknown>\\n#17 0x7fd95ae9caa4 \\u003Cunknown>\\n#18 0x7fd95af29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55cd4604e67a <unknown>
E       #1 0x55cd45acd566 <unknown>
E       #2 0x55cd45b08b4c <unknown>
E       #3 0x55cd45b047c4 <unknown>
E       #4 0x55cd45b53bd3 <unknown>
E       #5 0x55cd45b53286 <unknown>
E       #6 0x55cd45b45403 <unknown>
E       #7 0x55cd45b11b02 <unknown>
E       #8 0x55cd45b127c1 <unknown>
E       #9 0x55cd46012448 <unknown>
E       #10 0x55cd460162af <unknown>
E       #11 0x55cd45ff98d9 <unknown>
E       #12 0x55cd46016e55 <unknown>
E       #13 0x55cd45fdf13f <unknown>
E       #14 0x55cd4603b4b8 <unknown>
E       #15 0x55cd4603b693 <unknown>
E       #16 0x55cd4604d613 <unknown>
E       #17 0x7fd95ae9caa4 <unknown>
E       #18 0x7fd95af29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55cd4604e67a <unknown>
E           #1 0x55cd45acd566 <unknown>
E           #2 0x55cd45b08b4c <unknown>
E           #3 0x55cd45b047c4 <unknown>
E           #4 0x55cd45b53bd3 <unknown>
E           #5 0x55cd45b53286 <unknown>
E           #6 0x55cd45b45403 <unknown>
E           #7 0x55cd45b11b02 <unknown>
E           #8 0x55cd45b127c1 <unknown>
E           #9 0x55cd46012448 <unknown>
E           #10 0x55cd460162af <unknown>
E           #11 0x55cd45ff98d9 <unknown>
E           #12 0x55cd46016e55 <unknown>
E           #13 0x55cd45fdf13f <unknown>
E           #14 0x55cd4603b4b8 <unknown>
E           #15 0x55cd4603b693 <unknown>
E           #16 0x55cd4604d613 <unknown>
E           #17 0x7fd95ae9caa4 <unknown>
E           #18 0x7fd95af29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:45,854 - INFO - Starting test with Chrome browser
2025-10-16 15:13:45,854 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:45,919 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:45,956 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:45,994 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:47,083 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55cd4604e67a <unknown>
#1 0x55cd45acd566 <unknown>
#2 0x55cd45b08b4c <unknown>
#3 0x55cd45b047c4 <unknown>
#4 0x55cd45b53bd3 <unknown>
#5 0x55cd45b53286 <unknown>
#6 0x55cd45b45403 <unknown>
#7 0x55cd45b11b02 <unknown>
#8 0x55cd45b127c1 <unknown>
#9 0x55cd46012448 <unknown>
#10 0x55cd460162af <unknown>
#11 0x55cd45ff98d9 <unknown>
#12 0x55cd46016e55 <unknown>
#13 0x55cd45fdf13f <unknown>
#14 0x55cd4603b4b8 <unknown>
#15 0x55cd4603b693 <unknown>
#16 0x55cd4604d613 <unknown>
#17 0x7fd95ae9caa4 <unknown>
#18 0x7fd95af29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55cd4604e67a <unknown>
#1 0x55cd45acd566 <unknown>
#2 0x55cd45b08b4c <unknown>
#3 0x55cd45b047c4 <unknown>
#4 0x55cd45b53bd3 <unknown>
#5 0x55cd45b53286 <unknown>
#6 0x55cd45b45403 <unknown>
#7 0x55cd45b11b02 <unknown>
#8 0x55cd45b127c1 <unknown>
#9 0x55cd46012448 <unknown>
#10 0x55cd460162af <unknown>
#11 0x55cd45ff98d9 <unknown>
#12 0x55cd46016e55 <unknown>
#13 0x55cd45fdf13f <unknown>
#14 0x55cd4603b4b8 <unknown>
#15 0x55cd4603b693 <unknown>
#16 0x55cd4604d613 <unknown>
#17 0x7fd95ae9caa4 <unknown>
#18 0x7fd95af29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username0] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98b0140>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b98b0230>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98b0140>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b98b0230>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b98b1c70>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98b0140>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b98b15e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5565a6f2f613 \\u003Cunknown>\\n#17 0x7fa34149caa4 \\u003Cunknown>\\n#18 0x7fa341529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5565a6f3067a <unknown>
E       #1 0x5565a69af566 <unknown>
E       #2 0x5565a69eab4c <unknown>
E       #3 0x5565a69e67c4 <unknown>
E       #4 0x5565a6a35bd3 <unknown>
E       #5 0x5565a6a35286 <unknown>
E       #6 0x5565a6a27403 <unknown>
E       #7 0x5565a69f3b02 <unknown>
E       #8 0x5565a69f47c1 <unknown>
E       #9 0x5565a6ef4448 <unknown>
E       #10 0x5565a6ef82af <unknown>
E       #11 0x5565a6edb8d9 <unknown>
E       #12 0x5565a6ef8e55 <unknown>
E       #13 0x5565a6ec113f <unknown>
E       #14 0x5565a6f1d4b8 <unknown>
E       #15 0x5565a6f1d693 <unknown>
E       #16 0x5565a6f2f613 <unknown>
E       #17 0x7fa34149caa4 <unknown>
E       #18 0x7fa341529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5565a6f3067a <unknown>
E           #1 0x5565a69af566 <unknown>
E           #2 0x5565a69eab4c <unknown>
E           #3 0x5565a69e67c4 <unknown>
E           #4 0x5565a6a35bd3 <unknown>
E           #5 0x5565a6a35286 <unknown>
E           #6 0x5565a6a27403 <unknown>
E           #7 0x5565a69f3b02 <unknown>
E           #8 0x5565a69f47c1 <unknown>
E           #9 0x5565a6ef4448 <unknown>
E           #10 0x5565a6ef82af <unknown>
E           #11 0x5565a6edb8d9 <unknown>
E           #12 0x5565a6ef8e55 <unknown>
E           #13 0x5565a6ec113f <unknown>
E           #14 0x5565a6f1d4b8 <unknown>
E           #15 0x5565a6f1d693 <unknown>
E           #16 0x5565a6f2f613 <unknown>
E           #17 0x7fa34149caa4 <unknown>
E           #18 0x7fa341529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:47,124 - INFO - Starting test with Chrome browser
2025-10-16 15:13:47,124 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:47,190 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:47,223 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:47,257 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:48,346 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5565a6f3067a <unknown>
#1 0x5565a69af566 <unknown>
#2 0x5565a69eab4c <unknown>
#3 0x5565a69e67c4 <unknown>
#4 0x5565a6a35bd3 <unknown>
#5 0x5565a6a35286 <unknown>
#6 0x5565a6a27403 <unknown>
#7 0x5565a69f3b02 <unknown>
#8 0x5565a69f47c1 <unknown>
#9 0x5565a6ef4448 <unknown>
#10 0x5565a6ef82af <unknown>
#11 0x5565a6edb8d9 <unknown>
#12 0x5565a6ef8e55 <unknown>
#13 0x5565a6ec113f <unknown>
#14 0x5565a6f1d4b8 <unknown>
#15 0x5565a6f1d693 <unknown>
#16 0x5565a6f2f613 <unknown>
#17 0x7fa34149caa4 <unknown>
#18 0x7fa341529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5565a6f3067a <unknown>
#1 0x5565a69af566 <unknown>
#2 0x5565a69eab4c <unknown>
#3 0x5565a69e67c4 <unknown>
#4 0x5565a6a35bd3 <unknown>
#5 0x5565a6a35286 <unknown>
#6 0x5565a6a27403 <unknown>
#7 0x5565a69f3b02 <unknown>
#8 0x5565a69f47c1 <unknown>
#9 0x5565a6ef4448 <unknown>
#10 0x5565a6ef82af <unknown>
#11 0x5565a6edb8d9 <unknown>
#12 0x5565a6ef8e55 <unknown>
#13 0x5565a6ec113f <unknown>
#14 0x5565a6f1d4b8 <unknown>
#15 0x5565a6f1d693 <unknown>
#16 0x5565a6f2f613 <unknown>
#17 0x7fa34149caa4 <unknown>
#18 0x7fa341529c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username1] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98b2030>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b98b23f0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98b2030>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b98b23f0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b98b2300>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98b2030>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b8660050>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5589ca59e613 \\u003Cunknown>\\n#17 0x7fdfc2a9caa4 \\u003Cunknown>\\n#18 0x7fdfc2b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5589ca59f67a <unknown>
E       #1 0x5589ca01e566 <unknown>
E       #2 0x5589ca059b4c <unknown>
E       #3 0x5589ca0557c4 <unknown>
E       #4 0x5589ca0a4bd3 <unknown>
E       #5 0x5589ca0a4286 <unknown>
E       #6 0x5589ca096403 <unknown>
E       #7 0x5589ca062b02 <unknown>
E       #8 0x5589ca0637c1 <unknown>
E       #9 0x5589ca563448 <unknown>
E       #10 0x5589ca5672af <unknown>
E       #11 0x5589ca54a8d9 <unknown>
E       #12 0x5589ca567e55 <unknown>
E       #13 0x5589ca53013f <unknown>
E       #14 0x5589ca58c4b8 <unknown>
E       #15 0x5589ca58c693 <unknown>
E       #16 0x5589ca59e613 <unknown>
E       #17 0x7fdfc2a9caa4 <unknown>
E       #18 0x7fdfc2b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5589ca59f67a <unknown>
E           #1 0x5589ca01e566 <unknown>
E           #2 0x5589ca059b4c <unknown>
E           #3 0x5589ca0557c4 <unknown>
E           #4 0x5589ca0a4bd3 <unknown>
E           #5 0x5589ca0a4286 <unknown>
E           #6 0x5589ca096403 <unknown>
E           #7 0x5589ca062b02 <unknown>
E           #8 0x5589ca0637c1 <unknown>
E           #9 0x5589ca563448 <unknown>
E           #10 0x5589ca5672af <unknown>
E           #11 0x5589ca54a8d9 <unknown>
E           #12 0x5589ca567e55 <unknown>
E           #13 0x5589ca53013f <unknown>
E           #14 0x5589ca58c4b8 <unknown>
E           #15 0x5589ca58c693 <unknown>
E           #16 0x5589ca59e613 <unknown>
E           #17 0x7fdfc2a9caa4 <unknown>
E           #18 0x7fdfc2b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:48,385 - INFO - Starting test with Chrome browser
2025-10-16 15:13:48,385 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:48,450 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:48,484 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:48,517 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:49,605 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5589ca59f67a <unknown>
#1 0x5589ca01e566 <unknown>
#2 0x5589ca059b4c <unknown>
#3 0x5589ca0557c4 <unknown>
#4 0x5589ca0a4bd3 <unknown>
#5 0x5589ca0a4286 <unknown>
#6 0x5589ca096403 <unknown>
#7 0x5589ca062b02 <unknown>
#8 0x5589ca0637c1 <unknown>
#9 0x5589ca563448 <unknown>
#10 0x5589ca5672af <unknown>
#11 0x5589ca54a8d9 <unknown>
#12 0x5589ca567e55 <unknown>
#13 0x5589ca53013f <unknown>
#14 0x5589ca58c4b8 <unknown>
#15 0x5589ca58c693 <unknown>
#16 0x5589ca59e613 <unknown>
#17 0x7fdfc2a9caa4 <unknown>
#18 0x7fdfc2b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5589ca59f67a <unknown>
#1 0x5589ca01e566 <unknown>
#2 0x5589ca059b4c <unknown>
#3 0x5589ca0557c4 <unknown>
#4 0x5589ca0a4bd3 <unknown>
#5 0x5589ca0a4286 <unknown>
#6 0x5589ca096403 <unknown>
#7 0x5589ca062b02 <unknown>
#8 0x5589ca0637c1 <unknown>
#9 0x5589ca563448 <unknown>
#10 0x5589ca5672af <unknown>
#11 0x5589ca54a8d9 <unknown>
#12 0x5589ca567e55 <unknown>
#13 0x5589ca53013f <unknown>
#14 0x5589ca58c4b8 <unknown>
#15 0x5589ca58c693 <unknown>
#16 0x5589ca59e613 <unknown>
#17 0x7fdfc2a9caa4 <unknown>
#18 0x7fdfc2b29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username2] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98dce50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b98dd7f0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98dce50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b98dd7f0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b98dd550>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b98dce50>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b98de970>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x557e53824613 \\u003Cunknown>\\n#17 0x7f3df6a9caa4 \\u003Cunknown>\\n#18 0x7f3df6b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x557e5382567a <unknown>
E       #1 0x557e532a4566 <unknown>
E       #2 0x557e532dfb4c <unknown>
E       #3 0x557e532db7c4 <unknown>
E       #4 0x557e5332abd3 <unknown>
E       #5 0x557e5332a286 <unknown>
E       #6 0x557e5331c403 <unknown>
E       #7 0x557e532e8b02 <unknown>
E       #8 0x557e532e97c1 <unknown>
E       #9 0x557e537e9448 <unknown>
E       #10 0x557e537ed2af <unknown>
E       #11 0x557e537d08d9 <unknown>
E       #12 0x557e537ede55 <unknown>
E       #13 0x557e537b613f <unknown>
E       #14 0x557e538124b8 <unknown>
E       #15 0x557e53812693 <unknown>
E       #16 0x557e53824613 <unknown>
E       #17 0x7f3df6a9caa4 <unknown>
E       #18 0x7f3df6b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x557e5382567a <unknown>
E           #1 0x557e532a4566 <unknown>
E           #2 0x557e532dfb4c <unknown>
E           #3 0x557e532db7c4 <unknown>
E           #4 0x557e5332abd3 <unknown>
E           #5 0x557e5332a286 <unknown>
E           #6 0x557e5331c403 <unknown>
E           #7 0x557e532e8b02 <unknown>
E           #8 0x557e532e97c1 <unknown>
E           #9 0x557e537e9448 <unknown>
E           #10 0x557e537ed2af <unknown>
E           #11 0x557e537d08d9 <unknown>
E           #12 0x557e537ede55 <unknown>
E           #13 0x557e537b613f <unknown>
E           #14 0x557e538124b8 <unknown>
E           #15 0x557e53812693 <unknown>
E           #16 0x557e53824613 <unknown>
E           #17 0x7f3df6a9caa4 <unknown>
E           #18 0x7f3df6b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:49,645 - INFO - Starting test with Chrome browser
2025-10-16 15:13:49,645 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:49,711 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:49,746 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:49,778 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:50,869 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x557e5382567a <unknown>
#1 0x557e532a4566 <unknown>
#2 0x557e532dfb4c <unknown>
#3 0x557e532db7c4 <unknown>
#4 0x557e5332abd3 <unknown>
#5 0x557e5332a286 <unknown>
#6 0x557e5331c403 <unknown>
#7 0x557e532e8b02 <unknown>
#8 0x557e532e97c1 <unknown>
#9 0x557e537e9448 <unknown>
#10 0x557e537ed2af <unknown>
#11 0x557e537d08d9 <unknown>
#12 0x557e537ede55 <unknown>
#13 0x557e537b613f <unknown>
#14 0x557e538124b8 <unknown>
#15 0x557e53812693 <unknown>
#16 0x557e53824613 <unknown>
#17 0x7f3df6a9caa4 <unknown>
#18 0x7f3df6b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x557e5382567a <unknown>
#1 0x557e532a4566 <unknown>
#2 0x557e532dfb4c <unknown>
#3 0x557e532db7c4 <unknown>
#4 0x557e5332abd3 <unknown>
#5 0x557e5332a286 <unknown>
#6 0x557e5331c403 <unknown>
#7 0x557e532e8b02 <unknown>
#8 0x557e532e97c1 <unknown>
#9 0x557e537e9448 <unknown>
#10 0x557e537ed2af <unknown>
#11 0x557e537d08d9 <unknown>
#12 0x557e537ede55 <unknown>
#13 0x557e537b613f <unknown>
#14 0x557e538124b8 <unknown>
#15 0x557e53812693 <unknown>
#16 0x557e53824613 <unknown>
#17 0x7f3df6a9caa4 <unknown>
#18 0x7f3df6b29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username3] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b864cc90>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b864ce50>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b864cc90>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21b864ce50>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21b864d010>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21b864cc90>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21b864d470>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55c5db428613 \\u003Cunknown>\\n#17 0x7f006be9caa4 \\u003Cunknown>\\n#18 0x7f006bf29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55c5db42967a <unknown>
E       #1 0x55c5daea8566 <unknown>
E       #2 0x55c5daee3b4c <unknown>
E       #3 0x55c5daedf7c4 <unknown>
E       #4 0x55c5daf2ebd3 <unknown>
E       #5 0x55c5daf2e286 <unknown>
E       #6 0x55c5daf20403 <unknown>
E       #7 0x55c5daeecb02 <unknown>
E       #8 0x55c5daeed7c1 <unknown>
E       #9 0x55c5db3ed448 <unknown>
E       #10 0x55c5db3f12af <unknown>
E       #11 0x55c5db3d48d9 <unknown>
E       #12 0x55c5db3f1e55 <unknown>
E       #13 0x55c5db3ba13f <unknown>
E       #14 0x55c5db4164b8 <unknown>
E       #15 0x55c5db416693 <unknown>
E       #16 0x55c5db428613 <unknown>
E       #17 0x7f006be9caa4 <unknown>
E       #18 0x7f006bf29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55c5db42967a <unknown>
E           #1 0x55c5daea8566 <unknown>
E           #2 0x55c5daee3b4c <unknown>
E           #3 0x55c5daedf7c4 <unknown>
E           #4 0x55c5daf2ebd3 <unknown>
E           #5 0x55c5daf2e286 <unknown>
E           #6 0x55c5daf20403 <unknown>
E           #7 0x55c5daeecb02 <unknown>
E           #8 0x55c5daeed7c1 <unknown>
E           #9 0x55c5db3ed448 <unknown>
E           #10 0x55c5db3f12af <unknown>
E           #11 0x55c5db3d48d9 <unknown>
E           #12 0x55c5db3f1e55 <unknown>
E           #13 0x55c5db3ba13f <unknown>
E           #14 0x55c5db4164b8 <unknown>
E           #15 0x55c5db416693 <unknown>
E           #16 0x55c5db428613 <unknown>
E           #17 0x7f006be9caa4 <unknown>
E           #18 0x7f006bf29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:50,909 - INFO - Starting test with Chrome browser
2025-10-16 15:13:50,909 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:50,977 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:51,016 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:51,051 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:52,144 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55c5db42967a <unknown>
#1 0x55c5daea8566 <unknown>
#2 0x55c5daee3b4c <unknown>
#3 0x55c5daedf7c4 <unknown>
#4 0x55c5daf2ebd3 <unknown>
#5 0x55c5daf2e286 <unknown>
#6 0x55c5daf20403 <unknown>
#7 0x55c5daeecb02 <unknown>
#8 0x55c5daeed7c1 <unknown>
#9 0x55c5db3ed448 <unknown>
#10 0x55c5db3f12af <unknown>
#11 0x55c5db3d48d9 <unknown>
#12 0x55c5db3f1e55 <unknown>
#13 0x55c5db3ba13f <unknown>
#14 0x55c5db4164b8 <unknown>
#15 0x55c5db416693 <unknown>
#16 0x55c5db428613 <unknown>
#17 0x7f006be9caa4 <unknown>
#18 0x7f006bf29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55c5db42967a <unknown>
#1 0x55c5daea8566 <unknown>
#2 0x55c5daee3b4c <unknown>
#3 0x55c5daedf7c4 <unknown>
#4 0x55c5daf2ebd3 <unknown>
#5 0x55c5daf2e286 <unknown>
#6 0x55c5daf20403 <unknown>
#7 0x55c5daeecb02 <unknown>
#8 0x55c5daeed7c1 <unknown>
#9 0x55c5db3ed448 <unknown>
#10 0x55c5db3f12af <unknown>
#11 0x55c5db3d48d9 <unknown>
#12 0x55c5db3f1e55 <unknown>
#13 0x55c5db3ba13f <unknown>
#14 0x55c5db4164b8 <unknown>
#15 0x55c5db416693 <unknown>
#16 0x55c5db428613 <unknown>
#17 0x7f006be9caa4 <unknown>
#18 0x7f006bf29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username4] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f21babdf930>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21babdd4a0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f21babdf930>
service = <selenium.webdriver.chrome.service.Service object at 0x7f21babdd4a0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f21babdd300>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f21babdf930>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f21babdeea0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55ccd2ae1613 \\u003Cunknown>\\n#17 0x7fce5ce9caa4 \\u003Cunknown>\\n#18 0x7fce5cf29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55ccd2ae267a <unknown>
E       #1 0x55ccd2561566 <unknown>
E       #2 0x55ccd259cb4c <unknown>
E       #3 0x55ccd25987c4 <unknown>
E       #4 0x55ccd25e7bd3 <unknown>
E       #5 0x55ccd25e7286 <unknown>
E       #6 0x55ccd25d9403 <unknown>
E       #7 0x55ccd25a5b02 <unknown>
E       #8 0x55ccd25a67c1 <unknown>
E       #9 0x55ccd2aa6448 <unknown>
E       #10 0x55ccd2aaa2af <unknown>
E       #11 0x55ccd2a8d8d9 <unknown>
E       #12 0x55ccd2aaae55 <unknown>
E       #13 0x55ccd2a7313f <unknown>
E       #14 0x55ccd2acf4b8 <unknown>
E       #15 0x55ccd2acf693 <unknown>
E       #16 0x55ccd2ae1613 <unknown>
E       #17 0x7fce5ce9caa4 <unknown>
E       #18 0x7fce5cf29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55ccd2ae267a <unknown>
E           #1 0x55ccd2561566 <unknown>
E           #2 0x55ccd259cb4c <unknown>
E           #3 0x55ccd25987c4 <unknown>
E           #4 0x55ccd25e7bd3 <unknown>
E           #5 0x55ccd25e7286 <unknown>
E           #6 0x55ccd25d9403 <unknown>
E           #7 0x55ccd25a5b02 <unknown>
E           #8 0x55ccd25a67c1 <unknown>
E           #9 0x55ccd2aa6448 <unknown>
E           #10 0x55ccd2aaa2af <unknown>
E           #11 0x55ccd2a8d8d9 <unknown>
E           #12 0x55ccd2aaae55 <unknown>
E           #13 0x55ccd2a7313f <unknown>
E           #14 0x55ccd2acf4b8 <unknown>
E           #15 0x55ccd2acf693 <unknown>
E           #16 0x55ccd2ae1613 <unknown>
E           #17 0x7fce5ce9caa4 <unknown>
E           #18 0x7fce5cf29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-16 15:13:52,185 - INFO - Starting test with Chrome browser
2025-10-16 15:13:52,185 - INFO - ====== WebDriver manager ======
2025-10-16 15:13:52,255 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:52,290 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-16 15:13:52,324 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-16 15:13:53,418 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ccd2ae267a <unknown>
#1 0x55ccd2561566 <unknown>
#2 0x55ccd259cb4c <unknown>
#3 0x55ccd25987c4 <unknown>
#4 0x55ccd25e7bd3 <unknown>
#5 0x55ccd25e7286 <unknown>
#6 0x55ccd25d9403 <unknown>
#7 0x55ccd25a5b02 <unknown>
#8 0x55ccd25a67c1 <unknown>
#9 0x55ccd2aa6448 <unknown>
#10 0x55ccd2aaa2af <unknown>
#11 0x55ccd2a8d8d9 <unknown>
#12 0x55ccd2aaae55 <unknown>
#13 0x55ccd2a7313f <unknown>
#14 0x55ccd2acf4b8 <unknown>
#15 0x55ccd2acf693 <unknown>
#16 0x55ccd2ae1613 <unknown>
#17 0x7fce5ce9caa4 <unknown>
#18 0x7fce5cf29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ccd2ae267a <unknown>
#1 0x55ccd2561566 <unknown>
#2 0x55ccd259cb4c <unknown>
#3 0x55ccd25987c4 <unknown>
#4 0x55ccd25e7bd3 <unknown>
#5 0x55ccd25e7286 <unknown>
#6 0x55ccd25d9403 <unknown>
#7 0x55ccd25a5b02 <unknown>
#8 0x55ccd25a67c1 <unknown>
#9 0x55ccd2aa6448 <unknown>
#10 0x55ccd2aaa2af <unknown>
#11 0x55ccd2a8d8d9 <unknown>
#12 0x55ccd2aaae55 <unknown>
#13 0x55ccd2a7313f <unknown>
#14 0x55ccd2acf4b8 <unknown>
#15 0x55ccd2acf693 <unknown>
#16 0x55ccd2ae1613 <unknown>
#17 0x7fce5ce9caa4 <unknown>
#18 0x7fce5cf29c6c <unknown>
- Generated html report: file:///home/runner/work/Mocha_accounting/Mocha_accounting/C%3A%5CUsers%5CTaurus13%5CPycharmProjects%5CPythonProject%5Creports/20251016_151333/report.html -
============================= 15 errors in 19.71s ==============================
=== LOGIN TESTS COMPLETED ===
Exit Code: 1
