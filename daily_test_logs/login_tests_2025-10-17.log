=== LOGIN TESTS STARTED: 2025-10-17 03:48:07 ===
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.3.5, pluggy-1.6.0 -- /opt/hostedtoolcache/Python/3.13.7/x64/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.11.0-1018-azure-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.6.0'}, 'Plugins': {'html': '4.1.1', 'rerunfailures': '16.1', 'Faker': '37.11.0', 'xdist': '3.8.0', 'metadata': '3.1.1'}, 'CI': 'true', 'JAVA_HOME': '/usr/lib/jvm/temurin-17-jdk-amd64'}
rootdir: /home/runner/work/Mocha_accounting/Mocha_accounting
plugins: html-4.1.1, rerunfailures-16.1, Faker-37.11.0, xdist-3.8.0, metadata-3.1.1
collecting ... collected 15 items

tests/test_signup_login/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] ERROR [  6%]
tests/test_signup_login/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] ERROR [ 13%]
tests/test_signup_login/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ERROR [ 20%]
tests/test_signup_login/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] ERROR [ 26%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username0] ERROR [ 33%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username1] ERROR [ 40%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username2] ERROR [ 46%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username3] ERROR [ 53%]
tests/test_signup_login/test_login.py::test_blank_username_validation ERROR [ 60%]
tests/test_signup_login/test_login.py::test_blank_password_validation ERROR [ 66%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username0] ERROR [ 73%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username1] ERROR [ 80%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username2] ERROR [ 86%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username3] ERROR [ 93%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username4] ERROR [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d44d70>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d44ec0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d44d70>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d44ec0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8d45400>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d44d70>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f8d45160>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55c1704d4613 \\u003Cunknown>\\n#17 0x7f831549caa4 \\u003Cunknown>\\n#18 0x7f8315529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55c1704d567a <unknown>
E       #1 0x55c16ff54566 <unknown>
E       #2 0x55c16ff8fb4c <unknown>
E       #3 0x55c16ff8b7c4 <unknown>
E       #4 0x55c16ffdabd3 <unknown>
E       #5 0x55c16ffda286 <unknown>
E       #6 0x55c16ffcc403 <unknown>
E       #7 0x55c16ff98b02 <unknown>
E       #8 0x55c16ff997c1 <unknown>
E       #9 0x55c170499448 <unknown>
E       #10 0x55c17049d2af <unknown>
E       #11 0x55c1704808d9 <unknown>
E       #12 0x55c17049de55 <unknown>
E       #13 0x55c17046613f <unknown>
E       #14 0x55c1704c24b8 <unknown>
E       #15 0x55c1704c2693 <unknown>
E       #16 0x55c1704d4613 <unknown>
E       #17 0x7f831549caa4 <unknown>
E       #18 0x7f8315529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55c1704d567a <unknown>
E           #1 0x55c16ff54566 <unknown>
E           #2 0x55c16ff8fb4c <unknown>
E           #3 0x55c16ff8b7c4 <unknown>
E           #4 0x55c16ffdabd3 <unknown>
E           #5 0x55c16ffda286 <unknown>
E           #6 0x55c16ffcc403 <unknown>
E           #7 0x55c16ff98b02 <unknown>
E           #8 0x55c16ff997c1 <unknown>
E           #9 0x55c170499448 <unknown>
E           #10 0x55c17049d2af <unknown>
E           #11 0x55c1704808d9 <unknown>
E           #12 0x55c17049de55 <unknown>
E           #13 0x55c17046613f <unknown>
E           #14 0x55c1704c24b8 <unknown>
E           #15 0x55c1704c2693 <unknown>
E           #16 0x55c1704d4613 <unknown>
E           #17 0x7f831549caa4 <unknown>
E           #18 0x7f8315529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:08,671 - INFO - Starting test with Chrome browser
2025-10-17 03:48:08,671 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:08,737 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:08,772 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:08,806 - INFO - There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
2025-10-17 03:48:08,806 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:08,904 - INFO - WebDriver version 141.0.7390.78 selected
2025-10-17 03:48:08,908 - INFO - Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-17 03:48:08,909 - INFO - About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-17 03:48:08,944 - INFO - Driver downloading response is 200
2025-10-17 03:48:08,995 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:09,140 - INFO - Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
2025-10-17 03:48:10,253 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55c1704d567a <unknown>
#1 0x55c16ff54566 <unknown>
#2 0x55c16ff8fb4c <unknown>
#3 0x55c16ff8b7c4 <unknown>
#4 0x55c16ffdabd3 <unknown>
#5 0x55c16ffda286 <unknown>
#6 0x55c16ffcc403 <unknown>
#7 0x55c16ff98b02 <unknown>
#8 0x55c16ff997c1 <unknown>
#9 0x55c170499448 <unknown>
#10 0x55c17049d2af <unknown>
#11 0x55c1704808d9 <unknown>
#12 0x55c17049de55 <unknown>
#13 0x55c17046613f <unknown>
#14 0x55c1704c24b8 <unknown>
#15 0x55c1704c2693 <unknown>
#16 0x55c1704d4613 <unknown>
#17 0x7f831549caa4 <unknown>
#18 0x7f8315529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 WebDriver version 141.0.7390.78 selected
INFO     WDM:logger.py:11 Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 Driver downloading response is 200
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55c1704d567a <unknown>
#1 0x55c16ff54566 <unknown>
#2 0x55c16ff8fb4c <unknown>
#3 0x55c16ff8b7c4 <unknown>
#4 0x55c16ffdabd3 <unknown>
#5 0x55c16ffda286 <unknown>
#6 0x55c16ffcc403 <unknown>
#7 0x55c16ff98b02 <unknown>
#8 0x55c16ff997c1 <unknown>
#9 0x55c170499448 <unknown>
#10 0x55c17049d2af <unknown>
#11 0x55c1704808d9 <unknown>
#12 0x55c17049de55 <unknown>
#13 0x55c17046613f <unknown>
#14 0x55c1704c24b8 <unknown>
#15 0x55c1704c2693 <unknown>
#16 0x55c1704d4613 <unknown>
#17 0x7f831549caa4 <unknown>
#18 0x7f8315529c6c <unknown>
____ ERROR at setup of test_valid_login[samatakamble9@gmail.com-Samata@16] _____

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d6a710>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d6ac10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d6a710>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d6ac10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8d6afd0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d6a710>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f8d6ae90>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x56306807f613 \\u003Cunknown>\\n#17 0x7f4abba9caa4 \\u003Cunknown>\\n#18 0x7f4abbb29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x56306808067a <unknown>
E       #1 0x563067aff566 <unknown>
E       #2 0x563067b3ab4c <unknown>
E       #3 0x563067b367c4 <unknown>
E       #4 0x563067b85bd3 <unknown>
E       #5 0x563067b85286 <unknown>
E       #6 0x563067b77403 <unknown>
E       #7 0x563067b43b02 <unknown>
E       #8 0x563067b447c1 <unknown>
E       #9 0x563068044448 <unknown>
E       #10 0x5630680482af <unknown>
E       #11 0x56306802b8d9 <unknown>
E       #12 0x563068048e55 <unknown>
E       #13 0x56306801113f <unknown>
E       #14 0x56306806d4b8 <unknown>
E       #15 0x56306806d693 <unknown>
E       #16 0x56306807f613 <unknown>
E       #17 0x7f4abba9caa4 <unknown>
E       #18 0x7f4abbb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x56306808067a <unknown>
E           #1 0x563067aff566 <unknown>
E           #2 0x563067b3ab4c <unknown>
E           #3 0x563067b367c4 <unknown>
E           #4 0x563067b85bd3 <unknown>
E           #5 0x563067b85286 <unknown>
E           #6 0x563067b77403 <unknown>
E           #7 0x563067b43b02 <unknown>
E           #8 0x563067b447c1 <unknown>
E           #9 0x563068044448 <unknown>
E           #10 0x5630680482af <unknown>
E           #11 0x56306802b8d9 <unknown>
E           #12 0x563068048e55 <unknown>
E           #13 0x56306801113f <unknown>
E           #14 0x56306806d4b8 <unknown>
E           #15 0x56306806d693 <unknown>
E           #16 0x56306807f613 <unknown>
E           #17 0x7f4abba9caa4 <unknown>
E           #18 0x7f4abbb29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:10,321 - INFO - Starting test with Chrome browser
2025-10-17 03:48:10,322 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:10,387 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:10,421 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:10,470 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:11,557 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x56306808067a <unknown>
#1 0x563067aff566 <unknown>
#2 0x563067b3ab4c <unknown>
#3 0x563067b367c4 <unknown>
#4 0x563067b85bd3 <unknown>
#5 0x563067b85286 <unknown>
#6 0x563067b77403 <unknown>
#7 0x563067b43b02 <unknown>
#8 0x563067b447c1 <unknown>
#9 0x563068044448 <unknown>
#10 0x5630680482af <unknown>
#11 0x56306802b8d9 <unknown>
#12 0x563068048e55 <unknown>
#13 0x56306801113f <unknown>
#14 0x56306806d4b8 <unknown>
#15 0x56306806d693 <unknown>
#16 0x56306807f613 <unknown>
#17 0x7f4abba9caa4 <unknown>
#18 0x7f4abbb29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x56306808067a <unknown>
#1 0x563067aff566 <unknown>
#2 0x563067b3ab4c <unknown>
#3 0x563067b367c4 <unknown>
#4 0x563067b85bd3 <unknown>
#5 0x563067b85286 <unknown>
#6 0x563067b77403 <unknown>
#7 0x563067b43b02 <unknown>
#8 0x563067b447c1 <unknown>
#9 0x563068044448 <unknown>
#10 0x5630680482af <unknown>
#11 0x56306802b8d9 <unknown>
#12 0x563068048e55 <unknown>
#13 0x56306801113f <unknown>
#14 0x56306806d4b8 <unknown>
#15 0x56306806d693 <unknown>
#16 0x56306807f613 <unknown>
#17 0x7f4abba9caa4 <unknown>
#18 0x7f4abbb29c6c <unknown>
__ ERROR at setup of test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ___

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d6aad0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d68e10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d6aad0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d68e10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8d69310>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d6aad0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f9614910>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x560ce8f53613 \\u003Cunknown>\\n#17 0x7ff67609caa4 \\u003Cunknown>\\n#18 0x7ff676129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x560ce8f5467a <unknown>
E       #1 0x560ce89d3566 <unknown>
E       #2 0x560ce8a0eb4c <unknown>
E       #3 0x560ce8a0a7c4 <unknown>
E       #4 0x560ce8a59bd3 <unknown>
E       #5 0x560ce8a59286 <unknown>
E       #6 0x560ce8a4b403 <unknown>
E       #7 0x560ce8a17b02 <unknown>
E       #8 0x560ce8a187c1 <unknown>
E       #9 0x560ce8f18448 <unknown>
E       #10 0x560ce8f1c2af <unknown>
E       #11 0x560ce8eff8d9 <unknown>
E       #12 0x560ce8f1ce55 <unknown>
E       #13 0x560ce8ee513f <unknown>
E       #14 0x560ce8f414b8 <unknown>
E       #15 0x560ce8f41693 <unknown>
E       #16 0x560ce8f53613 <unknown>
E       #17 0x7ff67609caa4 <unknown>
E       #18 0x7ff676129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x560ce8f5467a <unknown>
E           #1 0x560ce89d3566 <unknown>
E           #2 0x560ce8a0eb4c <unknown>
E           #3 0x560ce8a0a7c4 <unknown>
E           #4 0x560ce8a59bd3 <unknown>
E           #5 0x560ce8a59286 <unknown>
E           #6 0x560ce8a4b403 <unknown>
E           #7 0x560ce8a17b02 <unknown>
E           #8 0x560ce8a187c1 <unknown>
E           #9 0x560ce8f18448 <unknown>
E           #10 0x560ce8f1c2af <unknown>
E           #11 0x560ce8eff8d9 <unknown>
E           #12 0x560ce8f1ce55 <unknown>
E           #13 0x560ce8ee513f <unknown>
E           #14 0x560ce8f414b8 <unknown>
E           #15 0x560ce8f41693 <unknown>
E           #16 0x560ce8f53613 <unknown>
E           #17 0x7ff67609caa4 <unknown>
E           #18 0x7ff676129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:11,599 - INFO - Starting test with Chrome browser
2025-10-17 03:48:11,599 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:11,664 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:11,698 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:11,730 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:12,817 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x560ce8f5467a <unknown>
#1 0x560ce89d3566 <unknown>
#2 0x560ce8a0eb4c <unknown>
#3 0x560ce8a0a7c4 <unknown>
#4 0x560ce8a59bd3 <unknown>
#5 0x560ce8a59286 <unknown>
#6 0x560ce8a4b403 <unknown>
#7 0x560ce8a17b02 <unknown>
#8 0x560ce8a187c1 <unknown>
#9 0x560ce8f18448 <unknown>
#10 0x560ce8f1c2af <unknown>
#11 0x560ce8eff8d9 <unknown>
#12 0x560ce8f1ce55 <unknown>
#13 0x560ce8ee513f <unknown>
#14 0x560ce8f414b8 <unknown>
#15 0x560ce8f41693 <unknown>
#16 0x560ce8f53613 <unknown>
#17 0x7ff67609caa4 <unknown>
#18 0x7ff676129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x560ce8f5467a <unknown>
#1 0x560ce89d3566 <unknown>
#2 0x560ce8a0eb4c <unknown>
#3 0x560ce8a0a7c4 <unknown>
#4 0x560ce8a59bd3 <unknown>
#5 0x560ce8a59286 <unknown>
#6 0x560ce8a4b403 <unknown>
#7 0x560ce8a17b02 <unknown>
#8 0x560ce8a187c1 <unknown>
#9 0x560ce8f18448 <unknown>
#10 0x560ce8f1c2af <unknown>
#11 0x560ce8eff8d9 <unknown>
#12 0x560ce8f1ce55 <unknown>
#13 0x560ce8ee513f <unknown>
#14 0x560ce8f414b8 <unknown>
#15 0x560ce8f41693 <unknown>
#16 0x560ce8f53613 <unknown>
#17 0x7ff67609caa4 <unknown>
#18 0x7ff676129c6c <unknown>
_ ERROR at setup of test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d3ab10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d3ac40>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d3ab10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d3ac40>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8d3b100>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d3ab10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f8d3afd0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5618c9edf613 \\u003Cunknown>\\n#17 0x7feabda9caa4 \\u003Cunknown>\\n#18 0x7feabdb29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5618c9ee067a <unknown>
E       #1 0x5618c995f566 <unknown>
E       #2 0x5618c999ab4c <unknown>
E       #3 0x5618c99967c4 <unknown>
E       #4 0x5618c99e5bd3 <unknown>
E       #5 0x5618c99e5286 <unknown>
E       #6 0x5618c99d7403 <unknown>
E       #7 0x5618c99a3b02 <unknown>
E       #8 0x5618c99a47c1 <unknown>
E       #9 0x5618c9ea4448 <unknown>
E       #10 0x5618c9ea82af <unknown>
E       #11 0x5618c9e8b8d9 <unknown>
E       #12 0x5618c9ea8e55 <unknown>
E       #13 0x5618c9e7113f <unknown>
E       #14 0x5618c9ecd4b8 <unknown>
E       #15 0x5618c9ecd693 <unknown>
E       #16 0x5618c9edf613 <unknown>
E       #17 0x7feabda9caa4 <unknown>
E       #18 0x7feabdb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5618c9ee067a <unknown>
E           #1 0x5618c995f566 <unknown>
E           #2 0x5618c999ab4c <unknown>
E           #3 0x5618c99967c4 <unknown>
E           #4 0x5618c99e5bd3 <unknown>
E           #5 0x5618c99e5286 <unknown>
E           #6 0x5618c99d7403 <unknown>
E           #7 0x5618c99a3b02 <unknown>
E           #8 0x5618c99a47c1 <unknown>
E           #9 0x5618c9ea4448 <unknown>
E           #10 0x5618c9ea82af <unknown>
E           #11 0x5618c9e8b8d9 <unknown>
E           #12 0x5618c9ea8e55 <unknown>
E           #13 0x5618c9e7113f <unknown>
E           #14 0x5618c9ecd4b8 <unknown>
E           #15 0x5618c9ecd693 <unknown>
E           #16 0x5618c9edf613 <unknown>
E           #17 0x7feabda9caa4 <unknown>
E           #18 0x7feabdb29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:12,857 - INFO - Starting test with Chrome browser
2025-10-17 03:48:12,857 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:12,923 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:12,967 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:12,999 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:14,087 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5618c9ee067a <unknown>
#1 0x5618c995f566 <unknown>
#2 0x5618c999ab4c <unknown>
#3 0x5618c99967c4 <unknown>
#4 0x5618c99e5bd3 <unknown>
#5 0x5618c99e5286 <unknown>
#6 0x5618c99d7403 <unknown>
#7 0x5618c99a3b02 <unknown>
#8 0x5618c99a47c1 <unknown>
#9 0x5618c9ea4448 <unknown>
#10 0x5618c9ea82af <unknown>
#11 0x5618c9e8b8d9 <unknown>
#12 0x5618c9ea8e55 <unknown>
#13 0x5618c9e7113f <unknown>
#14 0x5618c9ecd4b8 <unknown>
#15 0x5618c9ecd693 <unknown>
#16 0x5618c9edf613 <unknown>
#17 0x7feabda9caa4 <unknown>
#18 0x7feabdb29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5618c9ee067a <unknown>
#1 0x5618c995f566 <unknown>
#2 0x5618c999ab4c <unknown>
#3 0x5618c99967c4 <unknown>
#4 0x5618c99e5bd3 <unknown>
#5 0x5618c99e5286 <unknown>
#6 0x5618c99d7403 <unknown>
#7 0x5618c99a3b02 <unknown>
#8 0x5618c99a47c1 <unknown>
#9 0x5618c9ea4448 <unknown>
#10 0x5618c9ea82af <unknown>
#11 0x5618c9e8b8d9 <unknown>
#12 0x5618c9ea8e55 <unknown>
#13 0x5618c9e7113f <unknown>
#14 0x5618c9ecd4b8 <unknown>
#15 0x5618c9ecd693 <unknown>
#16 0x5618c9edf613 <unknown>
#17 0x7feabda9caa4 <unknown>
#18 0x7feabdb29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username0] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d3b950>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f96a02b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d3b950>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f96a02b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f96a0510>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d3b950>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f96a03e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5620aa430613 \\u003Cunknown>\\n#17 0x7f917129caa4 \\u003Cunknown>\\n#18 0x7f9171329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5620aa43167a <unknown>
E       #1 0x5620a9eb0566 <unknown>
E       #2 0x5620a9eebb4c <unknown>
E       #3 0x5620a9ee77c4 <unknown>
E       #4 0x5620a9f36bd3 <unknown>
E       #5 0x5620a9f36286 <unknown>
E       #6 0x5620a9f28403 <unknown>
E       #7 0x5620a9ef4b02 <unknown>
E       #8 0x5620a9ef57c1 <unknown>
E       #9 0x5620aa3f5448 <unknown>
E       #10 0x5620aa3f92af <unknown>
E       #11 0x5620aa3dc8d9 <unknown>
E       #12 0x5620aa3f9e55 <unknown>
E       #13 0x5620aa3c213f <unknown>
E       #14 0x5620aa41e4b8 <unknown>
E       #15 0x5620aa41e693 <unknown>
E       #16 0x5620aa430613 <unknown>
E       #17 0x7f917129caa4 <unknown>
E       #18 0x7f9171329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5620aa43167a <unknown>
E           #1 0x5620a9eb0566 <unknown>
E           #2 0x5620a9eebb4c <unknown>
E           #3 0x5620a9ee77c4 <unknown>
E           #4 0x5620a9f36bd3 <unknown>
E           #5 0x5620a9f36286 <unknown>
E           #6 0x5620a9f28403 <unknown>
E           #7 0x5620a9ef4b02 <unknown>
E           #8 0x5620a9ef57c1 <unknown>
E           #9 0x5620aa3f5448 <unknown>
E           #10 0x5620aa3f92af <unknown>
E           #11 0x5620aa3dc8d9 <unknown>
E           #12 0x5620aa3f9e55 <unknown>
E           #13 0x5620aa3c213f <unknown>
E           #14 0x5620aa41e4b8 <unknown>
E           #15 0x5620aa41e693 <unknown>
E           #16 0x5620aa430613 <unknown>
E           #17 0x7f917129caa4 <unknown>
E           #18 0x7f9171329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:14,127 - INFO - Starting test with Chrome browser
2025-10-17 03:48:14,127 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:14,191 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:14,226 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:14,258 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:15,346 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5620aa43167a <unknown>
#1 0x5620a9eb0566 <unknown>
#2 0x5620a9eebb4c <unknown>
#3 0x5620a9ee77c4 <unknown>
#4 0x5620a9f36bd3 <unknown>
#5 0x5620a9f36286 <unknown>
#6 0x5620a9f28403 <unknown>
#7 0x5620a9ef4b02 <unknown>
#8 0x5620a9ef57c1 <unknown>
#9 0x5620aa3f5448 <unknown>
#10 0x5620aa3f92af <unknown>
#11 0x5620aa3dc8d9 <unknown>
#12 0x5620aa3f9e55 <unknown>
#13 0x5620aa3c213f <unknown>
#14 0x5620aa41e4b8 <unknown>
#15 0x5620aa41e693 <unknown>
#16 0x5620aa430613 <unknown>
#17 0x7f917129caa4 <unknown>
#18 0x7f9171329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5620aa43167a <unknown>
#1 0x5620a9eb0566 <unknown>
#2 0x5620a9eebb4c <unknown>
#3 0x5620a9ee77c4 <unknown>
#4 0x5620a9f36bd3 <unknown>
#5 0x5620a9f36286 <unknown>
#6 0x5620a9f28403 <unknown>
#7 0x5620a9ef4b02 <unknown>
#8 0x5620a9ef57c1 <unknown>
#9 0x5620aa3f5448 <unknown>
#10 0x5620aa3f92af <unknown>
#11 0x5620aa3dc8d9 <unknown>
#12 0x5620aa3f9e55 <unknown>
#13 0x5620aa3c213f <unknown>
#14 0x5620aa41e4b8 <unknown>
#15 0x5620aa41e693 <unknown>
#16 0x5620aa430613 <unknown>
#17 0x7f917129caa4 <unknown>
#18 0x7f9171329c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username1] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d2eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f96303b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d2eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f96303b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f9630b90>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d2eb10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f9630a70>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x56390ffb7613 \\u003Cunknown>\\n#17 0x7fc82049caa4 \\u003Cunknown>\\n#18 0x7fc820529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x56390ffb867a <unknown>
E       #1 0x56390fa37566 <unknown>
E       #2 0x56390fa72b4c <unknown>
E       #3 0x56390fa6e7c4 <unknown>
E       #4 0x56390fabdbd3 <unknown>
E       #5 0x56390fabd286 <unknown>
E       #6 0x56390faaf403 <unknown>
E       #7 0x56390fa7bb02 <unknown>
E       #8 0x56390fa7c7c1 <unknown>
E       #9 0x56390ff7c448 <unknown>
E       #10 0x56390ff802af <unknown>
E       #11 0x56390ff638d9 <unknown>
E       #12 0x56390ff80e55 <unknown>
E       #13 0x56390ff4913f <unknown>
E       #14 0x56390ffa54b8 <unknown>
E       #15 0x56390ffa5693 <unknown>
E       #16 0x56390ffb7613 <unknown>
E       #17 0x7fc82049caa4 <unknown>
E       #18 0x7fc820529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x56390ffb867a <unknown>
E           #1 0x56390fa37566 <unknown>
E           #2 0x56390fa72b4c <unknown>
E           #3 0x56390fa6e7c4 <unknown>
E           #4 0x56390fabdbd3 <unknown>
E           #5 0x56390fabd286 <unknown>
E           #6 0x56390faaf403 <unknown>
E           #7 0x56390fa7bb02 <unknown>
E           #8 0x56390fa7c7c1 <unknown>
E           #9 0x56390ff7c448 <unknown>
E           #10 0x56390ff802af <unknown>
E           #11 0x56390ff638d9 <unknown>
E           #12 0x56390ff80e55 <unknown>
E           #13 0x56390ff4913f <unknown>
E           #14 0x56390ffa54b8 <unknown>
E           #15 0x56390ffa5693 <unknown>
E           #16 0x56390ffb7613 <unknown>
E           #17 0x7fc82049caa4 <unknown>
E           #18 0x7fc820529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:15,386 - INFO - Starting test with Chrome browser
2025-10-17 03:48:15,386 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:15,452 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:15,487 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:15,520 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:16,608 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x56390ffb867a <unknown>
#1 0x56390fa37566 <unknown>
#2 0x56390fa72b4c <unknown>
#3 0x56390fa6e7c4 <unknown>
#4 0x56390fabdbd3 <unknown>
#5 0x56390fabd286 <unknown>
#6 0x56390faaf403 <unknown>
#7 0x56390fa7bb02 <unknown>
#8 0x56390fa7c7c1 <unknown>
#9 0x56390ff7c448 <unknown>
#10 0x56390ff802af <unknown>
#11 0x56390ff638d9 <unknown>
#12 0x56390ff80e55 <unknown>
#13 0x56390ff4913f <unknown>
#14 0x56390ffa54b8 <unknown>
#15 0x56390ffa5693 <unknown>
#16 0x56390ffb7613 <unknown>
#17 0x7fc82049caa4 <unknown>
#18 0x7fc820529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x56390ffb867a <unknown>
#1 0x56390fa37566 <unknown>
#2 0x56390fa72b4c <unknown>
#3 0x56390fa6e7c4 <unknown>
#4 0x56390fabdbd3 <unknown>
#5 0x56390fabd286 <unknown>
#6 0x56390faaf403 <unknown>
#7 0x56390fa7bb02 <unknown>
#8 0x56390fa7c7c1 <unknown>
#9 0x56390ff7c448 <unknown>
#10 0x56390ff802af <unknown>
#11 0x56390ff638d9 <unknown>
#12 0x56390ff80e55 <unknown>
#13 0x56390ff4913f <unknown>
#14 0x56390ffa54b8 <unknown>
#15 0x56390ffa5693 <unknown>
#16 0x56390ffb7613 <unknown>
#17 0x7fc82049caa4 <unknown>
#18 0x7fc820529c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username2] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d7b8a0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d7b9b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d7b8a0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d7b9b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8d7aad0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d7b8a0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f8d7abe0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x56147714f613 \\u003Cunknown>\\n#17 0x7f996de9caa4 \\u003Cunknown>\\n#18 0x7f996df29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x56147715067a <unknown>
E       #1 0x561476bcf566 <unknown>
E       #2 0x561476c0ab4c <unknown>
E       #3 0x561476c067c4 <unknown>
E       #4 0x561476c55bd3 <unknown>
E       #5 0x561476c55286 <unknown>
E       #6 0x561476c47403 <unknown>
E       #7 0x561476c13b02 <unknown>
E       #8 0x561476c147c1 <unknown>
E       #9 0x561477114448 <unknown>
E       #10 0x5614771182af <unknown>
E       #11 0x5614770fb8d9 <unknown>
E       #12 0x561477118e55 <unknown>
E       #13 0x5614770e113f <unknown>
E       #14 0x56147713d4b8 <unknown>
E       #15 0x56147713d693 <unknown>
E       #16 0x56147714f613 <unknown>
E       #17 0x7f996de9caa4 <unknown>
E       #18 0x7f996df29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x56147715067a <unknown>
E           #1 0x561476bcf566 <unknown>
E           #2 0x561476c0ab4c <unknown>
E           #3 0x561476c067c4 <unknown>
E           #4 0x561476c55bd3 <unknown>
E           #5 0x561476c55286 <unknown>
E           #6 0x561476c47403 <unknown>
E           #7 0x561476c13b02 <unknown>
E           #8 0x561476c147c1 <unknown>
E           #9 0x561477114448 <unknown>
E           #10 0x5614771182af <unknown>
E           #11 0x5614770fb8d9 <unknown>
E           #12 0x561477118e55 <unknown>
E           #13 0x5614770e113f <unknown>
E           #14 0x56147713d4b8 <unknown>
E           #15 0x56147713d693 <unknown>
E           #16 0x56147714f613 <unknown>
E           #17 0x7f996de9caa4 <unknown>
E           #18 0x7f996df29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:16,649 - INFO - Starting test with Chrome browser
2025-10-17 03:48:16,649 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:16,715 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:16,765 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:16,797 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:17,886 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x56147715067a <unknown>
#1 0x561476bcf566 <unknown>
#2 0x561476c0ab4c <unknown>
#3 0x561476c067c4 <unknown>
#4 0x561476c55bd3 <unknown>
#5 0x561476c55286 <unknown>
#6 0x561476c47403 <unknown>
#7 0x561476c13b02 <unknown>
#8 0x561476c147c1 <unknown>
#9 0x561477114448 <unknown>
#10 0x5614771182af <unknown>
#11 0x5614770fb8d9 <unknown>
#12 0x561477118e55 <unknown>
#13 0x5614770e113f <unknown>
#14 0x56147713d4b8 <unknown>
#15 0x56147713d693 <unknown>
#16 0x56147714f613 <unknown>
#17 0x7f996de9caa4 <unknown>
#18 0x7f996df29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x56147715067a <unknown>
#1 0x561476bcf566 <unknown>
#2 0x561476c0ab4c <unknown>
#3 0x561476c067c4 <unknown>
#4 0x561476c55bd3 <unknown>
#5 0x561476c55286 <unknown>
#6 0x561476c47403 <unknown>
#7 0x561476c13b02 <unknown>
#8 0x561476c147c1 <unknown>
#9 0x561477114448 <unknown>
#10 0x5614771182af <unknown>
#11 0x5614770fb8d9 <unknown>
#12 0x561477118e55 <unknown>
#13 0x5614770e113f <unknown>
#14 0x56147713d4b8 <unknown>
#15 0x56147713d693 <unknown>
#16 0x56147714f613 <unknown>
#17 0x7f996de9caa4 <unknown>
#18 0x7f996df29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username3] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d78d10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f82d0c00>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d78d10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f82d0c00>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f82d08d0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d78d10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f82d09e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x562f697c4613 \\u003Cunknown>\\n#17 0x7f90a7c9caa4 \\u003Cunknown>\\n#18 0x7f90a7d29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x562f697c567a <unknown>
E       #1 0x562f69244566 <unknown>
E       #2 0x562f6927fb4c <unknown>
E       #3 0x562f6927b7c4 <unknown>
E       #4 0x562f692cabd3 <unknown>
E       #5 0x562f692ca286 <unknown>
E       #6 0x562f692bc403 <unknown>
E       #7 0x562f69288b02 <unknown>
E       #8 0x562f692897c1 <unknown>
E       #9 0x562f69789448 <unknown>
E       #10 0x562f6978d2af <unknown>
E       #11 0x562f697708d9 <unknown>
E       #12 0x562f6978de55 <unknown>
E       #13 0x562f6975613f <unknown>
E       #14 0x562f697b24b8 <unknown>
E       #15 0x562f697b2693 <unknown>
E       #16 0x562f697c4613 <unknown>
E       #17 0x7f90a7c9caa4 <unknown>
E       #18 0x7f90a7d29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x562f697c567a <unknown>
E           #1 0x562f69244566 <unknown>
E           #2 0x562f6927fb4c <unknown>
E           #3 0x562f6927b7c4 <unknown>
E           #4 0x562f692cabd3 <unknown>
E           #5 0x562f692ca286 <unknown>
E           #6 0x562f692bc403 <unknown>
E           #7 0x562f69288b02 <unknown>
E           #8 0x562f692897c1 <unknown>
E           #9 0x562f69789448 <unknown>
E           #10 0x562f6978d2af <unknown>
E           #11 0x562f697708d9 <unknown>
E           #12 0x562f6978de55 <unknown>
E           #13 0x562f6975613f <unknown>
E           #14 0x562f697b24b8 <unknown>
E           #15 0x562f697b2693 <unknown>
E           #16 0x562f697c4613 <unknown>
E           #17 0x7f90a7c9caa4 <unknown>
E           #18 0x7f90a7d29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:17,926 - INFO - Starting test with Chrome browser
2025-10-17 03:48:17,926 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:17,990 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:18,025 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:18,057 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:19,145 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x562f697c567a <unknown>
#1 0x562f69244566 <unknown>
#2 0x562f6927fb4c <unknown>
#3 0x562f6927b7c4 <unknown>
#4 0x562f692cabd3 <unknown>
#5 0x562f692ca286 <unknown>
#6 0x562f692bc403 <unknown>
#7 0x562f69288b02 <unknown>
#8 0x562f692897c1 <unknown>
#9 0x562f69789448 <unknown>
#10 0x562f6978d2af <unknown>
#11 0x562f697708d9 <unknown>
#12 0x562f6978de55 <unknown>
#13 0x562f6975613f <unknown>
#14 0x562f697b24b8 <unknown>
#15 0x562f697b2693 <unknown>
#16 0x562f697c4613 <unknown>
#17 0x7f90a7c9caa4 <unknown>
#18 0x7f90a7d29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x562f697c567a <unknown>
#1 0x562f69244566 <unknown>
#2 0x562f6927fb4c <unknown>
#3 0x562f6927b7c4 <unknown>
#4 0x562f692cabd3 <unknown>
#5 0x562f692ca286 <unknown>
#6 0x562f692bc403 <unknown>
#7 0x562f69288b02 <unknown>
#8 0x562f692897c1 <unknown>
#9 0x562f69789448 <unknown>
#10 0x562f6978d2af <unknown>
#11 0x562f697708d9 <unknown>
#12 0x562f6978de55 <unknown>
#13 0x562f6975613f <unknown>
#14 0x562f697b24b8 <unknown>
#15 0x562f697b2693 <unknown>
#16 0x562f697c4613 <unknown>
#17 0x7f90a7c9caa4 <unknown>
#18 0x7f90a7d29c6c <unknown>
_______________ ERROR at setup of test_blank_username_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9650450>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f9650550>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9650450>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f9650550>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f9650050>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9650450>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f9650750>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x556c529aa613 \\u003Cunknown>\\n#17 0x7f8da469caa4 \\u003Cunknown>\\n#18 0x7f8da4729c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x556c529ab67a <unknown>
E       #1 0x556c5242a566 <unknown>
E       #2 0x556c52465b4c <unknown>
E       #3 0x556c524617c4 <unknown>
E       #4 0x556c524b0bd3 <unknown>
E       #5 0x556c524b0286 <unknown>
E       #6 0x556c524a2403 <unknown>
E       #7 0x556c5246eb02 <unknown>
E       #8 0x556c5246f7c1 <unknown>
E       #9 0x556c5296f448 <unknown>
E       #10 0x556c529732af <unknown>
E       #11 0x556c529568d9 <unknown>
E       #12 0x556c52973e55 <unknown>
E       #13 0x556c5293c13f <unknown>
E       #14 0x556c529984b8 <unknown>
E       #15 0x556c52998693 <unknown>
E       #16 0x556c529aa613 <unknown>
E       #17 0x7f8da469caa4 <unknown>
E       #18 0x7f8da4729c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x556c529ab67a <unknown>
E           #1 0x556c5242a566 <unknown>
E           #2 0x556c52465b4c <unknown>
E           #3 0x556c524617c4 <unknown>
E           #4 0x556c524b0bd3 <unknown>
E           #5 0x556c524b0286 <unknown>
E           #6 0x556c524a2403 <unknown>
E           #7 0x556c5246eb02 <unknown>
E           #8 0x556c5246f7c1 <unknown>
E           #9 0x556c5296f448 <unknown>
E           #10 0x556c529732af <unknown>
E           #11 0x556c529568d9 <unknown>
E           #12 0x556c52973e55 <unknown>
E           #13 0x556c5293c13f <unknown>
E           #14 0x556c529984b8 <unknown>
E           #15 0x556c52998693 <unknown>
E           #16 0x556c529aa613 <unknown>
E           #17 0x7f8da469caa4 <unknown>
E           #18 0x7f8da4729c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:19,186 - INFO - Starting test with Chrome browser
2025-10-17 03:48:19,186 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:19,252 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:19,285 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:19,317 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:20,405 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x556c529ab67a <unknown>
#1 0x556c5242a566 <unknown>
#2 0x556c52465b4c <unknown>
#3 0x556c524617c4 <unknown>
#4 0x556c524b0bd3 <unknown>
#5 0x556c524b0286 <unknown>
#6 0x556c524a2403 <unknown>
#7 0x556c5246eb02 <unknown>
#8 0x556c5246f7c1 <unknown>
#9 0x556c5296f448 <unknown>
#10 0x556c529732af <unknown>
#11 0x556c529568d9 <unknown>
#12 0x556c52973e55 <unknown>
#13 0x556c5293c13f <unknown>
#14 0x556c529984b8 <unknown>
#15 0x556c52998693 <unknown>
#16 0x556c529aa613 <unknown>
#17 0x7f8da469caa4 <unknown>
#18 0x7f8da4729c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x556c529ab67a <unknown>
#1 0x556c5242a566 <unknown>
#2 0x556c52465b4c <unknown>
#3 0x556c524617c4 <unknown>
#4 0x556c524b0bd3 <unknown>
#5 0x556c524b0286 <unknown>
#6 0x556c524a2403 <unknown>
#7 0x556c5246eb02 <unknown>
#8 0x556c5246f7c1 <unknown>
#9 0x556c5296f448 <unknown>
#10 0x556c529732af <unknown>
#11 0x556c529568d9 <unknown>
#12 0x556c52973e55 <unknown>
#13 0x556c5293c13f <unknown>
#14 0x556c529984b8 <unknown>
#15 0x556c52998693 <unknown>
#16 0x556c529aa613 <unknown>
#17 0x7f8da469caa4 <unknown>
#18 0x7f8da4729c6c <unknown>
_______________ ERROR at setup of test_blank_password_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9652550>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f9652850>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9652550>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f9652850>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f9652d50>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9652550>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f9652c50>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5555dab3d613 \\u003Cunknown>\\n#17 0x7fca5ec9caa4 \\u003Cunknown>\\n#18 0x7fca5ed29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5555dab3e67a <unknown>
E       #1 0x5555da5bd566 <unknown>
E       #2 0x5555da5f8b4c <unknown>
E       #3 0x5555da5f47c4 <unknown>
E       #4 0x5555da643bd3 <unknown>
E       #5 0x5555da643286 <unknown>
E       #6 0x5555da635403 <unknown>
E       #7 0x5555da601b02 <unknown>
E       #8 0x5555da6027c1 <unknown>
E       #9 0x5555dab02448 <unknown>
E       #10 0x5555dab062af <unknown>
E       #11 0x5555daae98d9 <unknown>
E       #12 0x5555dab06e55 <unknown>
E       #13 0x5555daacf13f <unknown>
E       #14 0x5555dab2b4b8 <unknown>
E       #15 0x5555dab2b693 <unknown>
E       #16 0x5555dab3d613 <unknown>
E       #17 0x7fca5ec9caa4 <unknown>
E       #18 0x7fca5ed29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5555dab3e67a <unknown>
E           #1 0x5555da5bd566 <unknown>
E           #2 0x5555da5f8b4c <unknown>
E           #3 0x5555da5f47c4 <unknown>
E           #4 0x5555da643bd3 <unknown>
E           #5 0x5555da643286 <unknown>
E           #6 0x5555da635403 <unknown>
E           #7 0x5555da601b02 <unknown>
E           #8 0x5555da6027c1 <unknown>
E           #9 0x5555dab02448 <unknown>
E           #10 0x5555dab062af <unknown>
E           #11 0x5555daae98d9 <unknown>
E           #12 0x5555dab06e55 <unknown>
E           #13 0x5555daacf13f <unknown>
E           #14 0x5555dab2b4b8 <unknown>
E           #15 0x5555dab2b693 <unknown>
E           #16 0x5555dab3d613 <unknown>
E           #17 0x7fca5ec9caa4 <unknown>
E           #18 0x7fca5ed29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:20,445 - INFO - Starting test with Chrome browser
2025-10-17 03:48:20,445 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:20,512 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:20,550 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:20,582 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:21,670 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5555dab3e67a <unknown>
#1 0x5555da5bd566 <unknown>
#2 0x5555da5f8b4c <unknown>
#3 0x5555da5f47c4 <unknown>
#4 0x5555da643bd3 <unknown>
#5 0x5555da643286 <unknown>
#6 0x5555da635403 <unknown>
#7 0x5555da601b02 <unknown>
#8 0x5555da6027c1 <unknown>
#9 0x5555dab02448 <unknown>
#10 0x5555dab062af <unknown>
#11 0x5555daae98d9 <unknown>
#12 0x5555dab06e55 <unknown>
#13 0x5555daacf13f <unknown>
#14 0x5555dab2b4b8 <unknown>
#15 0x5555dab2b693 <unknown>
#16 0x5555dab3d613 <unknown>
#17 0x7fca5ec9caa4 <unknown>
#18 0x7fca5ed29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5555dab3e67a <unknown>
#1 0x5555da5bd566 <unknown>
#2 0x5555da5f8b4c <unknown>
#3 0x5555da5f47c4 <unknown>
#4 0x5555da643bd3 <unknown>
#5 0x5555da643286 <unknown>
#6 0x5555da635403 <unknown>
#7 0x5555da601b02 <unknown>
#8 0x5555da6027c1 <unknown>
#9 0x5555dab02448 <unknown>
#10 0x5555dab062af <unknown>
#11 0x5555daae98d9 <unknown>
#12 0x5555dab06e55 <unknown>
#13 0x5555daacf13f <unknown>
#14 0x5555dab2b4b8 <unknown>
#15 0x5555dab2b693 <unknown>
#16 0x5555dab3d613 <unknown>
#17 0x7fca5ec9caa4 <unknown>
#18 0x7fca5ed29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username0] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8db0140>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8db0230>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8db0140>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8db0230>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8db1c70>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8db0140>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f8db15e0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55632ef94613 \\u003Cunknown>\\n#17 0x7f8319c9caa4 \\u003Cunknown>\\n#18 0x7f8319d29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55632ef9567a <unknown>
E       #1 0x55632ea14566 <unknown>
E       #2 0x55632ea4fb4c <unknown>
E       #3 0x55632ea4b7c4 <unknown>
E       #4 0x55632ea9abd3 <unknown>
E       #5 0x55632ea9a286 <unknown>
E       #6 0x55632ea8c403 <unknown>
E       #7 0x55632ea58b02 <unknown>
E       #8 0x55632ea597c1 <unknown>
E       #9 0x55632ef59448 <unknown>
E       #10 0x55632ef5d2af <unknown>
E       #11 0x55632ef408d9 <unknown>
E       #12 0x55632ef5de55 <unknown>
E       #13 0x55632ef2613f <unknown>
E       #14 0x55632ef824b8 <unknown>
E       #15 0x55632ef82693 <unknown>
E       #16 0x55632ef94613 <unknown>
E       #17 0x7f8319c9caa4 <unknown>
E       #18 0x7f8319d29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55632ef9567a <unknown>
E           #1 0x55632ea14566 <unknown>
E           #2 0x55632ea4fb4c <unknown>
E           #3 0x55632ea4b7c4 <unknown>
E           #4 0x55632ea9abd3 <unknown>
E           #5 0x55632ea9a286 <unknown>
E           #6 0x55632ea8c403 <unknown>
E           #7 0x55632ea58b02 <unknown>
E           #8 0x55632ea597c1 <unknown>
E           #9 0x55632ef59448 <unknown>
E           #10 0x55632ef5d2af <unknown>
E           #11 0x55632ef408d9 <unknown>
E           #12 0x55632ef5de55 <unknown>
E           #13 0x55632ef2613f <unknown>
E           #14 0x55632ef824b8 <unknown>
E           #15 0x55632ef82693 <unknown>
E           #16 0x55632ef94613 <unknown>
E           #17 0x7f8319c9caa4 <unknown>
E           #18 0x7f8319d29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:21,712 - INFO - Starting test with Chrome browser
2025-10-17 03:48:21,712 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:21,776 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:21,810 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:21,843 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:22,930 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55632ef9567a <unknown>
#1 0x55632ea14566 <unknown>
#2 0x55632ea4fb4c <unknown>
#3 0x55632ea4b7c4 <unknown>
#4 0x55632ea9abd3 <unknown>
#5 0x55632ea9a286 <unknown>
#6 0x55632ea8c403 <unknown>
#7 0x55632ea58b02 <unknown>
#8 0x55632ea597c1 <unknown>
#9 0x55632ef59448 <unknown>
#10 0x55632ef5d2af <unknown>
#11 0x55632ef408d9 <unknown>
#12 0x55632ef5de55 <unknown>
#13 0x55632ef2613f <unknown>
#14 0x55632ef824b8 <unknown>
#15 0x55632ef82693 <unknown>
#16 0x55632ef94613 <unknown>
#17 0x7f8319c9caa4 <unknown>
#18 0x7f8319d29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55632ef9567a <unknown>
#1 0x55632ea14566 <unknown>
#2 0x55632ea4fb4c <unknown>
#3 0x55632ea4b7c4 <unknown>
#4 0x55632ea9abd3 <unknown>
#5 0x55632ea9a286 <unknown>
#6 0x55632ea8c403 <unknown>
#7 0x55632ea58b02 <unknown>
#8 0x55632ea597c1 <unknown>
#9 0x55632ef59448 <unknown>
#10 0x55632ef5d2af <unknown>
#11 0x55632ef408d9 <unknown>
#12 0x55632ef5de55 <unknown>
#13 0x55632ef2613f <unknown>
#14 0x55632ef824b8 <unknown>
#15 0x55632ef82693 <unknown>
#16 0x55632ef94613 <unknown>
#17 0x7f8319c9caa4 <unknown>
#18 0x7f8319d29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username1] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8db2030>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8db23f0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8db2030>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8db23f0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8db2300>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8db2030>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f9604050>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5560f90d3613 \\u003Cunknown>\\n#17 0x7f0b1049caa4 \\u003Cunknown>\\n#18 0x7f0b10529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5560f90d467a <unknown>
E       #1 0x5560f8b53566 <unknown>
E       #2 0x5560f8b8eb4c <unknown>
E       #3 0x5560f8b8a7c4 <unknown>
E       #4 0x5560f8bd9bd3 <unknown>
E       #5 0x5560f8bd9286 <unknown>
E       #6 0x5560f8bcb403 <unknown>
E       #7 0x5560f8b97b02 <unknown>
E       #8 0x5560f8b987c1 <unknown>
E       #9 0x5560f9098448 <unknown>
E       #10 0x5560f909c2af <unknown>
E       #11 0x5560f907f8d9 <unknown>
E       #12 0x5560f909ce55 <unknown>
E       #13 0x5560f906513f <unknown>
E       #14 0x5560f90c14b8 <unknown>
E       #15 0x5560f90c1693 <unknown>
E       #16 0x5560f90d3613 <unknown>
E       #17 0x7f0b1049caa4 <unknown>
E       #18 0x7f0b10529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5560f90d467a <unknown>
E           #1 0x5560f8b53566 <unknown>
E           #2 0x5560f8b8eb4c <unknown>
E           #3 0x5560f8b8a7c4 <unknown>
E           #4 0x5560f8bd9bd3 <unknown>
E           #5 0x5560f8bd9286 <unknown>
E           #6 0x5560f8bcb403 <unknown>
E           #7 0x5560f8b97b02 <unknown>
E           #8 0x5560f8b987c1 <unknown>
E           #9 0x5560f9098448 <unknown>
E           #10 0x5560f909c2af <unknown>
E           #11 0x5560f907f8d9 <unknown>
E           #12 0x5560f909ce55 <unknown>
E           #13 0x5560f906513f <unknown>
E           #14 0x5560f90c14b8 <unknown>
E           #15 0x5560f90c1693 <unknown>
E           #16 0x5560f90d3613 <unknown>
E           #17 0x7f0b1049caa4 <unknown>
E           #18 0x7f0b10529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:22,970 - INFO - Starting test with Chrome browser
2025-10-17 03:48:22,970 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:23,036 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:23,071 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:23,103 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:24,191 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5560f90d467a <unknown>
#1 0x5560f8b53566 <unknown>
#2 0x5560f8b8eb4c <unknown>
#3 0x5560f8b8a7c4 <unknown>
#4 0x5560f8bd9bd3 <unknown>
#5 0x5560f8bd9286 <unknown>
#6 0x5560f8bcb403 <unknown>
#7 0x5560f8b97b02 <unknown>
#8 0x5560f8b987c1 <unknown>
#9 0x5560f9098448 <unknown>
#10 0x5560f909c2af <unknown>
#11 0x5560f907f8d9 <unknown>
#12 0x5560f909ce55 <unknown>
#13 0x5560f906513f <unknown>
#14 0x5560f90c14b8 <unknown>
#15 0x5560f90c1693 <unknown>
#16 0x5560f90d3613 <unknown>
#17 0x7f0b1049caa4 <unknown>
#18 0x7f0b10529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5560f90d467a <unknown>
#1 0x5560f8b53566 <unknown>
#2 0x5560f8b8eb4c <unknown>
#3 0x5560f8b8a7c4 <unknown>
#4 0x5560f8bd9bd3 <unknown>
#5 0x5560f8bd9286 <unknown>
#6 0x5560f8bcb403 <unknown>
#7 0x5560f8b97b02 <unknown>
#8 0x5560f8b987c1 <unknown>
#9 0x5560f9098448 <unknown>
#10 0x5560f909c2af <unknown>
#11 0x5560f907f8d9 <unknown>
#12 0x5560f909ce55 <unknown>
#13 0x5560f906513f <unknown>
#14 0x5560f90c14b8 <unknown>
#15 0x5560f90c1693 <unknown>
#16 0x5560f90d3613 <unknown>
#17 0x7f0b1049caa4 <unknown>
#18 0x7f0b10529c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username2] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d0ce50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d0d7f0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d0ce50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8d0d7f0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8d0d550>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8d0ce50>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f8d0e970>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55b2d8da5613 \\u003Cunknown>\\n#17 0x7f393109caa4 \\u003Cunknown>\\n#18 0x7f3931129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55b2d8da667a <unknown>
E       #1 0x55b2d8825566 <unknown>
E       #2 0x55b2d8860b4c <unknown>
E       #3 0x55b2d885c7c4 <unknown>
E       #4 0x55b2d88abbd3 <unknown>
E       #5 0x55b2d88ab286 <unknown>
E       #6 0x55b2d889d403 <unknown>
E       #7 0x55b2d8869b02 <unknown>
E       #8 0x55b2d886a7c1 <unknown>
E       #9 0x55b2d8d6a448 <unknown>
E       #10 0x55b2d8d6e2af <unknown>
E       #11 0x55b2d8d518d9 <unknown>
E       #12 0x55b2d8d6ee55 <unknown>
E       #13 0x55b2d8d3713f <unknown>
E       #14 0x55b2d8d934b8 <unknown>
E       #15 0x55b2d8d93693 <unknown>
E       #16 0x55b2d8da5613 <unknown>
E       #17 0x7f393109caa4 <unknown>
E       #18 0x7f3931129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55b2d8da667a <unknown>
E           #1 0x55b2d8825566 <unknown>
E           #2 0x55b2d8860b4c <unknown>
E           #3 0x55b2d885c7c4 <unknown>
E           #4 0x55b2d88abbd3 <unknown>
E           #5 0x55b2d88ab286 <unknown>
E           #6 0x55b2d889d403 <unknown>
E           #7 0x55b2d8869b02 <unknown>
E           #8 0x55b2d886a7c1 <unknown>
E           #9 0x55b2d8d6a448 <unknown>
E           #10 0x55b2d8d6e2af <unknown>
E           #11 0x55b2d8d518d9 <unknown>
E           #12 0x55b2d8d6ee55 <unknown>
E           #13 0x55b2d8d3713f <unknown>
E           #14 0x55b2d8d934b8 <unknown>
E           #15 0x55b2d8d93693 <unknown>
E           #16 0x55b2d8da5613 <unknown>
E           #17 0x7f393109caa4 <unknown>
E           #18 0x7f3931129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:24,231 - INFO - Starting test with Chrome browser
2025-10-17 03:48:24,231 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:24,299 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:24,336 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:24,368 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:25,456 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b2d8da667a <unknown>
#1 0x55b2d8825566 <unknown>
#2 0x55b2d8860b4c <unknown>
#3 0x55b2d885c7c4 <unknown>
#4 0x55b2d88abbd3 <unknown>
#5 0x55b2d88ab286 <unknown>
#6 0x55b2d889d403 <unknown>
#7 0x55b2d8869b02 <unknown>
#8 0x55b2d886a7c1 <unknown>
#9 0x55b2d8d6a448 <unknown>
#10 0x55b2d8d6e2af <unknown>
#11 0x55b2d8d518d9 <unknown>
#12 0x55b2d8d6ee55 <unknown>
#13 0x55b2d8d3713f <unknown>
#14 0x55b2d8d934b8 <unknown>
#15 0x55b2d8d93693 <unknown>
#16 0x55b2d8da5613 <unknown>
#17 0x7f393109caa4 <unknown>
#18 0x7f3931129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b2d8da667a <unknown>
#1 0x55b2d8825566 <unknown>
#2 0x55b2d8860b4c <unknown>
#3 0x55b2d885c7c4 <unknown>
#4 0x55b2d88abbd3 <unknown>
#5 0x55b2d88ab286 <unknown>
#6 0x55b2d889d403 <unknown>
#7 0x55b2d8869b02 <unknown>
#8 0x55b2d886a7c1 <unknown>
#9 0x55b2d8d6a448 <unknown>
#10 0x55b2d8d6e2af <unknown>
#11 0x55b2d8d518d9 <unknown>
#12 0x55b2d8d6ee55 <unknown>
#13 0x55b2d8d3713f <unknown>
#14 0x55b2d8d934b8 <unknown>
#15 0x55b2d8d93693 <unknown>
#16 0x55b2d8da5613 <unknown>
#17 0x7f393109caa4 <unknown>
#18 0x7f3931129c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username3] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9690c90>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f9690e50>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9690c90>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f9690e50>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f9691010>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f9690c90>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f9691470>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x564dd20fe613 \\u003Cunknown>\\n#17 0x7f7fb849caa4 \\u003Cunknown>\\n#18 0x7f7fb8529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x564dd20ff67a <unknown>
E       #1 0x564dd1b7e566 <unknown>
E       #2 0x564dd1bb9b4c <unknown>
E       #3 0x564dd1bb57c4 <unknown>
E       #4 0x564dd1c04bd3 <unknown>
E       #5 0x564dd1c04286 <unknown>
E       #6 0x564dd1bf6403 <unknown>
E       #7 0x564dd1bc2b02 <unknown>
E       #8 0x564dd1bc37c1 <unknown>
E       #9 0x564dd20c3448 <unknown>
E       #10 0x564dd20c72af <unknown>
E       #11 0x564dd20aa8d9 <unknown>
E       #12 0x564dd20c7e55 <unknown>
E       #13 0x564dd209013f <unknown>
E       #14 0x564dd20ec4b8 <unknown>
E       #15 0x564dd20ec693 <unknown>
E       #16 0x564dd20fe613 <unknown>
E       #17 0x7f7fb849caa4 <unknown>
E       #18 0x7f7fb8529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x564dd20ff67a <unknown>
E           #1 0x564dd1b7e566 <unknown>
E           #2 0x564dd1bb9b4c <unknown>
E           #3 0x564dd1bb57c4 <unknown>
E           #4 0x564dd1c04bd3 <unknown>
E           #5 0x564dd1c04286 <unknown>
E           #6 0x564dd1bf6403 <unknown>
E           #7 0x564dd1bc2b02 <unknown>
E           #8 0x564dd1bc37c1 <unknown>
E           #9 0x564dd20c3448 <unknown>
E           #10 0x564dd20c72af <unknown>
E           #11 0x564dd20aa8d9 <unknown>
E           #12 0x564dd20c7e55 <unknown>
E           #13 0x564dd209013f <unknown>
E           #14 0x564dd20ec4b8 <unknown>
E           #15 0x564dd20ec693 <unknown>
E           #16 0x564dd20fe613 <unknown>
E           #17 0x7f7fb849caa4 <unknown>
E           #18 0x7f7fb8529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:25,497 - INFO - Starting test with Chrome browser
2025-10-17 03:48:25,497 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:25,564 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:25,599 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:25,633 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:26,721 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x564dd20ff67a <unknown>
#1 0x564dd1b7e566 <unknown>
#2 0x564dd1bb9b4c <unknown>
#3 0x564dd1bb57c4 <unknown>
#4 0x564dd1c04bd3 <unknown>
#5 0x564dd1c04286 <unknown>
#6 0x564dd1bf6403 <unknown>
#7 0x564dd1bc2b02 <unknown>
#8 0x564dd1bc37c1 <unknown>
#9 0x564dd20c3448 <unknown>
#10 0x564dd20c72af <unknown>
#11 0x564dd20aa8d9 <unknown>
#12 0x564dd20c7e55 <unknown>
#13 0x564dd209013f <unknown>
#14 0x564dd20ec4b8 <unknown>
#15 0x564dd20ec693 <unknown>
#16 0x564dd20fe613 <unknown>
#17 0x7f7fb849caa4 <unknown>
#18 0x7f7fb8529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x564dd20ff67a <unknown>
#1 0x564dd1b7e566 <unknown>
#2 0x564dd1bb9b4c <unknown>
#3 0x564dd1bb57c4 <unknown>
#4 0x564dd1c04bd3 <unknown>
#5 0x564dd1c04286 <unknown>
#6 0x564dd1bf6403 <unknown>
#7 0x564dd1bc2b02 <unknown>
#8 0x564dd1bc37c1 <unknown>
#9 0x564dd20c3448 <unknown>
#10 0x564dd20c72af <unknown>
#11 0x564dd20aa8d9 <unknown>
#12 0x564dd20c7e55 <unknown>
#13 0x564dd209013f <unknown>
#14 0x564dd20ec4b8 <unknown>
#15 0x564dd20ec693 <unknown>
#16 0x564dd20fe613 <unknown>
#17 0x7f7fb849caa4 <unknown>
#18 0x7f7fb8529c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username4] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8eea270>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8eeb2b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8eea270>
service = <selenium.webdriver.chrome.service.Service object at 0x7f49f8eeb2b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f49f8ee81f0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f49f8eea270>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f49f8ee9710>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55d8c50fa613 \\u003Cunknown>\\n#17 0x7fdbe529caa4 \\u003Cunknown>\\n#18 0x7fdbe5329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55d8c50fb67a <unknown>
E       #1 0x55d8c4b7a566 <unknown>
E       #2 0x55d8c4bb5b4c <unknown>
E       #3 0x55d8c4bb17c4 <unknown>
E       #4 0x55d8c4c00bd3 <unknown>
E       #5 0x55d8c4c00286 <unknown>
E       #6 0x55d8c4bf2403 <unknown>
E       #7 0x55d8c4bbeb02 <unknown>
E       #8 0x55d8c4bbf7c1 <unknown>
E       #9 0x55d8c50bf448 <unknown>
E       #10 0x55d8c50c32af <unknown>
E       #11 0x55d8c50a68d9 <unknown>
E       #12 0x55d8c50c3e55 <unknown>
E       #13 0x55d8c508c13f <unknown>
E       #14 0x55d8c50e84b8 <unknown>
E       #15 0x55d8c50e8693 <unknown>
E       #16 0x55d8c50fa613 <unknown>
E       #17 0x7fdbe529caa4 <unknown>
E       #18 0x7fdbe5329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55d8c50fb67a <unknown>
E           #1 0x55d8c4b7a566 <unknown>
E           #2 0x55d8c4bb5b4c <unknown>
E           #3 0x55d8c4bb17c4 <unknown>
E           #4 0x55d8c4c00bd3 <unknown>
E           #5 0x55d8c4c00286 <unknown>
E           #6 0x55d8c4bf2403 <unknown>
E           #7 0x55d8c4bbeb02 <unknown>
E           #8 0x55d8c4bbf7c1 <unknown>
E           #9 0x55d8c50bf448 <unknown>
E           #10 0x55d8c50c32af <unknown>
E           #11 0x55d8c50a68d9 <unknown>
E           #12 0x55d8c50c3e55 <unknown>
E           #13 0x55d8c508c13f <unknown>
E           #14 0x55d8c50e84b8 <unknown>
E           #15 0x55d8c50e8693 <unknown>
E           #16 0x55d8c50fa613 <unknown>
E           #17 0x7fdbe529caa4 <unknown>
E           #18 0x7fdbe5329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-17 03:48:26,762 - INFO - Starting test with Chrome browser
2025-10-17 03:48:26,763 - INFO - ====== WebDriver manager ======
2025-10-17 03:48:26,828 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:26,862 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-17 03:48:26,894 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-17 03:48:27,982 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d8c50fb67a <unknown>
#1 0x55d8c4b7a566 <unknown>
#2 0x55d8c4bb5b4c <unknown>
#3 0x55d8c4bb17c4 <unknown>
#4 0x55d8c4c00bd3 <unknown>
#5 0x55d8c4c00286 <unknown>
#6 0x55d8c4bf2403 <unknown>
#7 0x55d8c4bbeb02 <unknown>
#8 0x55d8c4bbf7c1 <unknown>
#9 0x55d8c50bf448 <unknown>
#10 0x55d8c50c32af <unknown>
#11 0x55d8c50a68d9 <unknown>
#12 0x55d8c50c3e55 <unknown>
#13 0x55d8c508c13f <unknown>
#14 0x55d8c50e84b8 <unknown>
#15 0x55d8c50e8693 <unknown>
#16 0x55d8c50fa613 <unknown>
#17 0x7fdbe529caa4 <unknown>
#18 0x7fdbe5329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d8c50fb67a <unknown>
#1 0x55d8c4b7a566 <unknown>
#2 0x55d8c4bb5b4c <unknown>
#3 0x55d8c4bb17c4 <unknown>
#4 0x55d8c4c00bd3 <unknown>
#5 0x55d8c4c00286 <unknown>
#6 0x55d8c4bf2403 <unknown>
#7 0x55d8c4bbeb02 <unknown>
#8 0x55d8c4bbf7c1 <unknown>
#9 0x55d8c50bf448 <unknown>
#10 0x55d8c50c32af <unknown>
#11 0x55d8c50a68d9 <unknown>
#12 0x55d8c50c3e55 <unknown>
#13 0x55d8c508c13f <unknown>
#14 0x55d8c50e84b8 <unknown>
#15 0x55d8c50e8693 <unknown>
#16 0x55d8c50fa613 <unknown>
#17 0x7fdbe529caa4 <unknown>
#18 0x7fdbe5329c6c <unknown>
- Generated html report: file:///home/runner/work/Mocha_accounting/Mocha_accounting/C%3A%5CUsers%5CTaurus13%5CPycharmProjects%5CPythonProject%5Creports/20251017_034808/report.html -
============================= 15 errors in 19.45s ==============================
=== LOGIN TESTS COMPLETED ===
Exit Code: 1
