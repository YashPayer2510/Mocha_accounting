=== LOGIN TESTS STARTED: 2025-10-18 03:44:02 ===
============================= test session starts ==============================
platform linux -- Python 3.13.8, pytest-8.3.5, pluggy-1.6.0 -- /opt/hostedtoolcache/Python/3.13.8/x64/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.13.8', 'Platform': 'Linux-6.14.0-1012-azure-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.6.0'}, 'Plugins': {'metadata': '3.1.1', 'xdist': '3.8.0', 'rerunfailures': '16.1', 'Faker': '37.11.0', 'html': '4.1.1'}, 'CI': 'true', 'JAVA_HOME': '/usr/lib/jvm/temurin-17-jdk-amd64'}
rootdir: /home/runner/work/Mocha_accounting/Mocha_accounting
plugins: metadata-3.1.1, xdist-3.8.0, rerunfailures-16.1, Faker-37.11.0, html-4.1.1
collecting ... collected 15 items

tests/test_signup_login/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] ERROR [  6%]
tests/test_signup_login/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] ERROR [ 13%]
tests/test_signup_login/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ERROR [ 20%]
tests/test_signup_login/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] ERROR [ 26%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username0] ERROR [ 33%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username1] ERROR [ 40%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username2] ERROR [ 46%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username3] ERROR [ 53%]
tests/test_signup_login/test_login.py::test_blank_username_validation ERROR [ 60%]
tests/test_signup_login/test_login.py::test_blank_password_validation ERROR [ 66%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username0] ERROR [ 73%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username1] ERROR [ 80%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username2] ERROR [ 86%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username3] ERROR [ 93%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username4] ERROR [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242320ad0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff242320c20>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242320ad0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff242320c20>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff242321160>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242320ad0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff242320ec0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55b140849613 \\u003Cunknown>\\n#17 0x7f530249caa4 \\u003Cunknown>\\n#18 0x7f5302529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55b14084a67a <unknown>
E       #1 0x55b1402c9566 <unknown>
E       #2 0x55b140304b4c <unknown>
E       #3 0x55b1403007c4 <unknown>
E       #4 0x55b14034fbd3 <unknown>
E       #5 0x55b14034f286 <unknown>
E       #6 0x55b140341403 <unknown>
E       #7 0x55b14030db02 <unknown>
E       #8 0x55b14030e7c1 <unknown>
E       #9 0x55b14080e448 <unknown>
E       #10 0x55b1408122af <unknown>
E       #11 0x55b1407f58d9 <unknown>
E       #12 0x55b140812e55 <unknown>
E       #13 0x55b1407db13f <unknown>
E       #14 0x55b1408374b8 <unknown>
E       #15 0x55b140837693 <unknown>
E       #16 0x55b140849613 <unknown>
E       #17 0x7f530249caa4 <unknown>
E       #18 0x7f5302529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55b14084a67a <unknown>
E           #1 0x55b1402c9566 <unknown>
E           #2 0x55b140304b4c <unknown>
E           #3 0x55b1403007c4 <unknown>
E           #4 0x55b14034fbd3 <unknown>
E           #5 0x55b14034f286 <unknown>
E           #6 0x55b140341403 <unknown>
E           #7 0x55b14030db02 <unknown>
E           #8 0x55b14030e7c1 <unknown>
E           #9 0x55b14080e448 <unknown>
E           #10 0x55b1408122af <unknown>
E           #11 0x55b1407f58d9 <unknown>
E           #12 0x55b140812e55 <unknown>
E           #13 0x55b1407db13f <unknown>
E           #14 0x55b1408374b8 <unknown>
E           #15 0x55b140837693 <unknown>
E           #16 0x55b140849613 <unknown>
E           #17 0x7f530249caa4 <unknown>
E           #18 0x7f5302529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:03,497 - INFO - Starting test with Chrome browser
2025-10-18 03:44:03,498 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:03,564 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:03,599 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:03,631 - INFO - There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
2025-10-18 03:44:03,631 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:03,730 - INFO - WebDriver version 141.0.7390.78 selected
2025-10-18 03:44:03,735 - INFO - Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-18 03:44:03,735 - INFO - About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-18 03:44:03,776 - INFO - Driver downloading response is 200
2025-10-18 03:44:03,825 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:03,967 - INFO - Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
2025-10-18 03:44:07,210 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b14084a67a <unknown>
#1 0x55b1402c9566 <unknown>
#2 0x55b140304b4c <unknown>
#3 0x55b1403007c4 <unknown>
#4 0x55b14034fbd3 <unknown>
#5 0x55b14034f286 <unknown>
#6 0x55b140341403 <unknown>
#7 0x55b14030db02 <unknown>
#8 0x55b14030e7c1 <unknown>
#9 0x55b14080e448 <unknown>
#10 0x55b1408122af <unknown>
#11 0x55b1407f58d9 <unknown>
#12 0x55b140812e55 <unknown>
#13 0x55b1407db13f <unknown>
#14 0x55b1408374b8 <unknown>
#15 0x55b140837693 <unknown>
#16 0x55b140849613 <unknown>
#17 0x7f530249caa4 <unknown>
#18 0x7f5302529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 WebDriver version 141.0.7390.78 selected
INFO     WDM:logger.py:11 Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 Driver downloading response is 200
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55b14084a67a <unknown>
#1 0x55b1402c9566 <unknown>
#2 0x55b140304b4c <unknown>
#3 0x55b1403007c4 <unknown>
#4 0x55b14034fbd3 <unknown>
#5 0x55b14034f286 <unknown>
#6 0x55b140341403 <unknown>
#7 0x55b14030db02 <unknown>
#8 0x55b14030e7c1 <unknown>
#9 0x55b14080e448 <unknown>
#10 0x55b1408122af <unknown>
#11 0x55b1407f58d9 <unknown>
#12 0x55b140812e55 <unknown>
#13 0x55b1407db13f <unknown>
#14 0x55b1408374b8 <unknown>
#15 0x55b140837693 <unknown>
#16 0x55b140849613 <unknown>
#17 0x7f530249caa4 <unknown>
#18 0x7f5302529c6c <unknown>
____ ERROR at setup of test_valid_login[samatakamble9@gmail.com-Samata@16] _____

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24234a850>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24234ad50>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24234a850>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24234ad50>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff24234b110>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24234a850>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff24234afd0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55d7a25ca613 \\u003Cunknown>\\n#17 0x7f6e9cc9caa4 \\u003Cunknown>\\n#18 0x7f6e9cd29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55d7a25cb67a <unknown>
E       #1 0x55d7a204a566 <unknown>
E       #2 0x55d7a2085b4c <unknown>
E       #3 0x55d7a20817c4 <unknown>
E       #4 0x55d7a20d0bd3 <unknown>
E       #5 0x55d7a20d0286 <unknown>
E       #6 0x55d7a20c2403 <unknown>
E       #7 0x55d7a208eb02 <unknown>
E       #8 0x55d7a208f7c1 <unknown>
E       #9 0x55d7a258f448 <unknown>
E       #10 0x55d7a25932af <unknown>
E       #11 0x55d7a25768d9 <unknown>
E       #12 0x55d7a2593e55 <unknown>
E       #13 0x55d7a255c13f <unknown>
E       #14 0x55d7a25b84b8 <unknown>
E       #15 0x55d7a25b8693 <unknown>
E       #16 0x55d7a25ca613 <unknown>
E       #17 0x7f6e9cc9caa4 <unknown>
E       #18 0x7f6e9cd29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55d7a25cb67a <unknown>
E           #1 0x55d7a204a566 <unknown>
E           #2 0x55d7a2085b4c <unknown>
E           #3 0x55d7a20817c4 <unknown>
E           #4 0x55d7a20d0bd3 <unknown>
E           #5 0x55d7a20d0286 <unknown>
E           #6 0x55d7a20c2403 <unknown>
E           #7 0x55d7a208eb02 <unknown>
E           #8 0x55d7a208f7c1 <unknown>
E           #9 0x55d7a258f448 <unknown>
E           #10 0x55d7a25932af <unknown>
E           #11 0x55d7a25768d9 <unknown>
E           #12 0x55d7a2593e55 <unknown>
E           #13 0x55d7a255c13f <unknown>
E           #14 0x55d7a25b84b8 <unknown>
E           #15 0x55d7a25b8693 <unknown>
E           #16 0x55d7a25ca613 <unknown>
E           #17 0x7f6e9cc9caa4 <unknown>
E           #18 0x7f6e9cd29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:07,278 - INFO - Starting test with Chrome browser
2025-10-18 03:44:07,278 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:07,344 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:07,378 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:07,450 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:08,539 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d7a25cb67a <unknown>
#1 0x55d7a204a566 <unknown>
#2 0x55d7a2085b4c <unknown>
#3 0x55d7a20817c4 <unknown>
#4 0x55d7a20d0bd3 <unknown>
#5 0x55d7a20d0286 <unknown>
#6 0x55d7a20c2403 <unknown>
#7 0x55d7a208eb02 <unknown>
#8 0x55d7a208f7c1 <unknown>
#9 0x55d7a258f448 <unknown>
#10 0x55d7a25932af <unknown>
#11 0x55d7a25768d9 <unknown>
#12 0x55d7a2593e55 <unknown>
#13 0x55d7a255c13f <unknown>
#14 0x55d7a25b84b8 <unknown>
#15 0x55d7a25b8693 <unknown>
#16 0x55d7a25ca613 <unknown>
#17 0x7f6e9cc9caa4 <unknown>
#18 0x7f6e9cd29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d7a25cb67a <unknown>
#1 0x55d7a204a566 <unknown>
#2 0x55d7a2085b4c <unknown>
#3 0x55d7a20817c4 <unknown>
#4 0x55d7a20d0bd3 <unknown>
#5 0x55d7a20d0286 <unknown>
#6 0x55d7a20c2403 <unknown>
#7 0x55d7a208eb02 <unknown>
#8 0x55d7a208f7c1 <unknown>
#9 0x55d7a258f448 <unknown>
#10 0x55d7a25932af <unknown>
#11 0x55d7a25768d9 <unknown>
#12 0x55d7a2593e55 <unknown>
#13 0x55d7a255c13f <unknown>
#14 0x55d7a25b84b8 <unknown>
#15 0x55d7a25b8693 <unknown>
#16 0x55d7a25ca613 <unknown>
#17 0x7f6e9cc9caa4 <unknown>
#18 0x7f6e9cd29c6c <unknown>
__ ERROR at setup of test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ___

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242349bd0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff242349310>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242349bd0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff242349310>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff242349090>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242349bd0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2423b4a50>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55837f7e1613 \\u003Cunknown>\\n#17 0x7fb544e9caa4 \\u003Cunknown>\\n#18 0x7fb544f29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55837f7e267a <unknown>
E       #1 0x55837f261566 <unknown>
E       #2 0x55837f29cb4c <unknown>
E       #3 0x55837f2987c4 <unknown>
E       #4 0x55837f2e7bd3 <unknown>
E       #5 0x55837f2e7286 <unknown>
E       #6 0x55837f2d9403 <unknown>
E       #7 0x55837f2a5b02 <unknown>
E       #8 0x55837f2a67c1 <unknown>
E       #9 0x55837f7a6448 <unknown>
E       #10 0x55837f7aa2af <unknown>
E       #11 0x55837f78d8d9 <unknown>
E       #12 0x55837f7aae55 <unknown>
E       #13 0x55837f77313f <unknown>
E       #14 0x55837f7cf4b8 <unknown>
E       #15 0x55837f7cf693 <unknown>
E       #16 0x55837f7e1613 <unknown>
E       #17 0x7fb544e9caa4 <unknown>
E       #18 0x7fb544f29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55837f7e267a <unknown>
E           #1 0x55837f261566 <unknown>
E           #2 0x55837f29cb4c <unknown>
E           #3 0x55837f2987c4 <unknown>
E           #4 0x55837f2e7bd3 <unknown>
E           #5 0x55837f2e7286 <unknown>
E           #6 0x55837f2d9403 <unknown>
E           #7 0x55837f2a5b02 <unknown>
E           #8 0x55837f2a67c1 <unknown>
E           #9 0x55837f7a6448 <unknown>
E           #10 0x55837f7aa2af <unknown>
E           #11 0x55837f78d8d9 <unknown>
E           #12 0x55837f7aae55 <unknown>
E           #13 0x55837f77313f <unknown>
E           #14 0x55837f7cf4b8 <unknown>
E           #15 0x55837f7cf693 <unknown>
E           #16 0x55837f7e1613 <unknown>
E           #17 0x7fb544e9caa4 <unknown>
E           #18 0x7fb544f29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:08,580 - INFO - Starting test with Chrome browser
2025-10-18 03:44:08,580 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:08,646 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:08,680 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:08,714 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:09,804 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55837f7e267a <unknown>
#1 0x55837f261566 <unknown>
#2 0x55837f29cb4c <unknown>
#3 0x55837f2987c4 <unknown>
#4 0x55837f2e7bd3 <unknown>
#5 0x55837f2e7286 <unknown>
#6 0x55837f2d9403 <unknown>
#7 0x55837f2a5b02 <unknown>
#8 0x55837f2a67c1 <unknown>
#9 0x55837f7a6448 <unknown>
#10 0x55837f7aa2af <unknown>
#11 0x55837f78d8d9 <unknown>
#12 0x55837f7aae55 <unknown>
#13 0x55837f77313f <unknown>
#14 0x55837f7cf4b8 <unknown>
#15 0x55837f7cf693 <unknown>
#16 0x55837f7e1613 <unknown>
#17 0x7fb544e9caa4 <unknown>
#18 0x7fb544f29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55837f7e267a <unknown>
#1 0x55837f261566 <unknown>
#2 0x55837f29cb4c <unknown>
#3 0x55837f2987c4 <unknown>
#4 0x55837f2e7bd3 <unknown>
#5 0x55837f2e7286 <unknown>
#6 0x55837f2d9403 <unknown>
#7 0x55837f2a5b02 <unknown>
#8 0x55837f2a67c1 <unknown>
#9 0x55837f7a6448 <unknown>
#10 0x55837f7aa2af <unknown>
#11 0x55837f78d8d9 <unknown>
#12 0x55837f7aae55 <unknown>
#13 0x55837f77313f <unknown>
#14 0x55837f7cf4b8 <unknown>
#15 0x55837f7cf693 <unknown>
#16 0x55837f7e1613 <unknown>
#17 0x7fb544e9caa4 <unknown>
#18 0x7fb544f29c6c <unknown>
_ ERROR at setup of test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2440a2c40>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2440a2d70>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2440a2c40>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2440a2d70>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff2440a3230>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2440a2c40>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2440a3100>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55ec2f3d8613 \\u003Cunknown>\\n#17 0x7f25c2c9caa4 \\u003Cunknown>\\n#18 0x7f25c2d29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55ec2f3d967a <unknown>
E       #1 0x55ec2ee58566 <unknown>
E       #2 0x55ec2ee93b4c <unknown>
E       #3 0x55ec2ee8f7c4 <unknown>
E       #4 0x55ec2eedebd3 <unknown>
E       #5 0x55ec2eede286 <unknown>
E       #6 0x55ec2eed0403 <unknown>
E       #7 0x55ec2ee9cb02 <unknown>
E       #8 0x55ec2ee9d7c1 <unknown>
E       #9 0x55ec2f39d448 <unknown>
E       #10 0x55ec2f3a12af <unknown>
E       #11 0x55ec2f3848d9 <unknown>
E       #12 0x55ec2f3a1e55 <unknown>
E       #13 0x55ec2f36a13f <unknown>
E       #14 0x55ec2f3c64b8 <unknown>
E       #15 0x55ec2f3c6693 <unknown>
E       #16 0x55ec2f3d8613 <unknown>
E       #17 0x7f25c2c9caa4 <unknown>
E       #18 0x7f25c2d29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55ec2f3d967a <unknown>
E           #1 0x55ec2ee58566 <unknown>
E           #2 0x55ec2ee93b4c <unknown>
E           #3 0x55ec2ee8f7c4 <unknown>
E           #4 0x55ec2eedebd3 <unknown>
E           #5 0x55ec2eede286 <unknown>
E           #6 0x55ec2eed0403 <unknown>
E           #7 0x55ec2ee9cb02 <unknown>
E           #8 0x55ec2ee9d7c1 <unknown>
E           #9 0x55ec2f39d448 <unknown>
E           #10 0x55ec2f3a12af <unknown>
E           #11 0x55ec2f3848d9 <unknown>
E           #12 0x55ec2f3a1e55 <unknown>
E           #13 0x55ec2f36a13f <unknown>
E           #14 0x55ec2f3c64b8 <unknown>
E           #15 0x55ec2f3c6693 <unknown>
E           #16 0x55ec2f3d8613 <unknown>
E           #17 0x7f25c2c9caa4 <unknown>
E           #18 0x7f25c2d29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:09,842 - INFO - Starting test with Chrome browser
2025-10-18 03:44:09,843 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:09,907 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:09,941 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:09,973 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:11,062 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ec2f3d967a <unknown>
#1 0x55ec2ee58566 <unknown>
#2 0x55ec2ee93b4c <unknown>
#3 0x55ec2ee8f7c4 <unknown>
#4 0x55ec2eedebd3 <unknown>
#5 0x55ec2eede286 <unknown>
#6 0x55ec2eed0403 <unknown>
#7 0x55ec2ee9cb02 <unknown>
#8 0x55ec2ee9d7c1 <unknown>
#9 0x55ec2f39d448 <unknown>
#10 0x55ec2f3a12af <unknown>
#11 0x55ec2f3848d9 <unknown>
#12 0x55ec2f3a1e55 <unknown>
#13 0x55ec2f36a13f <unknown>
#14 0x55ec2f3c64b8 <unknown>
#15 0x55ec2f3c6693 <unknown>
#16 0x55ec2f3d8613 <unknown>
#17 0x7f25c2c9caa4 <unknown>
#18 0x7f25c2d29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ec2f3d967a <unknown>
#1 0x55ec2ee58566 <unknown>
#2 0x55ec2ee93b4c <unknown>
#3 0x55ec2ee8f7c4 <unknown>
#4 0x55ec2eedebd3 <unknown>
#5 0x55ec2eede286 <unknown>
#6 0x55ec2eed0403 <unknown>
#7 0x55ec2ee9cb02 <unknown>
#8 0x55ec2ee9d7c1 <unknown>
#9 0x55ec2f39d448 <unknown>
#10 0x55ec2f3a12af <unknown>
#11 0x55ec2f3848d9 <unknown>
#12 0x55ec2f3a1e55 <unknown>
#13 0x55ec2f36a13f <unknown>
#14 0x55ec2f3c64b8 <unknown>
#15 0x55ec2f3c6693 <unknown>
#16 0x55ec2f3d8613 <unknown>
#17 0x7f25c2c9caa4 <unknown>
#18 0x7f25c2d29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username0] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2440a3bb0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2442143e0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2440a3bb0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2442143e0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff244214640>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2440a3bb0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff244214510>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55beb86c7613 \\u003Cunknown>\\n#17 0x7feeb6c9caa4 \\u003Cunknown>\\n#18 0x7feeb6d29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55beb86c867a <unknown>
E       #1 0x55beb8147566 <unknown>
E       #2 0x55beb8182b4c <unknown>
E       #3 0x55beb817e7c4 <unknown>
E       #4 0x55beb81cdbd3 <unknown>
E       #5 0x55beb81cd286 <unknown>
E       #6 0x55beb81bf403 <unknown>
E       #7 0x55beb818bb02 <unknown>
E       #8 0x55beb818c7c1 <unknown>
E       #9 0x55beb868c448 <unknown>
E       #10 0x55beb86902af <unknown>
E       #11 0x55beb86738d9 <unknown>
E       #12 0x55beb8690e55 <unknown>
E       #13 0x55beb865913f <unknown>
E       #14 0x55beb86b54b8 <unknown>
E       #15 0x55beb86b5693 <unknown>
E       #16 0x55beb86c7613 <unknown>
E       #17 0x7feeb6c9caa4 <unknown>
E       #18 0x7feeb6d29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55beb86c867a <unknown>
E           #1 0x55beb8147566 <unknown>
E           #2 0x55beb8182b4c <unknown>
E           #3 0x55beb817e7c4 <unknown>
E           #4 0x55beb81cdbd3 <unknown>
E           #5 0x55beb81cd286 <unknown>
E           #6 0x55beb81bf403 <unknown>
E           #7 0x55beb818bb02 <unknown>
E           #8 0x55beb818c7c1 <unknown>
E           #9 0x55beb868c448 <unknown>
E           #10 0x55beb86902af <unknown>
E           #11 0x55beb86738d9 <unknown>
E           #12 0x55beb8690e55 <unknown>
E           #13 0x55beb865913f <unknown>
E           #14 0x55beb86b54b8 <unknown>
E           #15 0x55beb86b5693 <unknown>
E           #16 0x55beb86c7613 <unknown>
E           #17 0x7feeb6c9caa4 <unknown>
E           #18 0x7feeb6d29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:11,101 - INFO - Starting test with Chrome browser
2025-10-18 03:44:11,101 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:11,166 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:11,199 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:11,233 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:12,322 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55beb86c867a <unknown>
#1 0x55beb8147566 <unknown>
#2 0x55beb8182b4c <unknown>
#3 0x55beb817e7c4 <unknown>
#4 0x55beb81cdbd3 <unknown>
#5 0x55beb81cd286 <unknown>
#6 0x55beb81bf403 <unknown>
#7 0x55beb818bb02 <unknown>
#8 0x55beb818c7c1 <unknown>
#9 0x55beb868c448 <unknown>
#10 0x55beb86902af <unknown>
#11 0x55beb86738d9 <unknown>
#12 0x55beb8690e55 <unknown>
#13 0x55beb865913f <unknown>
#14 0x55beb86b54b8 <unknown>
#15 0x55beb86b5693 <unknown>
#16 0x55beb86c7613 <unknown>
#17 0x7feeb6c9caa4 <unknown>
#18 0x7feeb6d29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55beb86c867a <unknown>
#1 0x55beb8147566 <unknown>
#2 0x55beb8182b4c <unknown>
#3 0x55beb817e7c4 <unknown>
#4 0x55beb81cdbd3 <unknown>
#5 0x55beb81cd286 <unknown>
#6 0x55beb81bf403 <unknown>
#7 0x55beb818bb02 <unknown>
#8 0x55beb818c7c1 <unknown>
#9 0x55beb868c448 <unknown>
#10 0x55beb86902af <unknown>
#11 0x55beb86738d9 <unknown>
#12 0x55beb8690e55 <unknown>
#13 0x55beb865913f <unknown>
#14 0x55beb86b54b8 <unknown>
#15 0x55beb86b5693 <unknown>
#16 0x55beb86c7613 <unknown>
#17 0x7feeb6c9caa4 <unknown>
#18 0x7feeb6d29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username1] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24408eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2442a03b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24408eb10>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2442a03b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff2442a0b90>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24408eb10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2442a0a70>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55cfc1ac3613 \\u003Cunknown>\\n#17 0x7ff7d509caa4 \\u003Cunknown>\\n#18 0x7ff7d5129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55cfc1ac467a <unknown>
E       #1 0x55cfc1543566 <unknown>
E       #2 0x55cfc157eb4c <unknown>
E       #3 0x55cfc157a7c4 <unknown>
E       #4 0x55cfc15c9bd3 <unknown>
E       #5 0x55cfc15c9286 <unknown>
E       #6 0x55cfc15bb403 <unknown>
E       #7 0x55cfc1587b02 <unknown>
E       #8 0x55cfc15887c1 <unknown>
E       #9 0x55cfc1a88448 <unknown>
E       #10 0x55cfc1a8c2af <unknown>
E       #11 0x55cfc1a6f8d9 <unknown>
E       #12 0x55cfc1a8ce55 <unknown>
E       #13 0x55cfc1a5513f <unknown>
E       #14 0x55cfc1ab14b8 <unknown>
E       #15 0x55cfc1ab1693 <unknown>
E       #16 0x55cfc1ac3613 <unknown>
E       #17 0x7ff7d509caa4 <unknown>
E       #18 0x7ff7d5129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55cfc1ac467a <unknown>
E           #1 0x55cfc1543566 <unknown>
E           #2 0x55cfc157eb4c <unknown>
E           #3 0x55cfc157a7c4 <unknown>
E           #4 0x55cfc15c9bd3 <unknown>
E           #5 0x55cfc15c9286 <unknown>
E           #6 0x55cfc15bb403 <unknown>
E           #7 0x55cfc1587b02 <unknown>
E           #8 0x55cfc15887c1 <unknown>
E           #9 0x55cfc1a88448 <unknown>
E           #10 0x55cfc1a8c2af <unknown>
E           #11 0x55cfc1a6f8d9 <unknown>
E           #12 0x55cfc1a8ce55 <unknown>
E           #13 0x55cfc1a5513f <unknown>
E           #14 0x55cfc1ab14b8 <unknown>
E           #15 0x55cfc1ab1693 <unknown>
E           #16 0x55cfc1ac3613 <unknown>
E           #17 0x7ff7d509caa4 <unknown>
E           #18 0x7ff7d5129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:12,362 - INFO - Starting test with Chrome browser
2025-10-18 03:44:12,362 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:12,428 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:12,463 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:12,495 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:13,584 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55cfc1ac467a <unknown>
#1 0x55cfc1543566 <unknown>
#2 0x55cfc157eb4c <unknown>
#3 0x55cfc157a7c4 <unknown>
#4 0x55cfc15c9bd3 <unknown>
#5 0x55cfc15c9286 <unknown>
#6 0x55cfc15bb403 <unknown>
#7 0x55cfc1587b02 <unknown>
#8 0x55cfc15887c1 <unknown>
#9 0x55cfc1a88448 <unknown>
#10 0x55cfc1a8c2af <unknown>
#11 0x55cfc1a6f8d9 <unknown>
#12 0x55cfc1a8ce55 <unknown>
#13 0x55cfc1a5513f <unknown>
#14 0x55cfc1ab14b8 <unknown>
#15 0x55cfc1ab1693 <unknown>
#16 0x55cfc1ac3613 <unknown>
#17 0x7ff7d509caa4 <unknown>
#18 0x7ff7d5129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55cfc1ac467a <unknown>
#1 0x55cfc1543566 <unknown>
#2 0x55cfc157eb4c <unknown>
#3 0x55cfc157a7c4 <unknown>
#4 0x55cfc15c9bd3 <unknown>
#5 0x55cfc15c9286 <unknown>
#6 0x55cfc15bb403 <unknown>
#7 0x55cfc1587b02 <unknown>
#8 0x55cfc15887c1 <unknown>
#9 0x55cfc1a88448 <unknown>
#10 0x55cfc1a8c2af <unknown>
#11 0x55cfc1a6f8d9 <unknown>
#12 0x55cfc1a8ce55 <unknown>
#13 0x55cfc1a5513f <unknown>
#14 0x55cfc1ab14b8 <unknown>
#15 0x55cfc1ab1693 <unknown>
#16 0x55cfc1ac3613 <unknown>
#17 0x7ff7d509caa4 <unknown>
#18 0x7ff7d5129c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username2] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242353ac0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff242350e20>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242353ac0>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff242350e20>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff242352f10>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff242353ac0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2423539b0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x564b2d05d613 \\u003Cunknown>\\n#17 0x7f8c63a9caa4 \\u003Cunknown>\\n#18 0x7f8c63b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x564b2d05e67a <unknown>
E       #1 0x564b2cadd566 <unknown>
E       #2 0x564b2cb18b4c <unknown>
E       #3 0x564b2cb147c4 <unknown>
E       #4 0x564b2cb63bd3 <unknown>
E       #5 0x564b2cb63286 <unknown>
E       #6 0x564b2cb55403 <unknown>
E       #7 0x564b2cb21b02 <unknown>
E       #8 0x564b2cb227c1 <unknown>
E       #9 0x564b2d022448 <unknown>
E       #10 0x564b2d0262af <unknown>
E       #11 0x564b2d0098d9 <unknown>
E       #12 0x564b2d026e55 <unknown>
E       #13 0x564b2cfef13f <unknown>
E       #14 0x564b2d04b4b8 <unknown>
E       #15 0x564b2d04b693 <unknown>
E       #16 0x564b2d05d613 <unknown>
E       #17 0x7f8c63a9caa4 <unknown>
E       #18 0x7f8c63b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x564b2d05e67a <unknown>
E           #1 0x564b2cadd566 <unknown>
E           #2 0x564b2cb18b4c <unknown>
E           #3 0x564b2cb147c4 <unknown>
E           #4 0x564b2cb63bd3 <unknown>
E           #5 0x564b2cb63286 <unknown>
E           #6 0x564b2cb55403 <unknown>
E           #7 0x564b2cb21b02 <unknown>
E           #8 0x564b2cb227c1 <unknown>
E           #9 0x564b2d022448 <unknown>
E           #10 0x564b2d0262af <unknown>
E           #11 0x564b2d0098d9 <unknown>
E           #12 0x564b2d026e55 <unknown>
E           #13 0x564b2cfef13f <unknown>
E           #14 0x564b2d04b4b8 <unknown>
E           #15 0x564b2d04b693 <unknown>
E           #16 0x564b2d05d613 <unknown>
E           #17 0x7f8c63a9caa4 <unknown>
E           #18 0x7f8c63b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:13,625 - INFO - Starting test with Chrome browser
2025-10-18 03:44:13,625 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:13,691 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:13,726 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:13,768 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:14,857 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x564b2d05e67a <unknown>
#1 0x564b2cadd566 <unknown>
#2 0x564b2cb18b4c <unknown>
#3 0x564b2cb147c4 <unknown>
#4 0x564b2cb63bd3 <unknown>
#5 0x564b2cb63286 <unknown>
#6 0x564b2cb55403 <unknown>
#7 0x564b2cb21b02 <unknown>
#8 0x564b2cb227c1 <unknown>
#9 0x564b2d022448 <unknown>
#10 0x564b2d0262af <unknown>
#11 0x564b2d0098d9 <unknown>
#12 0x564b2d026e55 <unknown>
#13 0x564b2cfef13f <unknown>
#14 0x564b2d04b4b8 <unknown>
#15 0x564b2d04b693 <unknown>
#16 0x564b2d05d613 <unknown>
#17 0x7f8c63a9caa4 <unknown>
#18 0x7f8c63b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x564b2d05e67a <unknown>
#1 0x564b2cadd566 <unknown>
#2 0x564b2cb18b4c <unknown>
#3 0x564b2cb147c4 <unknown>
#4 0x564b2cb63bd3 <unknown>
#5 0x564b2cb63286 <unknown>
#6 0x564b2cb55403 <unknown>
#7 0x564b2cb21b02 <unknown>
#8 0x564b2cb227c1 <unknown>
#9 0x564b2d022448 <unknown>
#10 0x564b2d0262af <unknown>
#11 0x564b2d0098d9 <unknown>
#12 0x564b2d026e55 <unknown>
#13 0x564b2cfef13f <unknown>
#14 0x564b2d04b4b8 <unknown>
#15 0x564b2d04b693 <unknown>
#16 0x564b2d05d613 <unknown>
#17 0x7f8c63a9caa4 <unknown>
#18 0x7f8c63b29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username3] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2442b5d00>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2442b4f30>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2442b5d00>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2442b4f30>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff2442b4d10>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2442b5d00>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2442b4270>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55eaa1263613 \\u003Cunknown>\\n#17 0x7f6688e9caa4 \\u003Cunknown>\\n#18 0x7f6688f29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55eaa126467a <unknown>
E       #1 0x55eaa0ce3566 <unknown>
E       #2 0x55eaa0d1eb4c <unknown>
E       #3 0x55eaa0d1a7c4 <unknown>
E       #4 0x55eaa0d69bd3 <unknown>
E       #5 0x55eaa0d69286 <unknown>
E       #6 0x55eaa0d5b403 <unknown>
E       #7 0x55eaa0d27b02 <unknown>
E       #8 0x55eaa0d287c1 <unknown>
E       #9 0x55eaa1228448 <unknown>
E       #10 0x55eaa122c2af <unknown>
E       #11 0x55eaa120f8d9 <unknown>
E       #12 0x55eaa122ce55 <unknown>
E       #13 0x55eaa11f513f <unknown>
E       #14 0x55eaa12514b8 <unknown>
E       #15 0x55eaa1251693 <unknown>
E       #16 0x55eaa1263613 <unknown>
E       #17 0x7f6688e9caa4 <unknown>
E       #18 0x7f6688f29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55eaa126467a <unknown>
E           #1 0x55eaa0ce3566 <unknown>
E           #2 0x55eaa0d1eb4c <unknown>
E           #3 0x55eaa0d1a7c4 <unknown>
E           #4 0x55eaa0d69bd3 <unknown>
E           #5 0x55eaa0d69286 <unknown>
E           #6 0x55eaa0d5b403 <unknown>
E           #7 0x55eaa0d27b02 <unknown>
E           #8 0x55eaa0d287c1 <unknown>
E           #9 0x55eaa1228448 <unknown>
E           #10 0x55eaa122c2af <unknown>
E           #11 0x55eaa120f8d9 <unknown>
E           #12 0x55eaa122ce55 <unknown>
E           #13 0x55eaa11f513f <unknown>
E           #14 0x55eaa12514b8 <unknown>
E           #15 0x55eaa1251693 <unknown>
E           #16 0x55eaa1263613 <unknown>
E           #17 0x7f6688e9caa4 <unknown>
E           #18 0x7f6688f29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:14,896 - INFO - Starting test with Chrome browser
2025-10-18 03:44:14,896 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:14,961 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:15,055 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:15,087 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:16,175 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55eaa126467a <unknown>
#1 0x55eaa0ce3566 <unknown>
#2 0x55eaa0d1eb4c <unknown>
#3 0x55eaa0d1a7c4 <unknown>
#4 0x55eaa0d69bd3 <unknown>
#5 0x55eaa0d69286 <unknown>
#6 0x55eaa0d5b403 <unknown>
#7 0x55eaa0d27b02 <unknown>
#8 0x55eaa0d287c1 <unknown>
#9 0x55eaa1228448 <unknown>
#10 0x55eaa122c2af <unknown>
#11 0x55eaa120f8d9 <unknown>
#12 0x55eaa122ce55 <unknown>
#13 0x55eaa11f513f <unknown>
#14 0x55eaa12514b8 <unknown>
#15 0x55eaa1251693 <unknown>
#16 0x55eaa1263613 <unknown>
#17 0x7f6688e9caa4 <unknown>
#18 0x7f6688f29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55eaa126467a <unknown>
#1 0x55eaa0ce3566 <unknown>
#2 0x55eaa0d1eb4c <unknown>
#3 0x55eaa0d1a7c4 <unknown>
#4 0x55eaa0d69bd3 <unknown>
#5 0x55eaa0d69286 <unknown>
#6 0x55eaa0d5b403 <unknown>
#7 0x55eaa0d27b02 <unknown>
#8 0x55eaa0d287c1 <unknown>
#9 0x55eaa1228448 <unknown>
#10 0x55eaa122c2af <unknown>
#11 0x55eaa120f8d9 <unknown>
#12 0x55eaa122ce55 <unknown>
#13 0x55eaa11f513f <unknown>
#14 0x55eaa12514b8 <unknown>
#15 0x55eaa1251693 <unknown>
#16 0x55eaa1263613 <unknown>
#17 0x7f6688e9caa4 <unknown>
#18 0x7f6688f29c6c <unknown>
_______________ ERROR at setup of test_blank_username_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24238cd50>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24238c650>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24238cd50>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24238c650>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff24238c550>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24238cd50>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff24238cc50>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5611064db613 \\u003Cunknown>\\n#17 0x7f6bc5e9caa4 \\u003Cunknown>\\n#18 0x7f6bc5f29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5611064dc67a <unknown>
E       #1 0x561105f5b566 <unknown>
E       #2 0x561105f96b4c <unknown>
E       #3 0x561105f927c4 <unknown>
E       #4 0x561105fe1bd3 <unknown>
E       #5 0x561105fe1286 <unknown>
E       #6 0x561105fd3403 <unknown>
E       #7 0x561105f9fb02 <unknown>
E       #8 0x561105fa07c1 <unknown>
E       #9 0x5611064a0448 <unknown>
E       #10 0x5611064a42af <unknown>
E       #11 0x5611064878d9 <unknown>
E       #12 0x5611064a4e55 <unknown>
E       #13 0x56110646d13f <unknown>
E       #14 0x5611064c94b8 <unknown>
E       #15 0x5611064c9693 <unknown>
E       #16 0x5611064db613 <unknown>
E       #17 0x7f6bc5e9caa4 <unknown>
E       #18 0x7f6bc5f29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5611064dc67a <unknown>
E           #1 0x561105f5b566 <unknown>
E           #2 0x561105f96b4c <unknown>
E           #3 0x561105f927c4 <unknown>
E           #4 0x561105fe1bd3 <unknown>
E           #5 0x561105fe1286 <unknown>
E           #6 0x561105fd3403 <unknown>
E           #7 0x561105f9fb02 <unknown>
E           #8 0x561105fa07c1 <unknown>
E           #9 0x5611064a0448 <unknown>
E           #10 0x5611064a42af <unknown>
E           #11 0x5611064878d9 <unknown>
E           #12 0x5611064a4e55 <unknown>
E           #13 0x56110646d13f <unknown>
E           #14 0x5611064c94b8 <unknown>
E           #15 0x5611064c9693 <unknown>
E           #16 0x5611064db613 <unknown>
E           #17 0x7f6bc5e9caa4 <unknown>
E           #18 0x7f6bc5f29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:16,214 - INFO - Starting test with Chrome browser
2025-10-18 03:44:16,214 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:16,278 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:16,312 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:16,350 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:17,438 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5611064dc67a <unknown>
#1 0x561105f5b566 <unknown>
#2 0x561105f96b4c <unknown>
#3 0x561105f927c4 <unknown>
#4 0x561105fe1bd3 <unknown>
#5 0x561105fe1286 <unknown>
#6 0x561105fd3403 <unknown>
#7 0x561105f9fb02 <unknown>
#8 0x561105fa07c1 <unknown>
#9 0x5611064a0448 <unknown>
#10 0x5611064a42af <unknown>
#11 0x5611064878d9 <unknown>
#12 0x5611064a4e55 <unknown>
#13 0x56110646d13f <unknown>
#14 0x5611064c94b8 <unknown>
#15 0x5611064c9693 <unknown>
#16 0x5611064db613 <unknown>
#17 0x7f6bc5e9caa4 <unknown>
#18 0x7f6bc5f29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5611064dc67a <unknown>
#1 0x561105f5b566 <unknown>
#2 0x561105f96b4c <unknown>
#3 0x561105f927c4 <unknown>
#4 0x561105fe1bd3 <unknown>
#5 0x561105fe1286 <unknown>
#6 0x561105fd3403 <unknown>
#7 0x561105f9fb02 <unknown>
#8 0x561105fa07c1 <unknown>
#9 0x5611064a0448 <unknown>
#10 0x5611064a42af <unknown>
#11 0x5611064878d9 <unknown>
#12 0x5611064a4e55 <unknown>
#13 0x56110646d13f <unknown>
#14 0x5611064c94b8 <unknown>
#15 0x5611064c9693 <unknown>
#16 0x5611064db613 <unknown>
#17 0x7f6bc5e9caa4 <unknown>
#18 0x7f6bc5f29c6c <unknown>
_______________ ERROR at setup of test_blank_password_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24238e350>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24238e650>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24238e350>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24238e650>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff24238eb50>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24238e350>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff24238ea50>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55ab76dcb613 \\u003Cunknown>\\n#17 0x7fa76c29caa4 \\u003Cunknown>\\n#18 0x7fa76c329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55ab76dcc67a <unknown>
E       #1 0x55ab7684b566 <unknown>
E       #2 0x55ab76886b4c <unknown>
E       #3 0x55ab768827c4 <unknown>
E       #4 0x55ab768d1bd3 <unknown>
E       #5 0x55ab768d1286 <unknown>
E       #6 0x55ab768c3403 <unknown>
E       #7 0x55ab7688fb02 <unknown>
E       #8 0x55ab768907c1 <unknown>
E       #9 0x55ab76d90448 <unknown>
E       #10 0x55ab76d942af <unknown>
E       #11 0x55ab76d778d9 <unknown>
E       #12 0x55ab76d94e55 <unknown>
E       #13 0x55ab76d5d13f <unknown>
E       #14 0x55ab76db94b8 <unknown>
E       #15 0x55ab76db9693 <unknown>
E       #16 0x55ab76dcb613 <unknown>
E       #17 0x7fa76c29caa4 <unknown>
E       #18 0x7fa76c329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55ab76dcc67a <unknown>
E           #1 0x55ab7684b566 <unknown>
E           #2 0x55ab76886b4c <unknown>
E           #3 0x55ab768827c4 <unknown>
E           #4 0x55ab768d1bd3 <unknown>
E           #5 0x55ab768d1286 <unknown>
E           #6 0x55ab768c3403 <unknown>
E           #7 0x55ab7688fb02 <unknown>
E           #8 0x55ab768907c1 <unknown>
E           #9 0x55ab76d90448 <unknown>
E           #10 0x55ab76d942af <unknown>
E           #11 0x55ab76d778d9 <unknown>
E           #12 0x55ab76d94e55 <unknown>
E           #13 0x55ab76d5d13f <unknown>
E           #14 0x55ab76db94b8 <unknown>
E           #15 0x55ab76db9693 <unknown>
E           #16 0x55ab76dcb613 <unknown>
E           #17 0x7fa76c29caa4 <unknown>
E           #18 0x7fa76c329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:17,477 - INFO - Starting test with Chrome browser
2025-10-18 03:44:17,478 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:17,543 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:17,584 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:17,615 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:18,703 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ab76dcc67a <unknown>
#1 0x55ab7684b566 <unknown>
#2 0x55ab76886b4c <unknown>
#3 0x55ab768827c4 <unknown>
#4 0x55ab768d1bd3 <unknown>
#5 0x55ab768d1286 <unknown>
#6 0x55ab768c3403 <unknown>
#7 0x55ab7688fb02 <unknown>
#8 0x55ab768907c1 <unknown>
#9 0x55ab76d90448 <unknown>
#10 0x55ab76d942af <unknown>
#11 0x55ab76d778d9 <unknown>
#12 0x55ab76d94e55 <unknown>
#13 0x55ab76d5d13f <unknown>
#14 0x55ab76db94b8 <unknown>
#15 0x55ab76db9693 <unknown>
#16 0x55ab76dcb613 <unknown>
#17 0x7fa76c29caa4 <unknown>
#18 0x7fa76c329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55ab76dcc67a <unknown>
#1 0x55ab7684b566 <unknown>
#2 0x55ab76886b4c <unknown>
#3 0x55ab768827c4 <unknown>
#4 0x55ab768d1bd3 <unknown>
#5 0x55ab768d1286 <unknown>
#6 0x55ab768c3403 <unknown>
#7 0x55ab7688fb02 <unknown>
#8 0x55ab768907c1 <unknown>
#9 0x55ab76d90448 <unknown>
#10 0x55ab76d942af <unknown>
#11 0x55ab76d778d9 <unknown>
#12 0x55ab76d94e55 <unknown>
#13 0x55ab76d5d13f <unknown>
#14 0x55ab76db94b8 <unknown>
#15 0x55ab76db9693 <unknown>
#16 0x55ab76dcb613 <unknown>
#17 0x7fa76c29caa4 <unknown>
#18 0x7fa76c329c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username0] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423a7980>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2423a5a90>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423a7980>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2423a5a90>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff2423a6120>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423a7980>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2423a4140>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x558df3a59613 \\u003Cunknown>\\n#17 0x7fea6489caa4 \\u003Cunknown>\\n#18 0x7fea64929c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x558df3a5a67a <unknown>
E       #1 0x558df34d9566 <unknown>
E       #2 0x558df3514b4c <unknown>
E       #3 0x558df35107c4 <unknown>
E       #4 0x558df355fbd3 <unknown>
E       #5 0x558df355f286 <unknown>
E       #6 0x558df3551403 <unknown>
E       #7 0x558df351db02 <unknown>
E       #8 0x558df351e7c1 <unknown>
E       #9 0x558df3a1e448 <unknown>
E       #10 0x558df3a222af <unknown>
E       #11 0x558df3a058d9 <unknown>
E       #12 0x558df3a22e55 <unknown>
E       #13 0x558df39eb13f <unknown>
E       #14 0x558df3a474b8 <unknown>
E       #15 0x558df3a47693 <unknown>
E       #16 0x558df3a59613 <unknown>
E       #17 0x7fea6489caa4 <unknown>
E       #18 0x7fea64929c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x558df3a5a67a <unknown>
E           #1 0x558df34d9566 <unknown>
E           #2 0x558df3514b4c <unknown>
E           #3 0x558df35107c4 <unknown>
E           #4 0x558df355fbd3 <unknown>
E           #5 0x558df355f286 <unknown>
E           #6 0x558df3551403 <unknown>
E           #7 0x558df351db02 <unknown>
E           #8 0x558df351e7c1 <unknown>
E           #9 0x558df3a1e448 <unknown>
E           #10 0x558df3a222af <unknown>
E           #11 0x558df3a058d9 <unknown>
E           #12 0x558df3a22e55 <unknown>
E           #13 0x558df39eb13f <unknown>
E           #14 0x558df3a474b8 <unknown>
E           #15 0x558df3a47693 <unknown>
E           #16 0x558df3a59613 <unknown>
E           #17 0x7fea6489caa4 <unknown>
E           #18 0x7fea64929c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:18,745 - INFO - Starting test with Chrome browser
2025-10-18 03:44:18,745 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:18,810 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:18,845 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:18,878 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:19,966 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x558df3a5a67a <unknown>
#1 0x558df34d9566 <unknown>
#2 0x558df3514b4c <unknown>
#3 0x558df35107c4 <unknown>
#4 0x558df355fbd3 <unknown>
#5 0x558df355f286 <unknown>
#6 0x558df3551403 <unknown>
#7 0x558df351db02 <unknown>
#8 0x558df351e7c1 <unknown>
#9 0x558df3a1e448 <unknown>
#10 0x558df3a222af <unknown>
#11 0x558df3a058d9 <unknown>
#12 0x558df3a22e55 <unknown>
#13 0x558df39eb13f <unknown>
#14 0x558df3a474b8 <unknown>
#15 0x558df3a47693 <unknown>
#16 0x558df3a59613 <unknown>
#17 0x7fea6489caa4 <unknown>
#18 0x7fea64929c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x558df3a5a67a <unknown>
#1 0x558df34d9566 <unknown>
#2 0x558df3514b4c <unknown>
#3 0x558df35107c4 <unknown>
#4 0x558df355fbd3 <unknown>
#5 0x558df355f286 <unknown>
#6 0x558df3551403 <unknown>
#7 0x558df351db02 <unknown>
#8 0x558df351e7c1 <unknown>
#9 0x558df3a1e448 <unknown>
#10 0x558df3a222af <unknown>
#11 0x558df3a058d9 <unknown>
#12 0x558df3a22e55 <unknown>
#13 0x558df39eb13f <unknown>
#14 0x558df3a474b8 <unknown>
#15 0x558df3a47693 <unknown>
#16 0x558df3a59613 <unknown>
#17 0x7fea6489caa4 <unknown>
#18 0x7fea64929c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username1] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423a7c50>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2423a73e0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423a7c50>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2423a73e0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff2423a7e30>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423a7c50>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff244298050>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55bb7fcd5613 \\u003Cunknown>\\n#17 0x7f7975e9caa4 \\u003Cunknown>\\n#18 0x7f7975f29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55bb7fcd667a <unknown>
E       #1 0x55bb7f755566 <unknown>
E       #2 0x55bb7f790b4c <unknown>
E       #3 0x55bb7f78c7c4 <unknown>
E       #4 0x55bb7f7dbbd3 <unknown>
E       #5 0x55bb7f7db286 <unknown>
E       #6 0x55bb7f7cd403 <unknown>
E       #7 0x55bb7f799b02 <unknown>
E       #8 0x55bb7f79a7c1 <unknown>
E       #9 0x55bb7fc9a448 <unknown>
E       #10 0x55bb7fc9e2af <unknown>
E       #11 0x55bb7fc818d9 <unknown>
E       #12 0x55bb7fc9ee55 <unknown>
E       #13 0x55bb7fc6713f <unknown>
E       #14 0x55bb7fcc34b8 <unknown>
E       #15 0x55bb7fcc3693 <unknown>
E       #16 0x55bb7fcd5613 <unknown>
E       #17 0x7f7975e9caa4 <unknown>
E       #18 0x7f7975f29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55bb7fcd667a <unknown>
E           #1 0x55bb7f755566 <unknown>
E           #2 0x55bb7f790b4c <unknown>
E           #3 0x55bb7f78c7c4 <unknown>
E           #4 0x55bb7f7dbbd3 <unknown>
E           #5 0x55bb7f7db286 <unknown>
E           #6 0x55bb7f7cd403 <unknown>
E           #7 0x55bb7f799b02 <unknown>
E           #8 0x55bb7f79a7c1 <unknown>
E           #9 0x55bb7fc9a448 <unknown>
E           #10 0x55bb7fc9e2af <unknown>
E           #11 0x55bb7fc818d9 <unknown>
E           #12 0x55bb7fc9ee55 <unknown>
E           #13 0x55bb7fc6713f <unknown>
E           #14 0x55bb7fcc34b8 <unknown>
E           #15 0x55bb7fcc3693 <unknown>
E           #16 0x55bb7fcd5613 <unknown>
E           #17 0x7f7975e9caa4 <unknown>
E           #18 0x7f7975f29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:20,006 - INFO - Starting test with Chrome browser
2025-10-18 03:44:20,006 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:20,071 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:20,105 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:20,137 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:21,226 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55bb7fcd667a <unknown>
#1 0x55bb7f755566 <unknown>
#2 0x55bb7f790b4c <unknown>
#3 0x55bb7f78c7c4 <unknown>
#4 0x55bb7f7dbbd3 <unknown>
#5 0x55bb7f7db286 <unknown>
#6 0x55bb7f7cd403 <unknown>
#7 0x55bb7f799b02 <unknown>
#8 0x55bb7f79a7c1 <unknown>
#9 0x55bb7fc9a448 <unknown>
#10 0x55bb7fc9e2af <unknown>
#11 0x55bb7fc818d9 <unknown>
#12 0x55bb7fc9ee55 <unknown>
#13 0x55bb7fc6713f <unknown>
#14 0x55bb7fcc34b8 <unknown>
#15 0x55bb7fcc3693 <unknown>
#16 0x55bb7fcd5613 <unknown>
#17 0x7f7975e9caa4 <unknown>
#18 0x7f7975f29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55bb7fcd667a <unknown>
#1 0x55bb7f755566 <unknown>
#2 0x55bb7f790b4c <unknown>
#3 0x55bb7f78c7c4 <unknown>
#4 0x55bb7f7dbbd3 <unknown>
#5 0x55bb7f7db286 <unknown>
#6 0x55bb7f7cd403 <unknown>
#7 0x55bb7f799b02 <unknown>
#8 0x55bb7f79a7c1 <unknown>
#9 0x55bb7fc9a448 <unknown>
#10 0x55bb7fc9e2af <unknown>
#11 0x55bb7fc818d9 <unknown>
#12 0x55bb7fc9ee55 <unknown>
#13 0x55bb7fc6713f <unknown>
#14 0x55bb7fcc34b8 <unknown>
#15 0x55bb7fcc3693 <unknown>
#16 0x55bb7fcd5613 <unknown>
#17 0x7f7975e9caa4 <unknown>
#18 0x7f7975f29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username2] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423b1c50>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2423b19b0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423b1c50>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2423b19b0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff2423b1390>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2423b1c50>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2423b1d30>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55e7a35a4613 \\u003Cunknown>\\n#17 0x7f6fd129caa4 \\u003Cunknown>\\n#18 0x7f6fd1329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55e7a35a567a <unknown>
E       #1 0x55e7a3024566 <unknown>
E       #2 0x55e7a305fb4c <unknown>
E       #3 0x55e7a305b7c4 <unknown>
E       #4 0x55e7a30aabd3 <unknown>
E       #5 0x55e7a30aa286 <unknown>
E       #6 0x55e7a309c403 <unknown>
E       #7 0x55e7a3068b02 <unknown>
E       #8 0x55e7a30697c1 <unknown>
E       #9 0x55e7a3569448 <unknown>
E       #10 0x55e7a356d2af <unknown>
E       #11 0x55e7a35508d9 <unknown>
E       #12 0x55e7a356de55 <unknown>
E       #13 0x55e7a353613f <unknown>
E       #14 0x55e7a35924b8 <unknown>
E       #15 0x55e7a3592693 <unknown>
E       #16 0x55e7a35a4613 <unknown>
E       #17 0x7f6fd129caa4 <unknown>
E       #18 0x7f6fd1329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55e7a35a567a <unknown>
E           #1 0x55e7a3024566 <unknown>
E           #2 0x55e7a305fb4c <unknown>
E           #3 0x55e7a305b7c4 <unknown>
E           #4 0x55e7a30aabd3 <unknown>
E           #5 0x55e7a30aa286 <unknown>
E           #6 0x55e7a309c403 <unknown>
E           #7 0x55e7a3068b02 <unknown>
E           #8 0x55e7a30697c1 <unknown>
E           #9 0x55e7a3569448 <unknown>
E           #10 0x55e7a356d2af <unknown>
E           #11 0x55e7a35508d9 <unknown>
E           #12 0x55e7a356de55 <unknown>
E           #13 0x55e7a353613f <unknown>
E           #14 0x55e7a35924b8 <unknown>
E           #15 0x55e7a3592693 <unknown>
E           #16 0x55e7a35a4613 <unknown>
E           #17 0x7f6fd129caa4 <unknown>
E           #18 0x7f6fd1329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:21,268 - INFO - Starting test with Chrome browser
2025-10-18 03:44:21,268 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:21,334 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:21,367 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:21,399 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:22,487 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55e7a35a567a <unknown>
#1 0x55e7a3024566 <unknown>
#2 0x55e7a305fb4c <unknown>
#3 0x55e7a305b7c4 <unknown>
#4 0x55e7a30aabd3 <unknown>
#5 0x55e7a30aa286 <unknown>
#6 0x55e7a309c403 <unknown>
#7 0x55e7a3068b02 <unknown>
#8 0x55e7a30697c1 <unknown>
#9 0x55e7a3569448 <unknown>
#10 0x55e7a356d2af <unknown>
#11 0x55e7a35508d9 <unknown>
#12 0x55e7a356de55 <unknown>
#13 0x55e7a353613f <unknown>
#14 0x55e7a35924b8 <unknown>
#15 0x55e7a3592693 <unknown>
#16 0x55e7a35a4613 <unknown>
#17 0x7f6fd129caa4 <unknown>
#18 0x7f6fd1329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55e7a35a567a <unknown>
#1 0x55e7a3024566 <unknown>
#2 0x55e7a305fb4c <unknown>
#3 0x55e7a305b7c4 <unknown>
#4 0x55e7a30aabd3 <unknown>
#5 0x55e7a30aa286 <unknown>
#6 0x55e7a309c403 <unknown>
#7 0x55e7a3068b02 <unknown>
#8 0x55e7a30697c1 <unknown>
#9 0x55e7a3569448 <unknown>
#10 0x55e7a356d2af <unknown>
#11 0x55e7a35508d9 <unknown>
#12 0x55e7a356de55 <unknown>
#13 0x55e7a353613f <unknown>
#14 0x55e7a35924b8 <unknown>
#15 0x55e7a3592693 <unknown>
#16 0x55e7a35a4613 <unknown>
#17 0x7f6fd129caa4 <unknown>
#18 0x7f6fd1329c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username3] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24429c750>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24429c910>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24429c750>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff24429c910>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff24429cad0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff24429c750>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff24429cf30>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x555bf43d9613 \\u003Cunknown>\\n#17 0x7fce95c9caa4 \\u003Cunknown>\\n#18 0x7fce95d29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x555bf43da67a <unknown>
E       #1 0x555bf3e59566 <unknown>
E       #2 0x555bf3e94b4c <unknown>
E       #3 0x555bf3e907c4 <unknown>
E       #4 0x555bf3edfbd3 <unknown>
E       #5 0x555bf3edf286 <unknown>
E       #6 0x555bf3ed1403 <unknown>
E       #7 0x555bf3e9db02 <unknown>
E       #8 0x555bf3e9e7c1 <unknown>
E       #9 0x555bf439e448 <unknown>
E       #10 0x555bf43a22af <unknown>
E       #11 0x555bf43858d9 <unknown>
E       #12 0x555bf43a2e55 <unknown>
E       #13 0x555bf436b13f <unknown>
E       #14 0x555bf43c74b8 <unknown>
E       #15 0x555bf43c7693 <unknown>
E       #16 0x555bf43d9613 <unknown>
E       #17 0x7fce95c9caa4 <unknown>
E       #18 0x7fce95d29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x555bf43da67a <unknown>
E           #1 0x555bf3e59566 <unknown>
E           #2 0x555bf3e94b4c <unknown>
E           #3 0x555bf3e907c4 <unknown>
E           #4 0x555bf3edfbd3 <unknown>
E           #5 0x555bf3edf286 <unknown>
E           #6 0x555bf3ed1403 <unknown>
E           #7 0x555bf3e9db02 <unknown>
E           #8 0x555bf3e9e7c1 <unknown>
E           #9 0x555bf439e448 <unknown>
E           #10 0x555bf43a22af <unknown>
E           #11 0x555bf43858d9 <unknown>
E           #12 0x555bf43a2e55 <unknown>
E           #13 0x555bf436b13f <unknown>
E           #14 0x555bf43c74b8 <unknown>
E           #15 0x555bf43c7693 <unknown>
E           #16 0x555bf43d9613 <unknown>
E           #17 0x7fce95c9caa4 <unknown>
E           #18 0x7fce95d29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:22,527 - INFO - Starting test with Chrome browser
2025-10-18 03:44:22,527 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:22,595 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:22,628 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:22,662 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:23,750 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x555bf43da67a <unknown>
#1 0x555bf3e59566 <unknown>
#2 0x555bf3e94b4c <unknown>
#3 0x555bf3e907c4 <unknown>
#4 0x555bf3edfbd3 <unknown>
#5 0x555bf3edf286 <unknown>
#6 0x555bf3ed1403 <unknown>
#7 0x555bf3e9db02 <unknown>
#8 0x555bf3e9e7c1 <unknown>
#9 0x555bf439e448 <unknown>
#10 0x555bf43a22af <unknown>
#11 0x555bf43858d9 <unknown>
#12 0x555bf43a2e55 <unknown>
#13 0x555bf436b13f <unknown>
#14 0x555bf43c74b8 <unknown>
#15 0x555bf43c7693 <unknown>
#16 0x555bf43d9613 <unknown>
#17 0x7fce95c9caa4 <unknown>
#18 0x7fce95d29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x555bf43da67a <unknown>
#1 0x555bf3e59566 <unknown>
#2 0x555bf3e94b4c <unknown>
#3 0x555bf3e907c4 <unknown>
#4 0x555bf3edfbd3 <unknown>
#5 0x555bf3edf286 <unknown>
#6 0x555bf3ed1403 <unknown>
#7 0x555bf3e9db02 <unknown>
#8 0x555bf3e9e7c1 <unknown>
#9 0x555bf439e448 <unknown>
#10 0x555bf43a22af <unknown>
#11 0x555bf43858d9 <unknown>
#12 0x555bf43a2e55 <unknown>
#13 0x555bf436b13f <unknown>
#14 0x555bf43c74b8 <unknown>
#15 0x555bf43c7693 <unknown>
#16 0x555bf43d9613 <unknown>
#17 0x7fce95c9caa4 <unknown>
#18 0x7fce95d29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username4] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2441ff110>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2441ff040>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2441ff110>
service = <selenium.webdriver.chrome.service.Service object at 0x7ff2441ff040>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7ff2441fdcc0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7ff2441ff110>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7ff2441fc390>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x558fecdf3613 \\u003Cunknown>\\n#17 0x7f1bb4a9caa4 \\u003Cunknown>\\n#18 0x7f1bb4b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x558fecdf467a <unknown>
E       #1 0x558fec873566 <unknown>
E       #2 0x558fec8aeb4c <unknown>
E       #3 0x558fec8aa7c4 <unknown>
E       #4 0x558fec8f9bd3 <unknown>
E       #5 0x558fec8f9286 <unknown>
E       #6 0x558fec8eb403 <unknown>
E       #7 0x558fec8b7b02 <unknown>
E       #8 0x558fec8b87c1 <unknown>
E       #9 0x558fecdb8448 <unknown>
E       #10 0x558fecdbc2af <unknown>
E       #11 0x558fecd9f8d9 <unknown>
E       #12 0x558fecdbce55 <unknown>
E       #13 0x558fecd8513f <unknown>
E       #14 0x558fecde14b8 <unknown>
E       #15 0x558fecde1693 <unknown>
E       #16 0x558fecdf3613 <unknown>
E       #17 0x7f1bb4a9caa4 <unknown>
E       #18 0x7f1bb4b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x558fecdf467a <unknown>
E           #1 0x558fec873566 <unknown>
E           #2 0x558fec8aeb4c <unknown>
E           #3 0x558fec8aa7c4 <unknown>
E           #4 0x558fec8f9bd3 <unknown>
E           #5 0x558fec8f9286 <unknown>
E           #6 0x558fec8eb403 <unknown>
E           #7 0x558fec8b7b02 <unknown>
E           #8 0x558fec8b87c1 <unknown>
E           #9 0x558fecdb8448 <unknown>
E           #10 0x558fecdbc2af <unknown>
E           #11 0x558fecd9f8d9 <unknown>
E           #12 0x558fecdbce55 <unknown>
E           #13 0x558fecd8513f <unknown>
E           #14 0x558fecde14b8 <unknown>
E           #15 0x558fecde1693 <unknown>
E           #16 0x558fecdf3613 <unknown>
E           #17 0x7f1bb4a9caa4 <unknown>
E           #18 0x7f1bb4b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-18 03:44:23,791 - INFO - Starting test with Chrome browser
2025-10-18 03:44:23,791 - INFO - ====== WebDriver manager ======
2025-10-18 03:44:23,856 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:23,890 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-18 03:44:23,922 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-18 03:44:25,010 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x558fecdf467a <unknown>
#1 0x558fec873566 <unknown>
#2 0x558fec8aeb4c <unknown>
#3 0x558fec8aa7c4 <unknown>
#4 0x558fec8f9bd3 <unknown>
#5 0x558fec8f9286 <unknown>
#6 0x558fec8eb403 <unknown>
#7 0x558fec8b7b02 <unknown>
#8 0x558fec8b87c1 <unknown>
#9 0x558fecdb8448 <unknown>
#10 0x558fecdbc2af <unknown>
#11 0x558fecd9f8d9 <unknown>
#12 0x558fecdbce55 <unknown>
#13 0x558fecd8513f <unknown>
#14 0x558fecde14b8 <unknown>
#15 0x558fecde1693 <unknown>
#16 0x558fecdf3613 <unknown>
#17 0x7f1bb4a9caa4 <unknown>
#18 0x7f1bb4b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x558fecdf467a <unknown>
#1 0x558fec873566 <unknown>
#2 0x558fec8aeb4c <unknown>
#3 0x558fec8aa7c4 <unknown>
#4 0x558fec8f9bd3 <unknown>
#5 0x558fec8f9286 <unknown>
#6 0x558fec8eb403 <unknown>
#7 0x558fec8b7b02 <unknown>
#8 0x558fec8b87c1 <unknown>
#9 0x558fecdb8448 <unknown>
#10 0x558fecdbc2af <unknown>
#11 0x558fecd9f8d9 <unknown>
#12 0x558fecdbce55 <unknown>
#13 0x558fecd8513f <unknown>
#14 0x558fecde14b8 <unknown>
#15 0x558fecde1693 <unknown>
#16 0x558fecdf3613 <unknown>
#17 0x7f1bb4a9caa4 <unknown>
#18 0x7f1bb4b29c6c <unknown>
- Generated html report: file:///home/runner/work/Mocha_accounting/Mocha_accounting/C%3A%5CUsers%5CTaurus13%5CPycharmProjects%5CPythonProject%5Creports/20251018_034403/report.html -
============================= 15 errors in 21.65s ==============================
=== LOGIN TESTS COMPLETED ===
Exit Code: 1
