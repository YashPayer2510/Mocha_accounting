=== LOGIN TESTS STARTED: 2025-10-19 03:56:23 ===
============================= test session starts ==============================
platform linux -- Python 3.13.8, pytest-8.3.5, pluggy-1.6.0 -- /opt/hostedtoolcache/Python/3.13.8/x64/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.13.8', 'Platform': 'Linux-6.14.0-1012-azure-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.6.0'}, 'Plugins': {'metadata': '3.1.1', 'xdist': '3.8.0', 'rerunfailures': '16.1', 'Faker': '37.11.0', 'html': '4.1.1'}, 'CI': 'true', 'JAVA_HOME': '/usr/lib/jvm/temurin-17-jdk-amd64'}
rootdir: /home/runner/work/Mocha_accounting/Mocha_accounting
plugins: metadata-3.1.1, xdist-3.8.0, rerunfailures-16.1, Faker-37.11.0, html-4.1.1
collecting ... collected 15 items

tests/test_signup_login/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] ERROR [  6%]
tests/test_signup_login/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] ERROR [ 13%]
tests/test_signup_login/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ERROR [ 20%]
tests/test_signup_login/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] ERROR [ 26%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username0] ERROR [ 33%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username1] ERROR [ 40%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username2] ERROR [ 46%]
tests/test_signup_login/test_login.py::test_invalid_email_login[username3] ERROR [ 53%]
tests/test_signup_login/test_login.py::test_blank_username_validation ERROR [ 60%]
tests/test_signup_login/test_login.py::test_blank_password_validation ERROR [ 66%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username0] ERROR [ 73%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username1] ERROR [ 80%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username2] ERROR [ 86%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username3] ERROR [ 93%]
tests/test_signup_login/test_login.py::test_invalid_email_validation[username4] ERROR [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae74980>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae74ad0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae74980>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae74ad0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155ae75010>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae74980>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155ae74d70>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x558d223fa613 \\u003Cunknown>\\n#17 0x7f34ffc9caa4 \\u003Cunknown>\\n#18 0x7f34ffd29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x558d223fb67a <unknown>
E       #1 0x558d21e7a566 <unknown>
E       #2 0x558d21eb5b4c <unknown>
E       #3 0x558d21eb17c4 <unknown>
E       #4 0x558d21f00bd3 <unknown>
E       #5 0x558d21f00286 <unknown>
E       #6 0x558d21ef2403 <unknown>
E       #7 0x558d21ebeb02 <unknown>
E       #8 0x558d21ebf7c1 <unknown>
E       #9 0x558d223bf448 <unknown>
E       #10 0x558d223c32af <unknown>
E       #11 0x558d223a68d9 <unknown>
E       #12 0x558d223c3e55 <unknown>
E       #13 0x558d2238c13f <unknown>
E       #14 0x558d223e84b8 <unknown>
E       #15 0x558d223e8693 <unknown>
E       #16 0x558d223fa613 <unknown>
E       #17 0x7f34ffc9caa4 <unknown>
E       #18 0x7f34ffd29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x558d223fb67a <unknown>
E           #1 0x558d21e7a566 <unknown>
E           #2 0x558d21eb5b4c <unknown>
E           #3 0x558d21eb17c4 <unknown>
E           #4 0x558d21f00bd3 <unknown>
E           #5 0x558d21f00286 <unknown>
E           #6 0x558d21ef2403 <unknown>
E           #7 0x558d21ebeb02 <unknown>
E           #8 0x558d21ebf7c1 <unknown>
E           #9 0x558d223bf448 <unknown>
E           #10 0x558d223c32af <unknown>
E           #11 0x558d223a68d9 <unknown>
E           #12 0x558d223c3e55 <unknown>
E           #13 0x558d2238c13f <unknown>
E           #14 0x558d223e84b8 <unknown>
E           #15 0x558d223e8693 <unknown>
E           #16 0x558d223fa613 <unknown>
E           #17 0x7f34ffc9caa4 <unknown>
E           #18 0x7f34ffd29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:25,333 - INFO - Starting test with Chrome browser
2025-10-19 03:56:25,333 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:25,398 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:25,436 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:25,474 - INFO - There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
2025-10-19 03:56:25,474 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:25,580 - INFO - WebDriver version 141.0.7390.78 selected
2025-10-19 03:56:25,584 - INFO - Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-19 03:56:25,584 - INFO - About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
2025-10-19 03:56:25,626 - INFO - Driver downloading response is 200
2025-10-19 03:56:25,679 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:25,821 - INFO - Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
2025-10-19 03:56:29,066 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x558d223fb67a <unknown>
#1 0x558d21e7a566 <unknown>
#2 0x558d21eb5b4c <unknown>
#3 0x558d21eb17c4 <unknown>
#4 0x558d21f00bd3 <unknown>
#5 0x558d21f00286 <unknown>
#6 0x558d21ef2403 <unknown>
#7 0x558d21ebeb02 <unknown>
#8 0x558d21ebf7c1 <unknown>
#9 0x558d223bf448 <unknown>
#10 0x558d223c32af <unknown>
#11 0x558d223a68d9 <unknown>
#12 0x558d223c3e55 <unknown>
#13 0x558d2238c13f <unknown>
#14 0x558d223e84b8 <unknown>
#15 0x558d223e8693 <unknown>
#16 0x558d223fa613 <unknown>
#17 0x7f34ffc9caa4 <unknown>
#18 0x7f34ffd29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 There is no [linux64] chromedriver "141.0.7390.78" for browser google-chrome "141.0.7390" in cache
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 WebDriver version 141.0.7390.78 selected
INFO     WDM:logger.py:11 Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/141.0.7390.78/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 Driver downloading response is 200
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78]
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x558d223fb67a <unknown>
#1 0x558d21e7a566 <unknown>
#2 0x558d21eb5b4c <unknown>
#3 0x558d21eb17c4 <unknown>
#4 0x558d21f00bd3 <unknown>
#5 0x558d21f00286 <unknown>
#6 0x558d21ef2403 <unknown>
#7 0x558d21ebeb02 <unknown>
#8 0x558d21ebf7c1 <unknown>
#9 0x558d223bf448 <unknown>
#10 0x558d223c32af <unknown>
#11 0x558d223a68d9 <unknown>
#12 0x558d223c3e55 <unknown>
#13 0x558d2238c13f <unknown>
#14 0x558d223e84b8 <unknown>
#15 0x558d223e8693 <unknown>
#16 0x558d223fa613 <unknown>
#17 0x7f34ffc9caa4 <unknown>
#18 0x7f34ffd29c6c <unknown>
____ ERROR at setup of test_valid_login[samatakamble9@gmail.com-Samata@16] _____

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155adee850>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155adeed50>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155adee850>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155adeed50>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155adef110>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155adee850>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155adeefd0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5562880f5613 \\u003Cunknown>\\n#17 0x7efd01a9caa4 \\u003Cunknown>\\n#18 0x7efd01b29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5562880f667a <unknown>
E       #1 0x556287b75566 <unknown>
E       #2 0x556287bb0b4c <unknown>
E       #3 0x556287bac7c4 <unknown>
E       #4 0x556287bfbbd3 <unknown>
E       #5 0x556287bfb286 <unknown>
E       #6 0x556287bed403 <unknown>
E       #7 0x556287bb9b02 <unknown>
E       #8 0x556287bba7c1 <unknown>
E       #9 0x5562880ba448 <unknown>
E       #10 0x5562880be2af <unknown>
E       #11 0x5562880a18d9 <unknown>
E       #12 0x5562880bee55 <unknown>
E       #13 0x55628808713f <unknown>
E       #14 0x5562880e34b8 <unknown>
E       #15 0x5562880e3693 <unknown>
E       #16 0x5562880f5613 <unknown>
E       #17 0x7efd01a9caa4 <unknown>
E       #18 0x7efd01b29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[samatakamble9@gmail.com-Samata@16]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5562880f667a <unknown>
E           #1 0x556287b75566 <unknown>
E           #2 0x556287bb0b4c <unknown>
E           #3 0x556287bac7c4 <unknown>
E           #4 0x556287bfbbd3 <unknown>
E           #5 0x556287bfb286 <unknown>
E           #6 0x556287bed403 <unknown>
E           #7 0x556287bb9b02 <unknown>
E           #8 0x556287bba7c1 <unknown>
E           #9 0x5562880ba448 <unknown>
E           #10 0x5562880be2af <unknown>
E           #11 0x5562880a18d9 <unknown>
E           #12 0x5562880bee55 <unknown>
E           #13 0x55628808713f <unknown>
E           #14 0x5562880e34b8 <unknown>
E           #15 0x5562880e3693 <unknown>
E           #16 0x5562880f5613 <unknown>
E           #17 0x7efd01a9caa4 <unknown>
E           #18 0x7efd01b29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:29,133 - INFO - Starting test with Chrome browser
2025-10-19 03:56:29,133 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:29,199 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:29,235 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:29,308 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:30,396 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5562880f667a <unknown>
#1 0x556287b75566 <unknown>
#2 0x556287bb0b4c <unknown>
#3 0x556287bac7c4 <unknown>
#4 0x556287bfbbd3 <unknown>
#5 0x556287bfb286 <unknown>
#6 0x556287bed403 <unknown>
#7 0x556287bb9b02 <unknown>
#8 0x556287bba7c1 <unknown>
#9 0x5562880ba448 <unknown>
#10 0x5562880be2af <unknown>
#11 0x5562880a18d9 <unknown>
#12 0x5562880bee55 <unknown>
#13 0x55628808713f <unknown>
#14 0x5562880e34b8 <unknown>
#15 0x5562880e3693 <unknown>
#16 0x5562880f5613 <unknown>
#17 0x7efd01a9caa4 <unknown>
#18 0x7efd01b29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5562880f667a <unknown>
#1 0x556287b75566 <unknown>
#2 0x556287bb0b4c <unknown>
#3 0x556287bac7c4 <unknown>
#4 0x556287bfbbd3 <unknown>
#5 0x556287bfb286 <unknown>
#6 0x556287bed403 <unknown>
#7 0x556287bb9b02 <unknown>
#8 0x556287bba7c1 <unknown>
#9 0x5562880ba448 <unknown>
#10 0x5562880be2af <unknown>
#11 0x5562880a18d9 <unknown>
#12 0x5562880bee55 <unknown>
#13 0x55628808713f <unknown>
#14 0x5562880e34b8 <unknown>
#15 0x5562880e3693 <unknown>
#16 0x5562880f5613 <unknown>
#17 0x7efd01a9caa4 <unknown>
#18 0x7efd01b29c6c <unknown>
__ ERROR at setup of test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ___

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9cf50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ad9ce10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9cf50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ad9ce10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155ad9d450>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9cf50>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155ad9d310>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x556dec540613 \\u003Cunknown>\\n#17 0x7f0cc8e9caa4 \\u003Cunknown>\\n#18 0x7f0cc8f29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x556dec54167a <unknown>
E       #1 0x556debfc0566 <unknown>
E       #2 0x556debffbb4c <unknown>
E       #3 0x556debff77c4 <unknown>
E       #4 0x556dec046bd3 <unknown>
E       #5 0x556dec046286 <unknown>
E       #6 0x556dec038403 <unknown>
E       #7 0x556dec004b02 <unknown>
E       #8 0x556dec0057c1 <unknown>
E       #9 0x556dec505448 <unknown>
E       #10 0x556dec5092af <unknown>
E       #11 0x556dec4ec8d9 <unknown>
E       #12 0x556dec509e55 <unknown>
E       #13 0x556dec4d213f <unknown>
E       #14 0x556dec52e4b8 <unknown>
E       #15 0x556dec52e693 <unknown>
E       #16 0x556dec540613 <unknown>
E       #17 0x7f0cc8e9caa4 <unknown>
E       #18 0x7f0cc8f29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[shubhamdabir07@gmail.com-Shubham@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x556dec54167a <unknown>
E           #1 0x556debfc0566 <unknown>
E           #2 0x556debffbb4c <unknown>
E           #3 0x556debff77c4 <unknown>
E           #4 0x556dec046bd3 <unknown>
E           #5 0x556dec046286 <unknown>
E           #6 0x556dec038403 <unknown>
E           #7 0x556dec004b02 <unknown>
E           #8 0x556dec0057c1 <unknown>
E           #9 0x556dec505448 <unknown>
E           #10 0x556dec5092af <unknown>
E           #11 0x556dec4ec8d9 <unknown>
E           #12 0x556dec509e55 <unknown>
E           #13 0x556dec4d213f <unknown>
E           #14 0x556dec52e4b8 <unknown>
E           #15 0x556dec52e693 <unknown>
E           #16 0x556dec540613 <unknown>
E           #17 0x7f0cc8e9caa4 <unknown>
E           #18 0x7f0cc8f29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:30,435 - INFO - Starting test with Chrome browser
2025-10-19 03:56:30,435 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:30,500 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:30,534 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:30,569 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:31,656 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x556dec54167a <unknown>
#1 0x556debfc0566 <unknown>
#2 0x556debffbb4c <unknown>
#3 0x556debff77c4 <unknown>
#4 0x556dec046bd3 <unknown>
#5 0x556dec046286 <unknown>
#6 0x556dec038403 <unknown>
#7 0x556dec004b02 <unknown>
#8 0x556dec0057c1 <unknown>
#9 0x556dec505448 <unknown>
#10 0x556dec5092af <unknown>
#11 0x556dec4ec8d9 <unknown>
#12 0x556dec509e55 <unknown>
#13 0x556dec4d213f <unknown>
#14 0x556dec52e4b8 <unknown>
#15 0x556dec52e693 <unknown>
#16 0x556dec540613 <unknown>
#17 0x7f0cc8e9caa4 <unknown>
#18 0x7f0cc8f29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x556dec54167a <unknown>
#1 0x556debfc0566 <unknown>
#2 0x556debffbb4c <unknown>
#3 0x556debff77c4 <unknown>
#4 0x556dec046bd3 <unknown>
#5 0x556dec046286 <unknown>
#6 0x556dec038403 <unknown>
#7 0x556dec004b02 <unknown>
#8 0x556dec0057c1 <unknown>
#9 0x556dec505448 <unknown>
#10 0x556dec5092af <unknown>
#11 0x556dec4ec8d9 <unknown>
#12 0x556dec509e55 <unknown>
#13 0x556dec4d213f <unknown>
#14 0x556dec52e4b8 <unknown>
#15 0x556dec52e693 <unknown>
#16 0x556dec540613 <unknown>
#17 0x7f0cc8e9caa4 <unknown>
#18 0x7f0cc8f29c6c <unknown>
_ ERROR at setup of test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] _

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f1559179ba0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f1559178fc0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f1559179ba0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f1559178fc0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155917b100>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f1559179ba0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155917afd0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5616e79f2613 \\u003Cunknown>\\n#17 0x7f26fb29caa4 \\u003Cunknown>\\n#18 0x7f26fb329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5616e79f367a <unknown>
E       #1 0x5616e7472566 <unknown>
E       #2 0x5616e74adb4c <unknown>
E       #3 0x5616e74a97c4 <unknown>
E       #4 0x5616e74f8bd3 <unknown>
E       #5 0x5616e74f8286 <unknown>
E       #6 0x5616e74ea403 <unknown>
E       #7 0x5616e74b6b02 <unknown>
E       #8 0x5616e74b77c1 <unknown>
E       #9 0x5616e79b7448 <unknown>
E       #10 0x5616e79bb2af <unknown>
E       #11 0x5616e799e8d9 <unknown>
E       #12 0x5616e79bbe55 <unknown>
E       #13 0x5616e798413f <unknown>
E       #14 0x5616e79e04b8 <unknown>
E       #15 0x5616e79e0693 <unknown>
E       #16 0x5616e79f2613 <unknown>
E       #17 0x7f26fb29caa4 <unknown>
E       #18 0x7f26fb329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5616e79f367a <unknown>
E           #1 0x5616e7472566 <unknown>
E           #2 0x5616e74adb4c <unknown>
E           #3 0x5616e74a97c4 <unknown>
E           #4 0x5616e74f8bd3 <unknown>
E           #5 0x5616e74f8286 <unknown>
E           #6 0x5616e74ea403 <unknown>
E           #7 0x5616e74b6b02 <unknown>
E           #8 0x5616e74b77c1 <unknown>
E           #9 0x5616e79b7448 <unknown>
E           #10 0x5616e79bb2af <unknown>
E           #11 0x5616e799e8d9 <unknown>
E           #12 0x5616e79bbe55 <unknown>
E           #13 0x5616e798413f <unknown>
E           #14 0x5616e79e04b8 <unknown>
E           #15 0x5616e79e0693 <unknown>
E           #16 0x5616e79f2613 <unknown>
E           #17 0x7f26fb29caa4 <unknown>
E           #18 0x7f26fb329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:31,697 - INFO - Starting test with Chrome browser
2025-10-19 03:56:31,697 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:31,762 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:31,795 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:31,829 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:32,917 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5616e79f367a <unknown>
#1 0x5616e7472566 <unknown>
#2 0x5616e74adb4c <unknown>
#3 0x5616e74a97c4 <unknown>
#4 0x5616e74f8bd3 <unknown>
#5 0x5616e74f8286 <unknown>
#6 0x5616e74ea403 <unknown>
#7 0x5616e74b6b02 <unknown>
#8 0x5616e74b77c1 <unknown>
#9 0x5616e79b7448 <unknown>
#10 0x5616e79bb2af <unknown>
#11 0x5616e799e8d9 <unknown>
#12 0x5616e79bbe55 <unknown>
#13 0x5616e798413f <unknown>
#14 0x5616e79e04b8 <unknown>
#15 0x5616e79e0693 <unknown>
#16 0x5616e79f2613 <unknown>
#17 0x7f26fb29caa4 <unknown>
#18 0x7f26fb329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5616e79f367a <unknown>
#1 0x5616e7472566 <unknown>
#2 0x5616e74adb4c <unknown>
#3 0x5616e74a97c4 <unknown>
#4 0x5616e74f8bd3 <unknown>
#5 0x5616e74f8286 <unknown>
#6 0x5616e74ea403 <unknown>
#7 0x5616e74b6b02 <unknown>
#8 0x5616e74b77c1 <unknown>
#9 0x5616e79b7448 <unknown>
#10 0x5616e79bb2af <unknown>
#11 0x5616e799e8d9 <unknown>
#12 0x5616e79bbe55 <unknown>
#13 0x5616e798413f <unknown>
#14 0x5616e79e04b8 <unknown>
#15 0x5616e79e0693 <unknown>
#16 0x5616e79f2613 <unknown>
#17 0x7f26fb29caa4 <unknown>
#18 0x7f26fb329c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username0] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155917b820>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155917be10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155917b820>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155917be10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155af143e0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155917b820>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155af142b0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55e90d67a613 \\u003Cunknown>\\n#17 0x7f435fc9caa4 \\u003Cunknown>\\n#18 0x7f435fd29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55e90d67b67a <unknown>
E       #1 0x55e90d0fa566 <unknown>
E       #2 0x55e90d135b4c <unknown>
E       #3 0x55e90d1317c4 <unknown>
E       #4 0x55e90d180bd3 <unknown>
E       #5 0x55e90d180286 <unknown>
E       #6 0x55e90d172403 <unknown>
E       #7 0x55e90d13eb02 <unknown>
E       #8 0x55e90d13f7c1 <unknown>
E       #9 0x55e90d63f448 <unknown>
E       #10 0x55e90d6432af <unknown>
E       #11 0x55e90d6268d9 <unknown>
E       #12 0x55e90d643e55 <unknown>
E       #13 0x55e90d60c13f <unknown>
E       #14 0x55e90d6684b8 <unknown>
E       #15 0x55e90d668693 <unknown>
E       #16 0x55e90d67a613 <unknown>
E       #17 0x7f435fc9caa4 <unknown>
E       #18 0x7f435fd29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55e90d67b67a <unknown>
E           #1 0x55e90d0fa566 <unknown>
E           #2 0x55e90d135b4c <unknown>
E           #3 0x55e90d1317c4 <unknown>
E           #4 0x55e90d180bd3 <unknown>
E           #5 0x55e90d180286 <unknown>
E           #6 0x55e90d172403 <unknown>
E           #7 0x55e90d13eb02 <unknown>
E           #8 0x55e90d13f7c1 <unknown>
E           #9 0x55e90d63f448 <unknown>
E           #10 0x55e90d6432af <unknown>
E           #11 0x55e90d6268d9 <unknown>
E           #12 0x55e90d643e55 <unknown>
E           #13 0x55e90d60c13f <unknown>
E           #14 0x55e90d6684b8 <unknown>
E           #15 0x55e90d668693 <unknown>
E           #16 0x55e90d67a613 <unknown>
E           #17 0x7f435fc9caa4 <unknown>
E           #18 0x7f435fd29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:32,956 - INFO - Starting test with Chrome browser
2025-10-19 03:56:32,956 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:33,021 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:33,058 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:33,093 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:34,181 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55e90d67b67a <unknown>
#1 0x55e90d0fa566 <unknown>
#2 0x55e90d135b4c <unknown>
#3 0x55e90d1317c4 <unknown>
#4 0x55e90d180bd3 <unknown>
#5 0x55e90d180286 <unknown>
#6 0x55e90d172403 <unknown>
#7 0x55e90d13eb02 <unknown>
#8 0x55e90d13f7c1 <unknown>
#9 0x55e90d63f448 <unknown>
#10 0x55e90d6432af <unknown>
#11 0x55e90d6268d9 <unknown>
#12 0x55e90d643e55 <unknown>
#13 0x55e90d60c13f <unknown>
#14 0x55e90d6684b8 <unknown>
#15 0x55e90d668693 <unknown>
#16 0x55e90d67a613 <unknown>
#17 0x7f435fc9caa4 <unknown>
#18 0x7f435fd29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55e90d67b67a <unknown>
#1 0x55e90d0fa566 <unknown>
#2 0x55e90d135b4c <unknown>
#3 0x55e90d1317c4 <unknown>
#4 0x55e90d180bd3 <unknown>
#5 0x55e90d180286 <unknown>
#6 0x55e90d172403 <unknown>
#7 0x55e90d13eb02 <unknown>
#8 0x55e90d13f7c1 <unknown>
#9 0x55e90d63f448 <unknown>
#10 0x55e90d6432af <unknown>
#11 0x55e90d6268d9 <unknown>
#12 0x55e90d643e55 <unknown>
#13 0x55e90d60c13f <unknown>
#14 0x55e90d6684b8 <unknown>
#15 0x55e90d668693 <unknown>
#16 0x55e90d67a613 <unknown>
#17 0x7f435fc9caa4 <unknown>
#18 0x7f435fd29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username1] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155adc6b10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155920c050>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155adc6b10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155920c050>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155920c830>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155adc6b10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155920c710>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5627284d5613 \\u003Cunknown>\\n#17 0x7f3a3f69caa4 \\u003Cunknown>\\n#18 0x7f3a3f729c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5627284d667a <unknown>
E       #1 0x562727f55566 <unknown>
E       #2 0x562727f90b4c <unknown>
E       #3 0x562727f8c7c4 <unknown>
E       #4 0x562727fdbbd3 <unknown>
E       #5 0x562727fdb286 <unknown>
E       #6 0x562727fcd403 <unknown>
E       #7 0x562727f99b02 <unknown>
E       #8 0x562727f9a7c1 <unknown>
E       #9 0x56272849a448 <unknown>
E       #10 0x56272849e2af <unknown>
E       #11 0x5627284818d9 <unknown>
E       #12 0x56272849ee55 <unknown>
E       #13 0x56272846713f <unknown>
E       #14 0x5627284c34b8 <unknown>
E       #15 0x5627284c3693 <unknown>
E       #16 0x5627284d5613 <unknown>
E       #17 0x7f3a3f69caa4 <unknown>
E       #18 0x7f3a3f729c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5627284d667a <unknown>
E           #1 0x562727f55566 <unknown>
E           #2 0x562727f90b4c <unknown>
E           #3 0x562727f8c7c4 <unknown>
E           #4 0x562727fdbbd3 <unknown>
E           #5 0x562727fdb286 <unknown>
E           #6 0x562727fcd403 <unknown>
E           #7 0x562727f99b02 <unknown>
E           #8 0x562727f9a7c1 <unknown>
E           #9 0x56272849a448 <unknown>
E           #10 0x56272849e2af <unknown>
E           #11 0x5627284818d9 <unknown>
E           #12 0x56272849ee55 <unknown>
E           #13 0x56272846713f <unknown>
E           #14 0x5627284c34b8 <unknown>
E           #15 0x5627284c3693 <unknown>
E           #16 0x5627284d5613 <unknown>
E           #17 0x7f3a3f69caa4 <unknown>
E           #18 0x7f3a3f729c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:34,220 - INFO - Starting test with Chrome browser
2025-10-19 03:56:34,220 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:34,285 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:34,319 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:34,354 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:35,442 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5627284d667a <unknown>
#1 0x562727f55566 <unknown>
#2 0x562727f90b4c <unknown>
#3 0x562727f8c7c4 <unknown>
#4 0x562727fdbbd3 <unknown>
#5 0x562727fdb286 <unknown>
#6 0x562727fcd403 <unknown>
#7 0x562727f99b02 <unknown>
#8 0x562727f9a7c1 <unknown>
#9 0x56272849a448 <unknown>
#10 0x56272849e2af <unknown>
#11 0x5627284818d9 <unknown>
#12 0x56272849ee55 <unknown>
#13 0x56272846713f <unknown>
#14 0x5627284c34b8 <unknown>
#15 0x5627284c3693 <unknown>
#16 0x5627284d5613 <unknown>
#17 0x7f3a3f69caa4 <unknown>
#18 0x7f3a3f729c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5627284d667a <unknown>
#1 0x562727f55566 <unknown>
#2 0x562727f90b4c <unknown>
#3 0x562727f8c7c4 <unknown>
#4 0x562727fdbbd3 <unknown>
#5 0x562727fdb286 <unknown>
#6 0x562727fcd403 <unknown>
#7 0x562727f99b02 <unknown>
#8 0x562727f9a7c1 <unknown>
#9 0x56272849a448 <unknown>
#10 0x56272849e2af <unknown>
#11 0x5627284818d9 <unknown>
#12 0x56272849ee55 <unknown>
#13 0x56272846713f <unknown>
#14 0x5627284c34b8 <unknown>
#15 0x5627284c3693 <unknown>
#16 0x5627284d5613 <unknown>
#17 0x7f3a3f69caa4 <unknown>
#18 0x7f3a3f729c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username2] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155afb1370>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155afb1590>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155afb1370>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155afb1590>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155afb18c0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155afb1370>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155afb17b0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55df5a24c613 \\u003Cunknown>\\n#17 0x7fd80ea9caa4 \\u003Cunknown>\\n#18 0x7fd80eb29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55df5a24d67a <unknown>
E       #1 0x55df59ccc566 <unknown>
E       #2 0x55df59d07b4c <unknown>
E       #3 0x55df59d037c4 <unknown>
E       #4 0x55df59d52bd3 <unknown>
E       #5 0x55df59d52286 <unknown>
E       #6 0x55df59d44403 <unknown>
E       #7 0x55df59d10b02 <unknown>
E       #8 0x55df59d117c1 <unknown>
E       #9 0x55df5a211448 <unknown>
E       #10 0x55df5a2152af <unknown>
E       #11 0x55df5a1f88d9 <unknown>
E       #12 0x55df5a215e55 <unknown>
E       #13 0x55df5a1de13f <unknown>
E       #14 0x55df5a23a4b8 <unknown>
E       #15 0x55df5a23a693 <unknown>
E       #16 0x55df5a24c613 <unknown>
E       #17 0x7fd80ea9caa4 <unknown>
E       #18 0x7fd80eb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55df5a24d67a <unknown>
E           #1 0x55df59ccc566 <unknown>
E           #2 0x55df59d07b4c <unknown>
E           #3 0x55df59d037c4 <unknown>
E           #4 0x55df59d52bd3 <unknown>
E           #5 0x55df59d52286 <unknown>
E           #6 0x55df59d44403 <unknown>
E           #7 0x55df59d10b02 <unknown>
E           #8 0x55df59d117c1 <unknown>
E           #9 0x55df5a211448 <unknown>
E           #10 0x55df5a2152af <unknown>
E           #11 0x55df5a1f88d9 <unknown>
E           #12 0x55df5a215e55 <unknown>
E           #13 0x55df5a1de13f <unknown>
E           #14 0x55df5a23a4b8 <unknown>
E           #15 0x55df5a23a693 <unknown>
E           #16 0x55df5a24c613 <unknown>
E           #17 0x7fd80ea9caa4 <unknown>
E           #18 0x7fd80eb29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:35,481 - INFO - Starting test with Chrome browser
2025-10-19 03:56:35,481 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:35,546 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:35,581 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:35,618 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:36,706 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55df5a24d67a <unknown>
#1 0x55df59ccc566 <unknown>
#2 0x55df59d07b4c <unknown>
#3 0x55df59d037c4 <unknown>
#4 0x55df59d52bd3 <unknown>
#5 0x55df59d52286 <unknown>
#6 0x55df59d44403 <unknown>
#7 0x55df59d10b02 <unknown>
#8 0x55df59d117c1 <unknown>
#9 0x55df5a211448 <unknown>
#10 0x55df5a2152af <unknown>
#11 0x55df5a1f88d9 <unknown>
#12 0x55df5a215e55 <unknown>
#13 0x55df5a1de13f <unknown>
#14 0x55df5a23a4b8 <unknown>
#15 0x55df5a23a693 <unknown>
#16 0x55df5a24c613 <unknown>
#17 0x7fd80ea9caa4 <unknown>
#18 0x7fd80eb29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55df5a24d67a <unknown>
#1 0x55df59ccc566 <unknown>
#2 0x55df59d07b4c <unknown>
#3 0x55df59d037c4 <unknown>
#4 0x55df59d52bd3 <unknown>
#5 0x55df59d52286 <unknown>
#6 0x55df59d44403 <unknown>
#7 0x55df59d10b02 <unknown>
#8 0x55df59d117c1 <unknown>
#9 0x55df5a211448 <unknown>
#10 0x55df5a2152af <unknown>
#11 0x55df5a1f88d9 <unknown>
#12 0x55df5a215e55 <unknown>
#13 0x55df5a1de13f <unknown>
#14 0x55df5a23a4b8 <unknown>
#15 0x55df5a23a693 <unknown>
#16 0x55df5a24c613 <unknown>
#17 0x7fd80ea9caa4 <unknown>
#18 0x7fd80eb29c6c <unknown>
____________ ERROR at setup of test_invalid_email_login[username3] _____________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155addcd10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155addc8d0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155addcd10>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155addc8d0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155addce20>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155addcd10>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155addfbd0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5628f8f13613 \\u003Cunknown>\\n#17 0x7f68cba9caa4 \\u003Cunknown>\\n#18 0x7f68cbb29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5628f8f1467a <unknown>
E       #1 0x5628f8993566 <unknown>
E       #2 0x5628f89ceb4c <unknown>
E       #3 0x5628f89ca7c4 <unknown>
E       #4 0x5628f8a19bd3 <unknown>
E       #5 0x5628f8a19286 <unknown>
E       #6 0x5628f8a0b403 <unknown>
E       #7 0x5628f89d7b02 <unknown>
E       #8 0x5628f89d87c1 <unknown>
E       #9 0x5628f8ed8448 <unknown>
E       #10 0x5628f8edc2af <unknown>
E       #11 0x5628f8ebf8d9 <unknown>
E       #12 0x5628f8edce55 <unknown>
E       #13 0x5628f8ea513f <unknown>
E       #14 0x5628f8f014b8 <unknown>
E       #15 0x5628f8f01693 <unknown>
E       #16 0x5628f8f13613 <unknown>
E       #17 0x7f68cba9caa4 <unknown>
E       #18 0x7f68cbb29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_login[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5628f8f1467a <unknown>
E           #1 0x5628f8993566 <unknown>
E           #2 0x5628f89ceb4c <unknown>
E           #3 0x5628f89ca7c4 <unknown>
E           #4 0x5628f8a19bd3 <unknown>
E           #5 0x5628f8a19286 <unknown>
E           #6 0x5628f8a0b403 <unknown>
E           #7 0x5628f89d7b02 <unknown>
E           #8 0x5628f89d87c1 <unknown>
E           #9 0x5628f8ed8448 <unknown>
E           #10 0x5628f8edc2af <unknown>
E           #11 0x5628f8ebf8d9 <unknown>
E           #12 0x5628f8edce55 <unknown>
E           #13 0x5628f8ea513f <unknown>
E           #14 0x5628f8f014b8 <unknown>
E           #15 0x5628f8f01693 <unknown>
E           #16 0x5628f8f13613 <unknown>
E           #17 0x7f68cba9caa4 <unknown>
E           #18 0x7f68cbb29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:36,746 - INFO - Starting test with Chrome browser
2025-10-19 03:56:36,747 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:36,810 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:36,846 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:36,880 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:37,969 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5628f8f1467a <unknown>
#1 0x5628f8993566 <unknown>
#2 0x5628f89ceb4c <unknown>
#3 0x5628f89ca7c4 <unknown>
#4 0x5628f8a19bd3 <unknown>
#5 0x5628f8a19286 <unknown>
#6 0x5628f8a0b403 <unknown>
#7 0x5628f89d7b02 <unknown>
#8 0x5628f89d87c1 <unknown>
#9 0x5628f8ed8448 <unknown>
#10 0x5628f8edc2af <unknown>
#11 0x5628f8ebf8d9 <unknown>
#12 0x5628f8edce55 <unknown>
#13 0x5628f8ea513f <unknown>
#14 0x5628f8f014b8 <unknown>
#15 0x5628f8f01693 <unknown>
#16 0x5628f8f13613 <unknown>
#17 0x7f68cba9caa4 <unknown>
#18 0x7f68cbb29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5628f8f1467a <unknown>
#1 0x5628f8993566 <unknown>
#2 0x5628f89ceb4c <unknown>
#3 0x5628f89ca7c4 <unknown>
#4 0x5628f8a19bd3 <unknown>
#5 0x5628f8a19286 <unknown>
#6 0x5628f8a0b403 <unknown>
#7 0x5628f89d7b02 <unknown>
#8 0x5628f89d87c1 <unknown>
#9 0x5628f8ed8448 <unknown>
#10 0x5628f8edc2af <unknown>
#11 0x5628f8ebf8d9 <unknown>
#12 0x5628f8edce55 <unknown>
#13 0x5628f8ea513f <unknown>
#14 0x5628f8f014b8 <unknown>
#15 0x5628f8f01693 <unknown>
#16 0x5628f8f13613 <unknown>
#17 0x7f68cba9caa4 <unknown>
#18 0x7f68cbb29c6c <unknown>
_______________ ERROR at setup of test_blank_username_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae58f50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae58c50>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae58f50>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae58c50>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155ae58850>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae58f50>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155ae58350>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55d93c8cb613 \\u003Cunknown>\\n#17 0x7f95cf29caa4 \\u003Cunknown>\\n#18 0x7f95cf329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55d93c8cc67a <unknown>
E       #1 0x55d93c34b566 <unknown>
E       #2 0x55d93c386b4c <unknown>
E       #3 0x55d93c3827c4 <unknown>
E       #4 0x55d93c3d1bd3 <unknown>
E       #5 0x55d93c3d1286 <unknown>
E       #6 0x55d93c3c3403 <unknown>
E       #7 0x55d93c38fb02 <unknown>
E       #8 0x55d93c3907c1 <unknown>
E       #9 0x55d93c890448 <unknown>
E       #10 0x55d93c8942af <unknown>
E       #11 0x55d93c8778d9 <unknown>
E       #12 0x55d93c894e55 <unknown>
E       #13 0x55d93c85d13f <unknown>
E       #14 0x55d93c8b94b8 <unknown>
E       #15 0x55d93c8b9693 <unknown>
E       #16 0x55d93c8cb613 <unknown>
E       #17 0x7f95cf29caa4 <unknown>
E       #18 0x7f95cf329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_username_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55d93c8cc67a <unknown>
E           #1 0x55d93c34b566 <unknown>
E           #2 0x55d93c386b4c <unknown>
E           #3 0x55d93c3827c4 <unknown>
E           #4 0x55d93c3d1bd3 <unknown>
E           #5 0x55d93c3d1286 <unknown>
E           #6 0x55d93c3c3403 <unknown>
E           #7 0x55d93c38fb02 <unknown>
E           #8 0x55d93c3907c1 <unknown>
E           #9 0x55d93c890448 <unknown>
E           #10 0x55d93c8942af <unknown>
E           #11 0x55d93c8778d9 <unknown>
E           #12 0x55d93c894e55 <unknown>
E           #13 0x55d93c85d13f <unknown>
E           #14 0x55d93c8b94b8 <unknown>
E           #15 0x55d93c8b9693 <unknown>
E           #16 0x55d93c8cb613 <unknown>
E           #17 0x7f95cf29caa4 <unknown>
E           #18 0x7f95cf329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:38,008 - INFO - Starting test with Chrome browser
2025-10-19 03:56:38,008 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:38,072 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:38,107 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:38,143 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:39,231 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d93c8cc67a <unknown>
#1 0x55d93c34b566 <unknown>
#2 0x55d93c386b4c <unknown>
#3 0x55d93c3827c4 <unknown>
#4 0x55d93c3d1bd3 <unknown>
#5 0x55d93c3d1286 <unknown>
#6 0x55d93c3c3403 <unknown>
#7 0x55d93c38fb02 <unknown>
#8 0x55d93c3907c1 <unknown>
#9 0x55d93c890448 <unknown>
#10 0x55d93c8942af <unknown>
#11 0x55d93c8778d9 <unknown>
#12 0x55d93c894e55 <unknown>
#13 0x55d93c85d13f <unknown>
#14 0x55d93c8b94b8 <unknown>
#15 0x55d93c8b9693 <unknown>
#16 0x55d93c8cb613 <unknown>
#17 0x7f95cf29caa4 <unknown>
#18 0x7f95cf329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55d93c8cc67a <unknown>
#1 0x55d93c34b566 <unknown>
#2 0x55d93c386b4c <unknown>
#3 0x55d93c3827c4 <unknown>
#4 0x55d93c3d1bd3 <unknown>
#5 0x55d93c3d1286 <unknown>
#6 0x55d93c3c3403 <unknown>
#7 0x55d93c38fb02 <unknown>
#8 0x55d93c3907c1 <unknown>
#9 0x55d93c890448 <unknown>
#10 0x55d93c8942af <unknown>
#11 0x55d93c8778d9 <unknown>
#12 0x55d93c894e55 <unknown>
#13 0x55d93c85d13f <unknown>
#14 0x55d93c8b94b8 <unknown>
#15 0x55d93c8b9693 <unknown>
#16 0x55d93c8cb613 <unknown>
#17 0x7f95cf29caa4 <unknown>
#18 0x7f95cf329c6c <unknown>
_______________ ERROR at setup of test_blank_password_validation _______________

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae5a150>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae5a450>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae5a150>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae5a450>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155ae5a950>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae5a150>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155ae5a850>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x561929ff6613 \\u003Cunknown>\\n#17 0x7fac1e89caa4 \\u003Cunknown>\\n#18 0x7fac1e929c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x561929ff767a <unknown>
E       #1 0x561929a76566 <unknown>
E       #2 0x561929ab1b4c <unknown>
E       #3 0x561929aad7c4 <unknown>
E       #4 0x561929afcbd3 <unknown>
E       #5 0x561929afc286 <unknown>
E       #6 0x561929aee403 <unknown>
E       #7 0x561929abab02 <unknown>
E       #8 0x561929abb7c1 <unknown>
E       #9 0x561929fbb448 <unknown>
E       #10 0x561929fbf2af <unknown>
E       #11 0x561929fa28d9 <unknown>
E       #12 0x561929fbfe55 <unknown>
E       #13 0x561929f8813f <unknown>
E       #14 0x561929fe44b8 <unknown>
E       #15 0x561929fe4693 <unknown>
E       #16 0x561929ff6613 <unknown>
E       #17 0x7fac1e89caa4 <unknown>
E       #18 0x7fac1e929c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_blank_password_validation>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x561929ff767a <unknown>
E           #1 0x561929a76566 <unknown>
E           #2 0x561929ab1b4c <unknown>
E           #3 0x561929aad7c4 <unknown>
E           #4 0x561929afcbd3 <unknown>
E           #5 0x561929afc286 <unknown>
E           #6 0x561929aee403 <unknown>
E           #7 0x561929abab02 <unknown>
E           #8 0x561929abb7c1 <unknown>
E           #9 0x561929fbb448 <unknown>
E           #10 0x561929fbf2af <unknown>
E           #11 0x561929fa28d9 <unknown>
E           #12 0x561929fbfe55 <unknown>
E           #13 0x561929f8813f <unknown>
E           #14 0x561929fe44b8 <unknown>
E           #15 0x561929fe4693 <unknown>
E           #16 0x561929ff6613 <unknown>
E           #17 0x7fac1e89caa4 <unknown>
E           #18 0x7fac1e929c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:39,270 - INFO - Starting test with Chrome browser
2025-10-19 03:56:39,270 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:39,334 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:39,374 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:39,407 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:40,496 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x561929ff767a <unknown>
#1 0x561929a76566 <unknown>
#2 0x561929ab1b4c <unknown>
#3 0x561929aad7c4 <unknown>
#4 0x561929afcbd3 <unknown>
#5 0x561929afc286 <unknown>
#6 0x561929aee403 <unknown>
#7 0x561929abab02 <unknown>
#8 0x561929abb7c1 <unknown>
#9 0x561929fbb448 <unknown>
#10 0x561929fbf2af <unknown>
#11 0x561929fa28d9 <unknown>
#12 0x561929fbfe55 <unknown>
#13 0x561929f8813f <unknown>
#14 0x561929fe44b8 <unknown>
#15 0x561929fe4693 <unknown>
#16 0x561929ff6613 <unknown>
#17 0x7fac1e89caa4 <unknown>
#18 0x7fac1e929c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x561929ff767a <unknown>
#1 0x561929a76566 <unknown>
#2 0x561929ab1b4c <unknown>
#3 0x561929aad7c4 <unknown>
#4 0x561929afcbd3 <unknown>
#5 0x561929afc286 <unknown>
#6 0x561929aee403 <unknown>
#7 0x561929abab02 <unknown>
#8 0x561929abb7c1 <unknown>
#9 0x561929fbb448 <unknown>
#10 0x561929fbf2af <unknown>
#11 0x561929fa28d9 <unknown>
#12 0x561929fbfe55 <unknown>
#13 0x561929f8813f <unknown>
#14 0x561929fe44b8 <unknown>
#15 0x561929fe4693 <unknown>
#16 0x561929ff6613 <unknown>
#17 0x7fac1e89caa4 <unknown>
#18 0x7fac1e929c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username0] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae49b80>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae48e60>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae49b80>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae48e60>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155ae49040>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae49b80>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155ae49d60>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x565077ff8613 \\u003Cunknown>\\n#17 0x7f654529caa4 \\u003Cunknown>\\n#18 0x7f6545329c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x565077ff967a <unknown>
E       #1 0x565077a78566 <unknown>
E       #2 0x565077ab3b4c <unknown>
E       #3 0x565077aaf7c4 <unknown>
E       #4 0x565077afebd3 <unknown>
E       #5 0x565077afe286 <unknown>
E       #6 0x565077af0403 <unknown>
E       #7 0x565077abcb02 <unknown>
E       #8 0x565077abd7c1 <unknown>
E       #9 0x565077fbd448 <unknown>
E       #10 0x565077fc12af <unknown>
E       #11 0x565077fa48d9 <unknown>
E       #12 0x565077fc1e55 <unknown>
E       #13 0x565077f8a13f <unknown>
E       #14 0x565077fe64b8 <unknown>
E       #15 0x565077fe6693 <unknown>
E       #16 0x565077ff8613 <unknown>
E       #17 0x7f654529caa4 <unknown>
E       #18 0x7f6545329c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username0]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x565077ff967a <unknown>
E           #1 0x565077a78566 <unknown>
E           #2 0x565077ab3b4c <unknown>
E           #3 0x565077aaf7c4 <unknown>
E           #4 0x565077afebd3 <unknown>
E           #5 0x565077afe286 <unknown>
E           #6 0x565077af0403 <unknown>
E           #7 0x565077abcb02 <unknown>
E           #8 0x565077abd7c1 <unknown>
E           #9 0x565077fbd448 <unknown>
E           #10 0x565077fc12af <unknown>
E           #11 0x565077fa48d9 <unknown>
E           #12 0x565077fc1e55 <unknown>
E           #13 0x565077f8a13f <unknown>
E           #14 0x565077fe64b8 <unknown>
E           #15 0x565077fe6693 <unknown>
E           #16 0x565077ff8613 <unknown>
E           #17 0x7f654529caa4 <unknown>
E           #18 0x7f6545329c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:40,536 - INFO - Starting test with Chrome browser
2025-10-19 03:56:40,536 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:40,601 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:40,635 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:40,670 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:41,760 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x565077ff967a <unknown>
#1 0x565077a78566 <unknown>
#2 0x565077ab3b4c <unknown>
#3 0x565077aaf7c4 <unknown>
#4 0x565077afebd3 <unknown>
#5 0x565077afe286 <unknown>
#6 0x565077af0403 <unknown>
#7 0x565077abcb02 <unknown>
#8 0x565077abd7c1 <unknown>
#9 0x565077fbd448 <unknown>
#10 0x565077fc12af <unknown>
#11 0x565077fa48d9 <unknown>
#12 0x565077fc1e55 <unknown>
#13 0x565077f8a13f <unknown>
#14 0x565077fe64b8 <unknown>
#15 0x565077fe6693 <unknown>
#16 0x565077ff8613 <unknown>
#17 0x7f654529caa4 <unknown>
#18 0x7f6545329c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x565077ff967a <unknown>
#1 0x565077a78566 <unknown>
#2 0x565077ab3b4c <unknown>
#3 0x565077aaf7c4 <unknown>
#4 0x565077afebd3 <unknown>
#5 0x565077afe286 <unknown>
#6 0x565077af0403 <unknown>
#7 0x565077abcb02 <unknown>
#8 0x565077abd7c1 <unknown>
#9 0x565077fbd448 <unknown>
#10 0x565077fc12af <unknown>
#11 0x565077fa48d9 <unknown>
#12 0x565077fc1e55 <unknown>
#13 0x565077f8a13f <unknown>
#14 0x565077fe64b8 <unknown>
#15 0x565077fe6693 <unknown>
#16 0x565077ff8613 <unknown>
#17 0x7f654529caa4 <unknown>
#18 0x7f6545329c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username1] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae4a030>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae48500>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae4a030>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ae48500>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155ae48320>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ae4a030>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155ae48140>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55fe6ccd0613 \\u003Cunknown>\\n#17 0x7f876549caa4 \\u003Cunknown>\\n#18 0x7f8765529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55fe6ccd167a <unknown>
E       #1 0x55fe6c750566 <unknown>
E       #2 0x55fe6c78bb4c <unknown>
E       #3 0x55fe6c7877c4 <unknown>
E       #4 0x55fe6c7d6bd3 <unknown>
E       #5 0x55fe6c7d6286 <unknown>
E       #6 0x55fe6c7c8403 <unknown>
E       #7 0x55fe6c794b02 <unknown>
E       #8 0x55fe6c7957c1 <unknown>
E       #9 0x55fe6cc95448 <unknown>
E       #10 0x55fe6cc992af <unknown>
E       #11 0x55fe6cc7c8d9 <unknown>
E       #12 0x55fe6cc99e55 <unknown>
E       #13 0x55fe6cc6213f <unknown>
E       #14 0x55fe6ccbe4b8 <unknown>
E       #15 0x55fe6ccbe693 <unknown>
E       #16 0x55fe6ccd0613 <unknown>
E       #17 0x7f876549caa4 <unknown>
E       #18 0x7f8765529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username1]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55fe6ccd167a <unknown>
E           #1 0x55fe6c750566 <unknown>
E           #2 0x55fe6c78bb4c <unknown>
E           #3 0x55fe6c7877c4 <unknown>
E           #4 0x55fe6c7d6bd3 <unknown>
E           #5 0x55fe6c7d6286 <unknown>
E           #6 0x55fe6c7c8403 <unknown>
E           #7 0x55fe6c794b02 <unknown>
E           #8 0x55fe6c7957c1 <unknown>
E           #9 0x55fe6cc95448 <unknown>
E           #10 0x55fe6cc992af <unknown>
E           #11 0x55fe6cc7c8d9 <unknown>
E           #12 0x55fe6cc99e55 <unknown>
E           #13 0x55fe6cc6213f <unknown>
E           #14 0x55fe6ccbe4b8 <unknown>
E           #15 0x55fe6ccbe693 <unknown>
E           #16 0x55fe6ccd0613 <unknown>
E           #17 0x7f876549caa4 <unknown>
E           #18 0x7f8765529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:41,800 - INFO - Starting test with Chrome browser
2025-10-19 03:56:41,800 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:41,864 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:41,897 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:41,932 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:43,021 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55fe6ccd167a <unknown>
#1 0x55fe6c750566 <unknown>
#2 0x55fe6c78bb4c <unknown>
#3 0x55fe6c7877c4 <unknown>
#4 0x55fe6c7d6bd3 <unknown>
#5 0x55fe6c7d6286 <unknown>
#6 0x55fe6c7c8403 <unknown>
#7 0x55fe6c794b02 <unknown>
#8 0x55fe6c7957c1 <unknown>
#9 0x55fe6cc95448 <unknown>
#10 0x55fe6cc992af <unknown>
#11 0x55fe6cc7c8d9 <unknown>
#12 0x55fe6cc99e55 <unknown>
#13 0x55fe6cc6213f <unknown>
#14 0x55fe6ccbe4b8 <unknown>
#15 0x55fe6ccbe693 <unknown>
#16 0x55fe6ccd0613 <unknown>
#17 0x7f876549caa4 <unknown>
#18 0x7f8765529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55fe6ccd167a <unknown>
#1 0x55fe6c750566 <unknown>
#2 0x55fe6c78bb4c <unknown>
#3 0x55fe6c7877c4 <unknown>
#4 0x55fe6c7d6bd3 <unknown>
#5 0x55fe6c7d6286 <unknown>
#6 0x55fe6c7c8403 <unknown>
#7 0x55fe6c794b02 <unknown>
#8 0x55fe6c7957c1 <unknown>
#9 0x55fe6cc95448 <unknown>
#10 0x55fe6cc992af <unknown>
#11 0x55fe6cc7c8d9 <unknown>
#12 0x55fe6cc99e55 <unknown>
#13 0x55fe6cc6213f <unknown>
#14 0x55fe6ccbe4b8 <unknown>
#15 0x55fe6ccbe693 <unknown>
#16 0x55fe6ccd0613 <unknown>
#17 0x7f876549caa4 <unknown>
#18 0x7f8765529c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username2] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9b150>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ad9ac10>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9b150>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ad9ac10>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155ad997f0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9b150>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155ad99630>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x559690900613 \\u003Cunknown>\\n#17 0x7f113c09caa4 \\u003Cunknown>\\n#18 0x7f113c129c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55969090167a <unknown>
E       #1 0x559690380566 <unknown>
E       #2 0x5596903bbb4c <unknown>
E       #3 0x5596903b77c4 <unknown>
E       #4 0x559690406bd3 <unknown>
E       #5 0x559690406286 <unknown>
E       #6 0x5596903f8403 <unknown>
E       #7 0x5596903c4b02 <unknown>
E       #8 0x5596903c57c1 <unknown>
E       #9 0x5596908c5448 <unknown>
E       #10 0x5596908c92af <unknown>
E       #11 0x5596908ac8d9 <unknown>
E       #12 0x5596908c9e55 <unknown>
E       #13 0x55969089213f <unknown>
E       #14 0x5596908ee4b8 <unknown>
E       #15 0x5596908ee693 <unknown>
E       #16 0x559690900613 <unknown>
E       #17 0x7f113c09caa4 <unknown>
E       #18 0x7f113c129c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username2]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55969090167a <unknown>
E           #1 0x559690380566 <unknown>
E           #2 0x5596903bbb4c <unknown>
E           #3 0x5596903b77c4 <unknown>
E           #4 0x559690406bd3 <unknown>
E           #5 0x559690406286 <unknown>
E           #6 0x5596903f8403 <unknown>
E           #7 0x5596903c4b02 <unknown>
E           #8 0x5596903c57c1 <unknown>
E           #9 0x5596908c5448 <unknown>
E           #10 0x5596908c92af <unknown>
E           #11 0x5596908ac8d9 <unknown>
E           #12 0x5596908c9e55 <unknown>
E           #13 0x55969089213f <unknown>
E           #14 0x5596908ee4b8 <unknown>
E           #15 0x5596908ee693 <unknown>
E           #16 0x559690900613 <unknown>
E           #17 0x7f113c09caa4 <unknown>
E           #18 0x7f113c129c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:43,061 - INFO - Starting test with Chrome browser
2025-10-19 03:56:43,062 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:43,127 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:43,161 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:43,200 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:44,288 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55969090167a <unknown>
#1 0x559690380566 <unknown>
#2 0x5596903bbb4c <unknown>
#3 0x5596903b77c4 <unknown>
#4 0x559690406bd3 <unknown>
#5 0x559690406286 <unknown>
#6 0x5596903f8403 <unknown>
#7 0x5596903c4b02 <unknown>
#8 0x5596903c57c1 <unknown>
#9 0x5596908c5448 <unknown>
#10 0x5596908c92af <unknown>
#11 0x5596908ac8d9 <unknown>
#12 0x5596908c9e55 <unknown>
#13 0x55969089213f <unknown>
#14 0x5596908ee4b8 <unknown>
#15 0x5596908ee693 <unknown>
#16 0x559690900613 <unknown>
#17 0x7f113c09caa4 <unknown>
#18 0x7f113c129c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55969090167a <unknown>
#1 0x559690380566 <unknown>
#2 0x5596903bbb4c <unknown>
#3 0x5596903b77c4 <unknown>
#4 0x559690406bd3 <unknown>
#5 0x559690406286 <unknown>
#6 0x5596903f8403 <unknown>
#7 0x5596903c4b02 <unknown>
#8 0x5596903c57c1 <unknown>
#9 0x5596908c5448 <unknown>
#10 0x5596908c92af <unknown>
#11 0x5596908ac8d9 <unknown>
#12 0x5596908c9e55 <unknown>
#13 0x55969089213f <unknown>
#14 0x5596908ee4b8 <unknown>
#15 0x5596908ee693 <unknown>
#16 0x559690900613 <unknown>
#17 0x7f113c09caa4 <unknown>
#18 0x7f113c129c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username3] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9bbd0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ad9bcb0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9bbd0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155ad9bcb0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155aed0130>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155ad9bbd0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155aed03d0>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x55dba4089613 \\u003Cunknown>\\n#17 0x7f9042e9caa4 \\u003Cunknown>\\n#18 0x7f9042f29c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x55dba408a67a <unknown>
E       #1 0x55dba3b09566 <unknown>
E       #2 0x55dba3b44b4c <unknown>
E       #3 0x55dba3b407c4 <unknown>
E       #4 0x55dba3b8fbd3 <unknown>
E       #5 0x55dba3b8f286 <unknown>
E       #6 0x55dba3b81403 <unknown>
E       #7 0x55dba3b4db02 <unknown>
E       #8 0x55dba3b4e7c1 <unknown>
E       #9 0x55dba404e448 <unknown>
E       #10 0x55dba40522af <unknown>
E       #11 0x55dba40358d9 <unknown>
E       #12 0x55dba4052e55 <unknown>
E       #13 0x55dba401b13f <unknown>
E       #14 0x55dba40774b8 <unknown>
E       #15 0x55dba4077693 <unknown>
E       #16 0x55dba4089613 <unknown>
E       #17 0x7f9042e9caa4 <unknown>
E       #18 0x7f9042f29c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username3]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x55dba408a67a <unknown>
E           #1 0x55dba3b09566 <unknown>
E           #2 0x55dba3b44b4c <unknown>
E           #3 0x55dba3b407c4 <unknown>
E           #4 0x55dba3b8fbd3 <unknown>
E           #5 0x55dba3b8f286 <unknown>
E           #6 0x55dba3b81403 <unknown>
E           #7 0x55dba3b4db02 <unknown>
E           #8 0x55dba3b4e7c1 <unknown>
E           #9 0x55dba404e448 <unknown>
E           #10 0x55dba40522af <unknown>
E           #11 0x55dba40358d9 <unknown>
E           #12 0x55dba4052e55 <unknown>
E           #13 0x55dba401b13f <unknown>
E           #14 0x55dba40774b8 <unknown>
E           #15 0x55dba4077693 <unknown>
E           #16 0x55dba4089613 <unknown>
E           #17 0x7f9042e9caa4 <unknown>
E           #18 0x7f9042f29c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:44,327 - INFO - Starting test with Chrome browser
2025-10-19 03:56:44,327 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:44,391 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:44,428 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:44,462 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:45,550 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55dba408a67a <unknown>
#1 0x55dba3b09566 <unknown>
#2 0x55dba3b44b4c <unknown>
#3 0x55dba3b407c4 <unknown>
#4 0x55dba3b8fbd3 <unknown>
#5 0x55dba3b8f286 <unknown>
#6 0x55dba3b81403 <unknown>
#7 0x55dba3b4db02 <unknown>
#8 0x55dba3b4e7c1 <unknown>
#9 0x55dba404e448 <unknown>
#10 0x55dba40522af <unknown>
#11 0x55dba40358d9 <unknown>
#12 0x55dba4052e55 <unknown>
#13 0x55dba401b13f <unknown>
#14 0x55dba40774b8 <unknown>
#15 0x55dba4077693 <unknown>
#16 0x55dba4089613 <unknown>
#17 0x7f9042e9caa4 <unknown>
#18 0x7f9042f29c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x55dba408a67a <unknown>
#1 0x55dba3b09566 <unknown>
#2 0x55dba3b44b4c <unknown>
#3 0x55dba3b407c4 <unknown>
#4 0x55dba3b8fbd3 <unknown>
#5 0x55dba3b8f286 <unknown>
#6 0x55dba3b81403 <unknown>
#7 0x55dba3b4db02 <unknown>
#8 0x55dba3b4e7c1 <unknown>
#9 0x55dba404e448 <unknown>
#10 0x55dba40522af <unknown>
#11 0x55dba40358d9 <unknown>
#12 0x55dba4052e55 <unknown>
#13 0x55dba401b13f <unknown>
#14 0x55dba40774b8 <unknown>
#15 0x55dba4077693 <unknown>
#16 0x55dba4089613 <unknown>
#17 0x7f9042e9caa4 <unknown>
#18 0x7f9042f29c6c <unknown>
__________ ERROR at setup of test_invalid_email_validation[username4] __________

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
>               _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)

tests/test_signup_login/conftest.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
options = <selenium.webdriver.chrome.options.Options object at 0x7f155af2c2c0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155af2fad0>
keep_alive = True

    def __init__(
        self,
        options: Options = None,
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new instance of the chrome driver. Starts the service and
        then creates new instance of chrome driver.
    
        :Args:
         - options - this takes an instance of ChromeOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.
        """
        service = service if service else Service()
        options = options if options else Options()
    
>       super().__init__(
            browser_name=DesiredCapabilities.CHROME["browserName"],
            vendor_prefix="goog",
            options=options,
            service=service,
            keep_alive=keep_alive,
        )

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chrome/webdriver.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
browser_name = 'chrome', vendor_prefix = 'goog'
options = <selenium.webdriver.chrome.options.Options object at 0x7f155af2c2c0>
service = <selenium.webdriver.chrome.service.Service object at 0x7f155af2fad0>
keep_alive = True

    def __init__(
        self,
        browser_name: str = None,
        vendor_prefix: str = None,
        options: ArgOptions = ArgOptions(),
        service: Service = None,
        keep_alive: bool = True,
    ) -> None:
        """Creates a new WebDriver instance of the ChromiumDriver. Starts the
        service and then creates new WebDriver instance of ChromiumDriver.
    
        :Args:
         - browser_name - Browser name used when matching capabilities.
         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.
         - options - this takes an instance of ChromiumOptions
         - service - Service object for handling the browser driver if you need to pass extra details
         - keep_alive - Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.
        """
        self.service = service
    
        finder = DriverFinder(self.service, options)
        if finder.get_browser_path():
            options.binary_location = finder.get_browser_path()
            options.browser_version = None
    
        self.service.path = self.service.env_path() or finder.get_driver_path()
        self.service.start()
    
        executor = ChromiumRemoteConnection(
            remote_server_addr=self.service.service_url,
            browser_name=browser_name,
            vendor_prefix=vendor_prefix,
            keep_alive=keep_alive,
            ignore_proxy=options._ignore_local_proxy,
        )
    
        try:
>           super().__init__(command_executor=executor, options=options)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/chromium/webdriver.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
command_executor = <selenium.webdriver.chromium.remote_connection.ChromiumRemoteConnection object at 0x7f155af2fba0>
keep_alive = True, file_detector = None
options = <selenium.webdriver.chrome.options.Options object at 0x7f155af2c2c0>
locator_converter = None, web_element_cls = None, client_config = None

    def __init__(
        self,
        command_executor: Union[str, RemoteConnection] = "http://127.0.0.1:4444",
        keep_alive: bool = True,
        file_detector: Optional[FileDetector] = None,
        options: Optional[Union[BaseOptions, List[BaseOptions]]] = None,
        locator_converter: Optional[LocatorConverter] = None,
        web_element_cls: Optional[type] = None,
        client_config: Optional[ClientConfig] = None,
    ) -> None:
        """Create a new driver that will issue commands using the wire
        protocol.
    
        Parameters:
        ----------
        command_executor : str or remote_connection.RemoteConnection
            - Either a string representing the URL of the remote server or a custom
            remote_connection.RemoteConnection object. Defaults to 'http://127.0.0.1:4444/wd/hub'.
        keep_alive : bool (Deprecated)
            - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive. Defaults to True.
        file_detector : object or None
            - Pass a custom file detector object during instantiation. If None, the default LocalFileDetector() will be used.
        options : options.Options
            - Instance of a driver options.Options class.
        locator_converter : object or None
            - Custom locator converter to use. Defaults to None.
        web_element_cls : class
            - Custom class to use for web elements. Defaults to WebElement.
        client_config : object or None
            - Custom client configuration to use. Defaults to None.
        """
    
        if isinstance(options, list):
            capabilities = create_matches(options)
            _ignore_local_proxy = False
        else:
            capabilities = options.to_capabilities()
            _ignore_local_proxy = options._ignore_local_proxy
        self.command_executor = command_executor
        if isinstance(self.command_executor, (str, bytes)):
            self.command_executor = get_remote_connection(
                capabilities,
                command_executor=command_executor,
                keep_alive=keep_alive,
                ignore_local_proxy=_ignore_local_proxy,
                client_config=client_config,
            )
        self._is_remote = True
        self.session_id = None
        self.caps = {}
        self.pinned_scripts = {}
        self.error_handler = ErrorHandler()
        self._switch_to = SwitchTo(self)
        self._mobile = Mobile(self)
        self.file_detector = file_detector or LocalFileDetector()
        self.locator_converter = locator_converter or LocatorConverter()
        self._web_element_cls = web_element_cls or self._web_element_cls
        self._authenticator_id = None
        self.start_client()
>       self.start_session(capabilities)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
capabilities = {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sandbox', '--disable-dev-shm-usage', ...ing'], 'extensions': []}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}

    def start_session(self, capabilities: dict) -> None:
        """Creates a new session with the desired capabilities.
    
        Parameters:
        ----------
        capabilities : dict
            - A capabilities dict to start the session with.
        """
    
        caps = _create_caps(capabilities)
>       response = self.execute(Command.NEW_SESSION, caps)["value"]

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="None")>
driver_command = 'newSession'
params = {'capabilities': {'alwaysMatch': {'browserName': 'chrome', 'goog:chromeOptions': {'args': ['--disable-gpu', '--no-sand...]}, 'pageLoadStrategy': <PageLoadStrategy.normal: 'normal'>, 'unhandledPromptBehavior': 'accept'}, 'firstMatch': [{}]}}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        Parameters:
        ----------
        driver_command : str
            - The name of the command to execute as a string.
    
        params : dict
            - A dictionary of named Parameters to send with the command.
    
        Returns:
        --------
          dict - The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x7f155af2fc70>
response = {'status': 500, 'value': '{"value":{"error":"session not created","message":"session not created: probably user data d...\\n#16 0x5598597b8613 \\u003Cunknown>\\n#17 0x7f592649caa4 \\u003Cunknown>\\n#18 0x7f5926529c6c \\u003Cunknown>\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.SessionNotCreatedException: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E       Stacktrace:
E       #0 0x5598597b967a <unknown>
E       #1 0x559859238566 <unknown>
E       #2 0x559859273b4c <unknown>
E       #3 0x55985926f7c4 <unknown>
E       #4 0x5598592bebd3 <unknown>
E       #5 0x5598592be286 <unknown>
E       #6 0x5598592b0403 <unknown>
E       #7 0x55985927cb02 <unknown>
E       #8 0x55985927d7c1 <unknown>
E       #9 0x55985977d448 <unknown>
E       #10 0x5598597812af <unknown>
E       #11 0x5598597648d9 <unknown>
E       #12 0x559859781e55 <unknown>
E       #13 0x55985974a13f <unknown>
E       #14 0x5598597a64b8 <unknown>
E       #15 0x5598597a6693 <unknown>
E       #16 0x5598597b8613 <unknown>
E       #17 0x7f592649caa4 <unknown>
E       #18 0x7f5926529c6c <unknown>

/opt/hostedtoolcache/Python/3.13.8/x64/lib/python3.13/site-packages/selenium/webdriver/remote/errorhandler.py:232: SessionNotCreatedException

During handling of the above exception, another exception occurred:

request = <SubRequest 'sign_login_setup' for <Function test_invalid_email_validation[username4]>>

    @pytest.fixture
    def sign_login_setup(request):
        browser = BROWSER.lower()
        _driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            # 1. Driver setup
            if browser == "chrome":
                options = ChromeOptions()
                #options.add_argument("--headless=new")
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                _driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    
            elif browser == "firefox":
                options = FirefoxOptions()
                _driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
    
            elif browser == "edge":
                options = EdgeOptions()
                _driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
    
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            _driver.maximize_window()
            _driver.implicitly_wait(3)
    
            # 2. URL selection logic
            is_registration = request.node.get_closest_marker("is_registration")
            if is_registration:
                _driver.get(REGISTRATION_URL)
                logger.info(f"Navigated to registration: {REGISTRATION_URL}")
            else:
                _driver.get(URL)
                logger.info(f"Navigated to URL: {URL}")
    
            yield _driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
E           Stacktrace:
E           #0 0x5598597b967a <unknown>
E           #1 0x559859238566 <unknown>
E           #2 0x559859273b4c <unknown>
E           #3 0x55985926f7c4 <unknown>
E           #4 0x5598592bebd3 <unknown>
E           #5 0x5598592be286 <unknown>
E           #6 0x5598592b0403 <unknown>
E           #7 0x55985927cb02 <unknown>
E           #8 0x55985927d7c1 <unknown>
E           #9 0x55985977d448 <unknown>
E           #10 0x5598597812af <unknown>
E           #11 0x5598597648d9 <unknown>
E           #12 0x559859781e55 <unknown>
E           #13 0x55985974a13f <unknown>
E           #14 0x5598597a64b8 <unknown>
E           #15 0x5598597a6693 <unknown>
E           #16 0x5598597b8613 <unknown>
E           #17 0x7f592649caa4 <unknown>
E           #18 0x7f5926529c6c <unknown>

tests/test_signup_login/conftest.py:122: Failed
---------------------------- Captured stderr setup -----------------------------
2025-10-19 03:56:45,589 - INFO - Starting test with Chrome browser
2025-10-19 03:56:45,590 - INFO - ====== WebDriver manager ======
2025-10-19 03:56:45,654 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:45,689 - INFO - Get LATEST chromedriver version for google-chrome
2025-10-19 03:56:45,723 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
2025-10-19 03:56:46,812 - ERROR - Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5598597b967a <unknown>
#1 0x559859238566 <unknown>
#2 0x559859273b4c <unknown>
#3 0x55985926f7c4 <unknown>
#4 0x5598592bebd3 <unknown>
#5 0x5598592be286 <unknown>
#6 0x5598592b0403 <unknown>
#7 0x55985927cb02 <unknown>
#8 0x55985927d7c1 <unknown>
#9 0x55985977d448 <unknown>
#10 0x5598597812af <unknown>
#11 0x5598597648d9 <unknown>
#12 0x559859781e55 <unknown>
#13 0x55985974a13f <unknown>
#14 0x5598597a64b8 <unknown>
#15 0x5598597a6693 <unknown>
#16 0x5598597b8613 <unknown>
#17 0x7f592649caa4 <unknown>
#18 0x7f5926529c6c <unknown>

------------------------------ Captured log setup ------------------------------
INFO     tests.test_signup_login.conftest:conftest.py:77 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/141.0.7390.78/chromedriver-linux64/chromedriver] found in cache
ERROR    tests.test_signup_login.conftest:conftest.py:121 Driver setup failed: Message: session not created: probably user data directory is already in use, please specify a unique value for --user-data-dir argument, or don't use --user-data-dir
Stacktrace:
#0 0x5598597b967a <unknown>
#1 0x559859238566 <unknown>
#2 0x559859273b4c <unknown>
#3 0x55985926f7c4 <unknown>
#4 0x5598592bebd3 <unknown>
#5 0x5598592be286 <unknown>
#6 0x5598592b0403 <unknown>
#7 0x55985927cb02 <unknown>
#8 0x55985927d7c1 <unknown>
#9 0x55985977d448 <unknown>
#10 0x5598597812af <unknown>
#11 0x5598597648d9 <unknown>
#12 0x559859781e55 <unknown>
#13 0x55985974a13f <unknown>
#14 0x5598597a64b8 <unknown>
#15 0x5598597a6693 <unknown>
#16 0x5598597b8613 <unknown>
#17 0x7f592649caa4 <unknown>
#18 0x7f5926529c6c <unknown>
- Generated html report: file:///home/runner/work/Mocha_accounting/Mocha_accounting/C%3A%5CUsers%5CTaurus13%5CPycharmProjects%5CPythonProject%5Creports/20251019_035625/report.html -
============================= 15 errors in 21.62s ==============================
=== LOGIN TESTS COMPLETED ===
Exit Code: 1
