========== Linting Errors ==========
0
========== End of Linting ==========
============================================
Test Run Started: 2025-09-20 03:43:14
--------------------------------------------
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.3.5, pluggy-1.6.0 -- /opt/hostedtoolcache/Python/3.13.7/x64/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.13.7', 'Platform': 'Linux-6.11.0-1018-azure-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.6.0'}, 'Plugins': {'Faker': '37.8.0', 'rerunfailures': '16.0.1', 'metadata': '3.1.1', 'xdist': '3.8.0', 'html': '4.1.1'}, 'CI': 'true', 'JAVA_HOME': '/usr/lib/jvm/temurin-17-jdk-amd64'}
rootdir: /home/runner/work/Mocha_accounting/Mocha_accounting
plugins: Faker-37.8.0, rerunfailures-16.0.1, metadata-3.1.1, xdist-3.8.0, html-4.1.1
collecting ... collected 19 items

tests/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] FAILED [  5%]
tests/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] FAILED [ 10%]
tests/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] FAILED [ 15%]
tests/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] ERROR [ 21%]
tests/test_login.py::test_invalid_email_login[username0] ERROR           [ 26%]
tests/test_login.py::test_invalid_email_login[username1] ERROR           [ 31%]
tests/test_login.py::test_invalid_email_login[username2] FAILED          [ 36%]
tests/test_login.py::test_invalid_email_login[username3] FAILED          [ 42%]
tests/test_login.py::test_invalid_password_login[ranjeet.gupta@mochatechnologies.com-Password@123] FAILED [ 47%]
tests/test_login.py::test_invalid_password_login[samatakamble9@gmail.com-Password@12] ERROR [ 52%]
tests/test_login.py::test_invalid_password_login[shubhamdabir07@gmail.com-Password] FAILED [ 57%]
tests/test_login.py::test_invalid_password_login[hrishikesh.shinde1607@gmail.com-payer@1234] FAILED [ 63%]
tests/test_login.py::test_blank_username_validation PASSED               [ 68%]
tests/test_login.py::test_blank_password_validation PASSED               [ 73%]
tests/test_login.py::test_invalid_email_validation[username0] PASSED     [ 78%]
tests/test_login.py::test_invalid_email_validation[username1] PASSED     [ 84%]
tests/test_login.py::test_invalid_email_validation[username2] PASSED     [ 89%]
tests/test_login.py::test_invalid_email_validation[username3] PASSED     [ 94%]
tests/test_login.py::test_invalid_email_validation[username4] PASSED     [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] _

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f2964cf49d0>
conn = <urllib3.connection.HTTPConnection object at 0x7f2964cf4b00>
method = 'POST', url = '/session/b3b8f18a065b5befd2a6cf539437782c/url'
body = '{"url": "https://app.mochaaccounting.com/login"}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.30.0 (python linux)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=120, read=120, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connection.py:565: in getresponse
    httplib_response = super().getresponse()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:1430: in getresponse
    response.begin()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:331: in begin
    version, status, reason = self._read_status()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x7f296679a590>
b = <memory at 0x7f2964c99a80>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        try:
>           return self._sock.recv_into(b)
E           TimeoutError: timed out

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/socket.py:719: TimeoutError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
>           driver.get(URL)

conftest.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:454: in get
    self.execute(Command.GET, {"url": url})
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:427: in execute
    response = self.command_executor.execute(driver_command, params)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:404: in execute
    return self._request(command_info[0], url, body=data)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:428: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:143: in request
    return self.request_encode_body(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/util.py:39: in reraise
    raise value
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:787: in urlopen
    response = self._make_request(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f2964cf49d0>
err = TimeoutError('timed out')
url = '/session/b3b8f18a065b5befd2a6cf539437782c/url', timeout_value = 120

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:367: ReadTimeoutError

During handling of the above exception, another exception occurred:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
            driver.get(URL)
            logger.info(f"Navigated to URL: {URL}")
    
            if ENABLE_LOGIN:
                login(driver)
    
            yield driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)

conftest.py:127: Failed
---------------------------- Captured stderr setup -----------------------------
2025-09-20 03:49:49,789 - INFO - Starting test with Chrome browser
2025-09-20 03:49:49,789 - INFO - ====== WebDriver manager ======
2025-09-20 03:49:49,854 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:49:49,891 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:49:49,923 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 03:51:50,286 - ERROR - Driver setup failed: HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)
2025-09-20 03:51:50,286 - INFO - Closing browser
2025-09-20 03:53:50,387 - WARNING - Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)")': /session/b3b8f18a065b5befd2a6cf539437782c
2025-09-20 03:55:50,412 - WARNING - Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)")': /session/b3b8f18a065b5befd2a6cf539437782c
2025-09-20 03:57:50,513 - WARNING - Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)")': /session/b3b8f18a065b5befd2a6cf539437782c
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
ERROR    conftest:conftest.py:126 Driver setup failed: HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)
INFO     conftest:conftest.py:132 Closing browser
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)")': /session/b3b8f18a065b5befd2a6cf539437782c
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)")': /session/b3b8f18a065b5befd2a6cf539437782c
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)")': /session/b3b8f18a065b5befd2a6cf539437782c
____________ ERROR at setup of test_invalid_email_login[username0] _____________

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f2964cf68b0>
conn = <urllib3.connection.HTTPConnection object at 0x7f2964d268b0>
method = 'POST', url = '/session/5ebd412f8047c9feff686cd70e10d237/url'
body = '{"url": "https://app.mochaaccounting.com/login"}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.30.0 (python linux)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=120, read=120, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connection.py:565: in getresponse
    httplib_response = super().getresponse()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:1430: in getresponse
    response.begin()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:331: in begin
    version, status, reason = self._read_status()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x7f2966770160>
b = <memory at 0x7f2964c9a680>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        try:
>           return self._sock.recv_into(b)
E           TimeoutError: timed out

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/socket.py:719: TimeoutError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
>           driver.get(URL)

conftest.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:454: in get
    self.execute(Command.GET, {"url": url})
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:427: in execute
    response = self.command_executor.execute(driver_command, params)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:404: in execute
    return self._request(command_info[0], url, body=data)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:428: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:143: in request
    return self.request_encode_body(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/util.py:39: in reraise
    raise value
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:787: in urlopen
    response = self._make_request(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f2964cf68b0>
err = TimeoutError('timed out')
url = '/session/5ebd412f8047c9feff686cd70e10d237/url', timeout_value = 120

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:367: ReadTimeoutError

During handling of the above exception, another exception occurred:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
            driver.get(URL)
            logger.info(f"Navigated to URL: {URL}")
    
            if ENABLE_LOGIN:
                login(driver)
    
            yield driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)

conftest.py:127: Failed
---------------------------- Captured stderr setup -----------------------------
2025-09-20 03:59:51,569 - INFO - Starting test with Chrome browser
2025-09-20 03:59:51,569 - INFO - ====== WebDriver manager ======
2025-09-20 03:59:51,639 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:59:51,675 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:59:51,709 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:01:52,122 - ERROR - Driver setup failed: HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)
2025-09-20 04:01:52,122 - INFO - Closing browser
2025-09-20 04:03:52,192 - WARNING - Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)")': /session/5ebd412f8047c9feff686cd70e10d237
2025-09-20 04:05:52,288 - WARNING - Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)")': /session/5ebd412f8047c9feff686cd70e10d237
2025-09-20 04:07:52,389 - WARNING - Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)")': /session/5ebd412f8047c9feff686cd70e10d237
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
ERROR    conftest:conftest.py:126 Driver setup failed: HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)
INFO     conftest:conftest.py:132 Closing browser
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)")': /session/5ebd412f8047c9feff686cd70e10d237
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)")': /session/5ebd412f8047c9feff686cd70e10d237
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)")': /session/5ebd412f8047c9feff686cd70e10d237
____________ ERROR at setup of test_invalid_email_login[username1] _____________

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f29668e7e30>
conn = <urllib3.connection.HTTPConnection object at 0x7f2964d25bf0>
method = 'POST', url = '/session/d368bb28048611618f3456066d912759/url'
body = '{"url": "https://app.mochaaccounting.com/login"}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.30.0 (python linux)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=120, read=120, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connection.py:565: in getresponse
    httplib_response = super().getresponse()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:1430: in getresponse
    response.begin()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:331: in begin
    version, status, reason = self._read_status()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x7f2966767f40>
b = <memory at 0x7f2964c9b4c0>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        try:
>           return self._sock.recv_into(b)
E           TimeoutError: timed out

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/socket.py:719: TimeoutError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
>           driver.get(URL)

conftest.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:454: in get
    self.execute(Command.GET, {"url": url})
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:427: in execute
    response = self.command_executor.execute(driver_command, params)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:404: in execute
    return self._request(command_info[0], url, body=data)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:428: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:143: in request
    return self.request_encode_body(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/util.py:39: in reraise
    raise value
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:787: in urlopen
    response = self._make_request(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f29668e7e30>
err = TimeoutError('timed out')
url = '/session/d368bb28048611618f3456066d912759/url', timeout_value = 120

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:367: ReadTimeoutError

During handling of the above exception, another exception occurred:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
            driver.get(URL)
            logger.info(f"Navigated to URL: {URL}")
    
            if ENABLE_LOGIN:
                login(driver)
    
            yield driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)

conftest.py:127: Failed
---------------------------- Captured stderr setup -----------------------------
2025-09-20 04:09:53,320 - INFO - Starting test with Chrome browser
2025-09-20 04:09:53,320 - INFO - ====== WebDriver manager ======
2025-09-20 04:09:53,386 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:09:53,425 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:09:53,461 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:11:53,862 - ERROR - Driver setup failed: HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)
2025-09-20 04:11:53,863 - INFO - Closing browser
2025-09-20 04:13:53,952 - WARNING - Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)")': /session/d368bb28048611618f3456066d912759
2025-09-20 04:15:54,017 - WARNING - Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)")': /session/d368bb28048611618f3456066d912759
2025-09-20 04:17:54,114 - WARNING - Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)")': /session/d368bb28048611618f3456066d912759
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
ERROR    conftest:conftest.py:126 Driver setup failed: HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)
INFO     conftest:conftest.py:132 Closing browser
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)")': /session/d368bb28048611618f3456066d912759
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)")': /session/d368bb28048611618f3456066d912759
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)")': /session/d368bb28048611618f3456066d912759
_ ERROR at setup of test_invalid_password_login[samatakamble9@gmail.com-Password@12] _

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f2964cfb650>
conn = <urllib3.connection.HTTPConnection object at 0x7f2966a3d7b0>
method = 'POST', url = '/session/7f95eab89e201e4c5b121051b4743c22/url'
body = '{"url": "https://app.mochaaccounting.com/login"}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.30.0 (python linux)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=120, read=120, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connection.py:565: in getresponse
    httplib_response = super().getresponse()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:1430: in getresponse
    response.begin()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:331: in begin
    version, status, reason = self._read_status()
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/http/client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x7f2966780b50>
b = <memory at 0x7f2964fbc640>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        try:
>           return self._sock.recv_into(b)
E           TimeoutError: timed out

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/socket.py:719: TimeoutError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
>           driver.get(URL)

conftest.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:454: in get
    self.execute(Command.GET, {"url": url})
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/webdriver.py:427: in execute
    response = self.command_executor.execute(driver_command, params)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:404: in execute
    return self._request(command_info[0], url, body=data)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/remote/remote_connection.py:428: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:143: in request
    return self.request_encode_body(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/util/util.py:39: in reraise
    raise value
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:787: in urlopen
    response = self._make_request(
/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7f2964cfb650>
err = TimeoutError('timed out')
url = '/session/7f95eab89e201e4c5b121051b4743c22/url', timeout_value = 120

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/urllib3/connectionpool.py:367: ReadTimeoutError

During handling of the above exception, another exception occurred:

    @pytest.fixture(scope="function")
    def setup():
        browser = BROWSER.lower()
        driver = None
        logger.info(f"Starting test with {browser.capitalize()} browser")
    
        try:
            if browser == "chrome":
                options = ChromeOptions()
                options.add_argument("--disable-gpu")
                options.add_argument("--no-sandbox")
                options.add_argument("--disable-dev-shm-usage")
                options.add_argument("--force-device-scale-factor=0.85")
                options.add_argument("--headless=new")
                options.add_argument("--disable-extensions")
                options.add_argument("--remote-debugging-port=9222")
                options.add_experimental_option("excludeSwitches", ["enable-logging"])
                options.set_capability("unhandledPromptBehavior", "accept")
                options.add_argument(f"--user-data-dir={mkdtemp()}")
                driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
            elif browser == "firefox":
                options = FirefoxOptions()
                driver = webdriver.Firefox(service=FirefoxService(GeckoDriverManager().install()), options=options)
            elif browser == "edge":
                options = EdgeOptions()
                driver = webdriver.Edge(service=EdgeService(EdgeChromiumDriverManager().install()), options=options)
            else:
                raise ValueError(f"Unsupported browser: {browser}")
    
            driver.maximize_window()
            driver.implicitly_wait(30)
            driver.get(URL)
            logger.info(f"Navigated to URL: {URL}")
    
            if ENABLE_LOGIN:
                login(driver)
    
            yield driver
    
        except Exception as e:
            logger.error(f"Driver setup failed: {e}")
>           pytest.fail(f"Driver setup failed: {e}")
E           Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)

conftest.py:127: Failed
---------------------------- Captured stderr setup -----------------------------
2025-09-20 04:26:08,532 - INFO - Starting test with Chrome browser
2025-09-20 04:26:08,532 - INFO - ====== WebDriver manager ======
2025-09-20 04:26:08,597 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:26:08,632 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:26:08,664 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:28:09,072 - ERROR - Driver setup failed: HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)
2025-09-20 04:28:09,072 - INFO - Closing browser
2025-09-20 04:30:09,146 - WARNING - Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)")': /session/7f95eab89e201e4c5b121051b4743c22
2025-09-20 04:32:09,223 - WARNING - Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)")': /session/7f95eab89e201e4c5b121051b4743c22
2025-09-20 04:34:09,268 - WARNING - Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)")': /session/7f95eab89e201e4c5b121051b4743c22
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
ERROR    conftest:conftest.py:126 Driver setup failed: HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)
INFO     conftest:conftest.py:132 Closing browser
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)")': /session/7f95eab89e201e4c5b121051b4743c22
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)")': /session/7f95eab89e201e4c5b121051b4743c22
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)")': /session/7f95eab89e201e4c5b121051b4743c22
=================================== FAILURES ===================================
________ test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] ________

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="53fbe90f85a656e06e5c7760711efcff")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = 'ranjeet.gupta@mochatechnologies.com', password = 'Ais@1234'

    @pytest.mark.parametrize("username, password", zip(valid_username, valid_password))
    def test_valid_login(setup, login_test_data, username, password):
       # expectedmessage = login_test_data['expectederrormsg']
        driver = setup
        login_page = LoginPage(driver)
        logger.info("Starting the test case for valid credentials")
        login_page.enter_username(username)
        logger.info("User enters the email-id")
        login_page.enter_password(password)
        logger.info("User enters the password")
>       login_page.click_loginbutton()

tests/test_login.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="53fbe90f85a656e06e5c7760711efcff")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2964fdc900>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x5618302dbcba <unknown>
E       #1 0x56182fd508e0 <unknown>
E       #2 0x56182fda2580 <unknown>
E       #3 0x56182fda2771 <unknown>
E       #4 0x56182fdf0864 <unknown>
E       #5 0x56182fdc809d <unknown>
E       #6 0x56182fdedc63 <unknown>
E       #7 0x56182fdc7e43 <unknown>
E       #8 0x56182fd949a8 <unknown>
E       #9 0x56182fd95621 <unknown>
E       #10 0x56183029f8b8 <unknown>
E       #11 0x5618302a35e2 <unknown>
E       #12 0x561830286683 <unknown>
E       #13 0x5618302a4135 <unknown>
E       #14 0x56183026b80f <unknown>
E       #15 0x5618302c84c8 <unknown>
E       #16 0x5618302c86a2 <unknown>
E       #17 0x5618302dadc3 <unknown>
E       #18 0x7f089089caa4 <unknown>
E       #19 0x7f0890929c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 03:43:17,435 - INFO - Test data loaded successfully.
2025-09-20 03:43:17,435 - INFO - Starting test with Chrome browser
2025-09-20 03:43:17,435 - INFO - ====== WebDriver manager ======
2025-09-20 03:43:19,934 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:43:19,971 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:43:20,005 - INFO - There is no [linux64] chromedriver "140.0.7339.185" for browser google-chrome "140.0.7339" in cache
2025-09-20 03:43:20,005 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:43:20,103 - INFO - WebDriver version 140.0.7339.185 selected
2025-09-20 03:43:20,107 - INFO - Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/140.0.7339.185/linux64/chromedriver-linux64.zip
2025-09-20 03:43:20,107 - INFO - About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/140.0.7339.185/linux64/chromedriver-linux64.zip
2025-09-20 03:43:20,149 - INFO - Driver downloading response is 200
2025-09-20 03:43:20,209 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:43:20,357 - INFO - Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185]
2025-09-20 03:43:35,561 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:79 Test data loaded successfully.
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 There is no [linux64] chromedriver "140.0.7339.185" for browser google-chrome "140.0.7339" in cache
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 WebDriver version 140.0.7339.185 selected
INFO     WDM:logger.py:11 Modern chrome version https://storage.googleapis.com/chrome-for-testing-public/140.0.7339.185/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 About to download new driver from https://storage.googleapis.com/chrome-for-testing-public/140.0.7339.185/linux64/chromedriver-linux64.zip
INFO     WDM:logger.py:11 Driver downloading response is 200
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver has been saved in cache [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185]
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
----------------------------- Captured stderr call -----------------------------
2025-09-20 03:43:35,562 - INFO - Starting the test case for valid credentials
2025-09-20 03:43:35,930 - INFO - User enters the email-id
2025-09-20 03:43:37,559 - INFO - User enters the password
------------------------------ Captured log call -------------------------------
INFO     tests.test_login:test_login.py:36 Starting the test case for valid credentials
INFO     tests.test_login:test_login.py:38 User enters the email-id
INFO     tests.test_login:test_login.py:40 User enters the password
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 03:45:39,177 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
_____________ test_valid_login[samatakamble9@gmail.com-Samata@16] ______________

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="6ca46cffcc51615f197b34601d1a84d9")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = 'samatakamble9@gmail.com', password = 'Samata@16'

    @pytest.mark.parametrize("username, password", zip(valid_username, valid_password))
    def test_valid_login(setup, login_test_data, username, password):
       # expectedmessage = login_test_data['expectederrormsg']
        driver = setup
        login_page = LoginPage(driver)
        logger.info("Starting the test case for valid credentials")
        login_page.enter_username(username)
        logger.info("User enters the email-id")
        login_page.enter_password(password)
        logger.info("User enters the password")
>       login_page.click_loginbutton()

tests/test_login.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="6ca46cffcc51615f197b34601d1a84d9")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2964d618a0>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55b7ff789cba <unknown>
E       #1 0x55b7ff1fe8e0 <unknown>
E       #2 0x55b7ff250580 <unknown>
E       #3 0x55b7ff250771 <unknown>
E       #4 0x55b7ff29e864 <unknown>
E       #5 0x55b7ff27609d <unknown>
E       #6 0x55b7ff29bc63 <unknown>
E       #7 0x55b7ff275e43 <unknown>
E       #8 0x55b7ff2429a8 <unknown>
E       #9 0x55b7ff243621 <unknown>
E       #10 0x55b7ff74d8b8 <unknown>
E       #11 0x55b7ff7515e2 <unknown>
E       #12 0x55b7ff734683 <unknown>
E       #13 0x55b7ff752135 <unknown>
E       #14 0x55b7ff71980f <unknown>
E       #15 0x55b7ff7764c8 <unknown>
E       #16 0x55b7ff7766a2 <unknown>
E       #17 0x55b7ff788dc3 <unknown>
E       #18 0x7fe5c4a9caa4 <unknown>
E       #19 0x7fe5c4b29c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 03:45:39,362 - INFO - Starting test with Chrome browser
2025-09-20 03:45:39,363 - INFO - ====== WebDriver manager ======
2025-09-20 03:45:39,428 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:45:39,462 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:45:39,532 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 03:45:41,061 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
----------------------------- Captured stderr call -----------------------------
2025-09-20 03:45:41,062 - INFO - Starting the test case for valid credentials
2025-09-20 03:45:41,220 - INFO - User enters the email-id
2025-09-20 03:45:42,889 - INFO - User enters the password
------------------------------ Captured log call -------------------------------
INFO     tests.test_login:test_login.py:36 Starting the test case for valid credentials
INFO     tests.test_login:test_login.py:38 User enters the email-id
INFO     tests.test_login:test_login.py:40 User enters the password
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 03:47:44,566 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
___________ test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] ____________

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="68b635d0ff88bae5c107d3daa60ec9f1")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = 'shubhamdabir07@gmail.com', password = 'Shubham@1234'

    @pytest.mark.parametrize("username, password", zip(valid_username, valid_password))
    def test_valid_login(setup, login_test_data, username, password):
       # expectedmessage = login_test_data['expectederrormsg']
        driver = setup
        login_page = LoginPage(driver)
        logger.info("Starting the test case for valid credentials")
        login_page.enter_username(username)
        logger.info("User enters the email-id")
        login_page.enter_password(password)
        logger.info("User enters the password")
>       login_page.click_loginbutton()

tests/test_login.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="68b635d0ff88bae5c107d3daa60ec9f1")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f29668623e0>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55b6b1040cba <unknown>
E       #1 0x55b6b0ab58e0 <unknown>
E       #2 0x55b6b0b07580 <unknown>
E       #3 0x55b6b0b07771 <unknown>
E       #4 0x55b6b0b55864 <unknown>
E       #5 0x55b6b0b2d09d <unknown>
E       #6 0x55b6b0b52c63 <unknown>
E       #7 0x55b6b0b2ce43 <unknown>
E       #8 0x55b6b0af99a8 <unknown>
E       #9 0x55b6b0afa621 <unknown>
E       #10 0x55b6b10048b8 <unknown>
E       #11 0x55b6b10085e2 <unknown>
E       #12 0x55b6b0feb683 <unknown>
E       #13 0x55b6b1009135 <unknown>
E       #14 0x55b6b0fd080f <unknown>
E       #15 0x55b6b102d4c8 <unknown>
E       #16 0x55b6b102d6a2 <unknown>
E       #17 0x55b6b103fdc3 <unknown>
E       #18 0x7f1966c9caa4 <unknown>
E       #19 0x7f1966d29c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 03:47:44,630 - INFO - Starting test with Chrome browser
2025-09-20 03:47:44,631 - INFO - ====== WebDriver manager ======
2025-09-20 03:47:44,698 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:47:44,732 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 03:47:44,766 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 03:47:46,278 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
----------------------------- Captured stderr call -----------------------------
2025-09-20 03:47:46,279 - INFO - Starting the test case for valid credentials
2025-09-20 03:47:46,427 - INFO - User enters the email-id
2025-09-20 03:47:48,070 - INFO - User enters the password
------------------------------ Captured log call -------------------------------
INFO     tests.test_login:test_login.py:36 Starting the test case for valid credentials
INFO     tests.test_login:test_login.py:38 User enters the email-id
INFO     tests.test_login:test_login.py:40 User enters the password
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 03:49:49,731 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
_____________________ test_invalid_email_login[username2] ______________________

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="f4d75aa71d4604d7af726cf4e29f3b0f")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = ('payerash10@gmail.com',)

    @pytest.mark.parametrize("username", zip(invalid_username))
    def test_invalid_email_login(setup, login_test_data,username):
        driver= setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        #login_page.enter_password(password)
>       login_page.click_loginbutton()

tests/test_login.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="f4d75aa71d4604d7af726cf4e29f3b0f")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2966a413a0>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55738f1d6cba <unknown>
E       #1 0x55738ec4b8e0 <unknown>
E       #2 0x55738ec9d580 <unknown>
E       #3 0x55738ec9d771 <unknown>
E       #4 0x55738eceb864 <unknown>
E       #5 0x55738ecc309d <unknown>
E       #6 0x55738ece8c63 <unknown>
E       #7 0x55738ecc2e43 <unknown>
E       #8 0x55738ec8f9a8 <unknown>
E       #9 0x55738ec90621 <unknown>
E       #10 0x55738f19a8b8 <unknown>
E       #11 0x55738f19e5e2 <unknown>
E       #12 0x55738f181683 <unknown>
E       #13 0x55738f19f135 <unknown>
E       #14 0x55738f16680f <unknown>
E       #15 0x55738f1c34c8 <unknown>
E       #16 0x55738f1c36a2 <unknown>
E       #17 0x55738f1d5dc3 <unknown>
E       #18 0x7f7aada9caa4 <unknown>
E       #19 0x7f7aadb29c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 04:19:55,488 - INFO - Starting test with Chrome browser
2025-09-20 04:19:55,489 - INFO - ====== WebDriver manager ======
2025-09-20 04:19:55,553 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:19:55,590 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:19:55,622 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:19:57,229 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 04:21:58,977 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
_____________________ test_invalid_email_login[username3] ______________________

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="a1db8ad8f665c7a4d9e0c2fe824588f4")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = ('payer@gmail.com',)

    @pytest.mark.parametrize("username", zip(invalid_username))
    def test_invalid_email_login(setup, login_test_data,username):
        driver= setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        #login_page.enter_password(password)
>       login_page.click_loginbutton()

tests/test_login.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="a1db8ad8f665c7a4d9e0c2fe824588f4")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2966a42660>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55760757ecba <unknown>
E       #1 0x557606ff38e0 <unknown>
E       #2 0x557607045580 <unknown>
E       #3 0x557607045771 <unknown>
E       #4 0x557607093864 <unknown>
E       #5 0x55760706b09d <unknown>
E       #6 0x557607090c63 <unknown>
E       #7 0x55760706ae43 <unknown>
E       #8 0x5576070379a8 <unknown>
E       #9 0x557607038621 <unknown>
E       #10 0x5576075428b8 <unknown>
E       #11 0x5576075465e2 <unknown>
E       #12 0x557607529683 <unknown>
E       #13 0x557607547135 <unknown>
E       #14 0x55760750e80f <unknown>
E       #15 0x55760756b4c8 <unknown>
E       #16 0x55760756b6a2 <unknown>
E       #17 0x55760757ddc3 <unknown>
E       #18 0x7f2bb149caa4 <unknown>
E       #19 0x7f2bb1529c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 04:22:00,033 - INFO - Starting test with Chrome browser
2025-09-20 04:22:00,034 - INFO - ====== WebDriver manager ======
2025-09-20 04:22:00,098 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:22:00,132 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:22:00,166 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:22:01,486 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 04:24:03,202 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
_ test_invalid_password_login[ranjeet.gupta@mochatechnologies.com-Password@123] _

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="64b63994283b93ccf5764a7fc0526bb9")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = 'ranjeet.gupta@mochatechnologies.com', password = 'Password@123'

    @pytest.mark.parametrize("username, password", zip(valid_username, invalid_password))
    def test_invalid_password_login(setup, login_test_data,username, password ):
        driver = setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.enter_password(password)
>       login_page.click_loginbutton()

tests/test_login.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="64b63994283b93ccf5764a7fc0526bb9")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2966a42840>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x556167327cba <unknown>
E       #1 0x556166d9c8e0 <unknown>
E       #2 0x556166dee580 <unknown>
E       #3 0x556166dee771 <unknown>
E       #4 0x556166e3c864 <unknown>
E       #5 0x556166e1409d <unknown>
E       #6 0x556166e39c63 <unknown>
E       #7 0x556166e13e43 <unknown>
E       #8 0x556166de09a8 <unknown>
E       #9 0x556166de1621 <unknown>
E       #10 0x5561672eb8b8 <unknown>
E       #11 0x5561672ef5e2 <unknown>
E       #12 0x5561672d2683 <unknown>
E       #13 0x5561672f0135 <unknown>
E       #14 0x5561672b780f <unknown>
E       #15 0x5561673144c8 <unknown>
E       #16 0x5561673146a2 <unknown>
E       #17 0x556167326dc3 <unknown>
E       #18 0x7f9942e9caa4 <unknown>
E       #19 0x7f9942f29c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 04:24:03,268 - INFO - Starting test with Chrome browser
2025-09-20 04:24:03,268 - INFO - ====== WebDriver manager ======
2025-09-20 04:24:03,333 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:24:03,368 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:24:03,400 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:24:04,986 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 04:26:08,465 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
________ test_invalid_password_login[shubhamdabir07@gmail.com-Password] ________

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="da2094c77a81c8ae132503b6c00d2409")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = 'shubhamdabir07@gmail.com', password = 'Password'

    @pytest.mark.parametrize("username, password", zip(valid_username, invalid_password))
    def test_invalid_password_login(setup, login_test_data,username, password ):
        driver = setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.enter_password(password)
>       login_page.click_loginbutton()

tests/test_login.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="da2094c77a81c8ae132503b6c00d2409")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2966a41300>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55bbab8d9cba <unknown>
E       #1 0x55bbab34e8e0 <unknown>
E       #2 0x55bbab3a0580 <unknown>
E       #3 0x55bbab3a0771 <unknown>
E       #4 0x55bbab3ee864 <unknown>
E       #5 0x55bbab3c609d <unknown>
E       #6 0x55bbab3ebc63 <unknown>
E       #7 0x55bbab3c5e43 <unknown>
E       #8 0x55bbab3929a8 <unknown>
E       #9 0x55bbab393621 <unknown>
E       #10 0x55bbab89d8b8 <unknown>
E       #11 0x55bbab8a15e2 <unknown>
E       #12 0x55bbab884683 <unknown>
E       #13 0x55bbab8a2135 <unknown>
E       #14 0x55bbab86980f <unknown>
E       #15 0x55bbab8c64c8 <unknown>
E       #16 0x55bbab8c66a2 <unknown>
E       #17 0x55bbab8d8dc3 <unknown>
E       #18 0x7fa88949caa4 <unknown>
E       #19 0x7fa889529c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 04:36:10,258 - INFO - Starting test with Chrome browser
2025-09-20 04:36:10,258 - INFO - ====== WebDriver manager ======
2025-09-20 04:36:10,323 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:36:10,360 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:36:10,391 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:36:12,334 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 04:38:15,843 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
___ test_invalid_password_login[hrishikesh.shinde1607@gmail.com-payer@1234] ____

setup = <selenium.webdriver.chrome.webdriver.WebDriver (session="d66dde1aa54371724f60714cce9084b8")>
login_test_data = {'expected_password_validation': 'Password is required', 'expected_username_validation': 'Email is required.', 'expect...ect_email_verification_msg': "Please check your email address. If you don't have an account, you can create one.", ...}
username = 'hrishikesh.shinde1607@gmail.com', password = 'payer@1234'

    @pytest.mark.parametrize("username, password", zip(valid_username, invalid_password))
    def test_invalid_password_login(setup, login_test_data,username, password ):
        driver = setup
        login_page = LoginPage(driver)
        login_page.enter_username(username)
        login_page.enter_password(password)
>       login_page.click_loginbutton()

tests/test_login.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/login_page.py:44: in click_loginbutton
    self.actions.wait_for_element(self.login_button)
actions/actions.py:71: in wait_for_element
    WebDriverWait(self.driver, timeout).until(EC.visibility_of_element_located(locator))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <selenium.webdriver.support.wait.WebDriverWait (session="d66dde1aa54371724f60714cce9084b8")>
method = <function visibility_of_element_located.<locals>._predicate at 0x7f2966a43b00>
message = ''

    def until(self, method: Callable[[D], Union[Literal[False], T]], message: str = "") -> T:
        """Wait until the method returns a value that is not False.
    
        Calls the method provided with the driver as an argument until the
        return value does not evaluate to ``False``.
    
        Parameters:
        ----------
        method: callable(WebDriver)
            - A callable object that takes a WebDriver instance as an argument.
    
        message: str
            - Optional message for :exc:`TimeoutException`
    
        Return:
        -------
        object: T
            - The result of the last call to `method`
    
        Raises:
        -------
        TimeoutException
            - If 'method' does not return a truthy value within the WebDriverWait
            object's timeout
    
        Example:
        --------
        >>> from selenium.webdriver.common.by import By
        >>> from selenium.webdriver.support.ui import WebDriverWait
        >>> from selenium.webdriver.support import expected_conditions as EC
    
        # Wait until an element is visible on the page
        >>> wait = WebDriverWait(driver, 10)
        >>> element = wait.until(EC.visibility_of_element_located((By.ID, "exampleId")))
        >>> print(element.text)
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
                value = method(self._driver)
                if value:
                    return value
            except self._ignored_exceptions as exc:
                screen = getattr(exc, "screen", None)
                stacktrace = getattr(exc, "stacktrace", None)
            if time.monotonic() > end_time:
                break
            time.sleep(self._poll)
>       raise TimeoutException(message, screen, stacktrace)
E       selenium.common.exceptions.TimeoutException: Message: 
E       Stacktrace:
E       #0 0x55a885281cba <unknown>
E       #1 0x55a884cf68e0 <unknown>
E       #2 0x55a884d48580 <unknown>
E       #3 0x55a884d48771 <unknown>
E       #4 0x55a884d96864 <unknown>
E       #5 0x55a884d6e09d <unknown>
E       #6 0x55a884d93c63 <unknown>
E       #7 0x55a884d6de43 <unknown>
E       #8 0x55a884d3a9a8 <unknown>
E       #9 0x55a884d3b621 <unknown>
E       #10 0x55a8852458b8 <unknown>
E       #11 0x55a8852495e2 <unknown>
E       #12 0x55a88522c683 <unknown>
E       #13 0x55a88524a135 <unknown>
E       #14 0x55a88521180f <unknown>
E       #15 0x55a88526e4c8 <unknown>
E       #16 0x55a88526e6a2 <unknown>
E       #17 0x55a885280dc3 <unknown>
E       #18 0x7efdcc09caa4 <unknown>
E       #19 0x7efdcc129c3c <unknown>

/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/selenium/webdriver/support/wait.py:146: TimeoutException
---------------------------- Captured stderr setup -----------------------------
2025-09-20 04:38:15,908 - INFO - Starting test with Chrome browser
2025-09-20 04:38:15,908 - INFO - ====== WebDriver manager ======
2025-09-20 04:38:15,975 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:38:16,112 - INFO - Get LATEST chromedriver version for google-chrome
2025-09-20 04:38:16,145 - INFO - Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
2025-09-20 04:38:17,480 - INFO - Navigated to URL: https://app.mochaaccounting.com/login
------------------------------ Captured log setup ------------------------------
INFO     conftest:conftest.py:90 Starting test with Chrome browser
INFO     WDM:logger.py:11 ====== WebDriver manager ======
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Get LATEST chromedriver version for google-chrome
INFO     WDM:logger.py:11 Driver [/home/runner/.wdm/drivers/chromedriver/linux64/140.0.7339.185/chromedriver-linux64/chromedriver] found in cache
INFO     conftest:conftest.py:118 Navigated to URL: https://app.mochaaccounting.com/login
--------------------------- Captured stderr teardown ---------------------------
2025-09-20 04:40:21,043 - INFO - Closing browser
---------------------------- Captured log teardown -----------------------------
INFO     conftest:conftest.py:132 Closing browser
- Generated html report: file:///home/runner/work/Mocha_accounting/Mocha_accounting/C%3A%5CUsers%5CTaurus13%5CPycharmProjects%5CPythonProject%5Creports/20250920_034317/report.html -
=========================== short test summary info ============================
FAILED tests/test_login.py::test_valid_login[ranjeet.gupta@mochatechnologies.com-Ais@1234] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x5618302dbcba <unknown>
#1 0x56182fd508e0 <unknown>
#2 0x56182fda2580 <unknown>
#3 0x56182fda2771 <unknown>
#4 0x56182fdf0864 <unknown>
#5 0x56182fdc809d <unknown>
#6 0x56182fdedc63 <unknown>
#7 0x56182fdc7e43 <unknown>
#8 0x56182fd949a8 <unknown>
#9 0x56182fd95621 <unknown>
#10 0x56183029f8b8 <unknown>
#11 0x5618302a35e2 <unknown>
#12 0x561830286683 <unknown>
#13 0x5618302a4135 <unknown>
#14 0x56183026b80f <unknown>
#15 0x5618302c84c8 <unknown>
#16 0x5618302c86a2 <unknown>
#17 0x5618302dadc3 <unknown>
#18 0x7f089089caa4 <unknown>
#19 0x7f0890929c3c <unknown>
FAILED tests/test_login.py::test_valid_login[samatakamble9@gmail.com-Samata@16] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x55b7ff789cba <unknown>
#1 0x55b7ff1fe8e0 <unknown>
#2 0x55b7ff250580 <unknown>
#3 0x55b7ff250771 <unknown>
#4 0x55b7ff29e864 <unknown>
#5 0x55b7ff27609d <unknown>
#6 0x55b7ff29bc63 <unknown>
#7 0x55b7ff275e43 <unknown>
#8 0x55b7ff2429a8 <unknown>
#9 0x55b7ff243621 <unknown>
#10 0x55b7ff74d8b8 <unknown>
#11 0x55b7ff7515e2 <unknown>
#12 0x55b7ff734683 <unknown>
#13 0x55b7ff752135 <unknown>
#14 0x55b7ff71980f <unknown>
#15 0x55b7ff7764c8 <unknown>
#16 0x55b7ff7766a2 <unknown>
#17 0x55b7ff788dc3 <unknown>
#18 0x7fe5c4a9caa4 <unknown>
#19 0x7fe5c4b29c3c <unknown>
FAILED tests/test_login.py::test_valid_login[shubhamdabir07@gmail.com-Shubham@1234] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x55b6b1040cba <unknown>
#1 0x55b6b0ab58e0 <unknown>
#2 0x55b6b0b07580 <unknown>
#3 0x55b6b0b07771 <unknown>
#4 0x55b6b0b55864 <unknown>
#5 0x55b6b0b2d09d <unknown>
#6 0x55b6b0b52c63 <unknown>
#7 0x55b6b0b2ce43 <unknown>
#8 0x55b6b0af99a8 <unknown>
#9 0x55b6b0afa621 <unknown>
#10 0x55b6b10048b8 <unknown>
#11 0x55b6b10085e2 <unknown>
#12 0x55b6b0feb683 <unknown>
#13 0x55b6b1009135 <unknown>
#14 0x55b6b0fd080f <unknown>
#15 0x55b6b102d4c8 <unknown>
#16 0x55b6b102d6a2 <unknown>
#17 0x55b6b103fdc3 <unknown>
#18 0x7f1966c9caa4 <unknown>
#19 0x7f1966d29c3c <unknown>
FAILED tests/test_login.py::test_invalid_email_login[username2] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x55738f1d6cba <unknown>
#1 0x55738ec4b8e0 <unknown>
#2 0x55738ec9d580 <unknown>
#3 0x55738ec9d771 <unknown>
#4 0x55738eceb864 <unknown>
#5 0x55738ecc309d <unknown>
#6 0x55738ece8c63 <unknown>
#7 0x55738ecc2e43 <unknown>
#8 0x55738ec8f9a8 <unknown>
#9 0x55738ec90621 <unknown>
#10 0x55738f19a8b8 <unknown>
#11 0x55738f19e5e2 <unknown>
#12 0x55738f181683 <unknown>
#13 0x55738f19f135 <unknown>
#14 0x55738f16680f <unknown>
#15 0x55738f1c34c8 <unknown>
#16 0x55738f1c36a2 <unknown>
#17 0x55738f1d5dc3 <unknown>
#18 0x7f7aada9caa4 <unknown>
#19 0x7f7aadb29c3c <unknown>
FAILED tests/test_login.py::test_invalid_email_login[username3] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x55760757ecba <unknown>
#1 0x557606ff38e0 <unknown>
#2 0x557607045580 <unknown>
#3 0x557607045771 <unknown>
#4 0x557607093864 <unknown>
#5 0x55760706b09d <unknown>
#6 0x557607090c63 <unknown>
#7 0x55760706ae43 <unknown>
#8 0x5576070379a8 <unknown>
#9 0x557607038621 <unknown>
#10 0x5576075428b8 <unknown>
#11 0x5576075465e2 <unknown>
#12 0x557607529683 <unknown>
#13 0x557607547135 <unknown>
#14 0x55760750e80f <unknown>
#15 0x55760756b4c8 <unknown>
#16 0x55760756b6a2 <unknown>
#17 0x55760757ddc3 <unknown>
#18 0x7f2bb149caa4 <unknown>
#19 0x7f2bb1529c3c <unknown>
FAILED tests/test_login.py::test_invalid_password_login[ranjeet.gupta@mochatechnologies.com-Password@123] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x556167327cba <unknown>
#1 0x556166d9c8e0 <unknown>
#2 0x556166dee580 <unknown>
#3 0x556166dee771 <unknown>
#4 0x556166e3c864 <unknown>
#5 0x556166e1409d <unknown>
#6 0x556166e39c63 <unknown>
#7 0x556166e13e43 <unknown>
#8 0x556166de09a8 <unknown>
#9 0x556166de1621 <unknown>
#10 0x5561672eb8b8 <unknown>
#11 0x5561672ef5e2 <unknown>
#12 0x5561672d2683 <unknown>
#13 0x5561672f0135 <unknown>
#14 0x5561672b780f <unknown>
#15 0x5561673144c8 <unknown>
#16 0x5561673146a2 <unknown>
#17 0x556167326dc3 <unknown>
#18 0x7f9942e9caa4 <unknown>
#19 0x7f9942f29c3c <unknown>
FAILED tests/test_login.py::test_invalid_password_login[shubhamdabir07@gmail.com-Password] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x55bbab8d9cba <unknown>
#1 0x55bbab34e8e0 <unknown>
#2 0x55bbab3a0580 <unknown>
#3 0x55bbab3a0771 <unknown>
#4 0x55bbab3ee864 <unknown>
#5 0x55bbab3c609d <unknown>
#6 0x55bbab3ebc63 <unknown>
#7 0x55bbab3c5e43 <unknown>
#8 0x55bbab3929a8 <unknown>
#9 0x55bbab393621 <unknown>
#10 0x55bbab89d8b8 <unknown>
#11 0x55bbab8a15e2 <unknown>
#12 0x55bbab884683 <unknown>
#13 0x55bbab8a2135 <unknown>
#14 0x55bbab86980f <unknown>
#15 0x55bbab8c64c8 <unknown>
#16 0x55bbab8c66a2 <unknown>
#17 0x55bbab8d8dc3 <unknown>
#18 0x7fa88949caa4 <unknown>
#19 0x7fa889529c3c <unknown>
FAILED tests/test_login.py::test_invalid_password_login[hrishikesh.shinde1607@gmail.com-payer@1234] - selenium.common.exceptions.TimeoutException: Message: 
Stacktrace:
#0 0x55a885281cba <unknown>
#1 0x55a884cf68e0 <unknown>
#2 0x55a884d48580 <unknown>
#3 0x55a884d48771 <unknown>
#4 0x55a884d96864 <unknown>
#5 0x55a884d6e09d <unknown>
#6 0x55a884d93c63 <unknown>
#7 0x55a884d6de43 <unknown>
#8 0x55a884d3a9a8 <unknown>
#9 0x55a884d3b621 <unknown>
#10 0x55a8852458b8 <unknown>
#11 0x55a8852495e2 <unknown>
#12 0x55a88522c683 <unknown>
#13 0x55a88524a135 <unknown>
#14 0x55a88521180f <unknown>
#15 0x55a88526e4c8 <unknown>
#16 0x55a88526e6a2 <unknown>
#17 0x55a885280dc3 <unknown>
#18 0x7efdcc09caa4 <unknown>
#19 0x7efdcc129c3c <unknown>
ERROR tests/test_login.py::test_valid_login[hrishikesh.shinde1607@gmail.com-Hrishikesh@1234] - Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=56583): Read timed out. (read timeout=120)
ERROR tests/test_login.py::test_invalid_email_login[username0] - Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=38381): Read timed out. (read timeout=120)
ERROR tests/test_login.py::test_invalid_email_login[username1] - Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=43667): Read timed out. (read timeout=120)
ERROR tests/test_login.py::test_invalid_password_login[samatakamble9@gmail.com-Password@12] - Failed: Driver setup failed: HTTPConnectionPool(host='localhost', port=36701): Read timed out. (read timeout=120)
============== 8 failed, 7 passed, 4 errors in 3437.48s (0:57:17) ==============
--------------------------------------------
Test Run Finished: 2025-09-20 04:40:34
Duration: 3440 seconds
Status: FAILURE
Exit Code: 1
============================================
